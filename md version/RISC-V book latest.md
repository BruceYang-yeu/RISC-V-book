![](media/image1.PNG){width="9.568459098862641in" height="7.39391404199475in"}参考卡
====================================================================================

![](media/image2.PNG){width="8.975694444444445in"
height="7.133333333333334in"}

**目录** {#目录 .TOC}
========

[[参考卡]{.underline} 1](#参考卡)

[[致谢]{.underline} 7](#致谢)

[[关于作者]{.underline} 9](#关于作者)

[[前言]{.underline} 10](#前言)

[[译者序]{.underline} 12](#译者序)

[[翻译团队]{.underline} 12](#翻译团队)

[[第一章 为什么要有RISC-V？]{.underline} 13](#第一章-为什么要有risc-v)

[[1.1 导言]{.underline} 13](#导言)

[[1.2 模块化与增量型ISA]{.underline} 14](#模块化与增量型isa)

[[1.3 ISA设计 101]{.underline} 15](#isa设计-101)

[[1.4 全书的总览]{.underline} 19](#全书的总览)

[[1.5 结束语]{.underline} 20](#结束语)

[[1.6 扩展阅读]{.underline} 21](#扩展阅读)

[[第二章 RV32I：RISC-V基础整数指令集]{.underline}
23](#第二章-rv32irisc-v基础整数指令集)

[[2.1 导言]{.underline} 23](#导言-1)

[[2.2 RV32I指令格式]{.underline} 23](#rv32i指令格式)

[[2.3 RV32I寄存器]{.underline} 26](#rv32i寄存器)

[[2.4 RV32I整数计算]{.underline} 27](#rv32i整数计算)

[[2.5 RV32I的Load和Store]{.underline} 29](#rv32i的load和store)

[[2.6 RV32I条件分支]{.underline} 30](#rv32i条件分支)

[[2.7 RV32I无条件跳转]{.underline} 31](#rv32i无条件跳转)

[[2.8 RV32I杂项]{.underline} 31](#rv32i杂项)

[[2.9 使用插入排序比较RV32I，ARM-32，MIPS-32和x86-32指令集]{.underline}
32](#使用插入排序比较rv32iarm-32mips-32和x86-32指令集)

[[2.10 结束语]{.underline} 32](#结束语-1)

[[2.11 扩展阅读]{.underline} 33](#扩展阅读-1)

[[第三章 RISC-V汇编语言]{.underline} 41](#第三章-risc-v汇编语言)

[[3.1 导言]{.underline} 41](#导言-2)

[[3.2 函数调用规范（Calling convention）]{.underline}
41](#函数调用规范calling-convention)

[[3.3 汇编器]{.underline} 43](#汇编器)

[[3.4 链接器]{.underline} 46](#链接器)

[[3.5 静态链接和动态链接]{.underline} 49](#静态链接和动态链接)

[[3.6 加载器]{.underline} 49](#加载器)

[[3.7 结束语]{.underline} 49](#结束语-2)

[[3.8 扩展阅读]{.underline} 50](#扩展阅读-2)

[[第四章 乘法和除法指令]{.underline} 51](#第四章-乘法和除法指令)

[[4.1 导言]{.underline} 51](#导言-3)

[[4.2 结束语]{.underline} 53](#结束语-3)

[[4.3 扩展阅读]{.underline} 53](#扩展阅读-3)

[[第五章 RV32F和RV32D：单精度和双精度浮点数]{.underline}
55](#第五章-rv32f和rv32d单精度和双精度浮点数)

[[5.1 导言]{.underline} 55](#导言-4)

[[5.2浮点寄存器]{.underline} 55](#浮点寄存器)

[[5.3浮点加载，存储和算术指令]{.underline} 56](#浮点加载存储和算术指令)

[[5.4浮点转换和搬运]{.underline} 60](#浮点转换和搬运)

[[5.5其他浮点指令]{.underline} 60](#其他浮点指令)

[[5.6使用DAXPY程序比较RV32FD，ARM-32，MIPS-32和x86-32]{.underline}
62](#使用daxpy程序比较rv32fdarm-32mips-32和x86-32)

[[5.7结束语]{.underline} 62](#结束语-4)

[[5.8 扩展阅读]{.underline} 62](#扩展阅读-4)

[[第六章 原子指令]{.underline} 65](#第六章-原子指令)

[[6.1 导言]{.underline} 65](#导言-5)

[[6.2 结束语]{.underline} 67](#结束语-5)

[[6.3 扩展阅读]{.underline} 67](#扩展阅读-5)

[[第七章 压缩指令]{.underline} 69](#第七章-压缩指令)

[[7.1 导言]{.underline} 69](#导言-6)

[[7.2 RV32GC，Thumb-2，microMIPS和x86-32的比较]{.underline}
71](#rv32gcthumb-2micromips和x86-32的比较)

[[7.3 结束语]{.underline} 71](#结束语-6)

[[7.4 扩展阅读]{.underline} 71](#扩展阅读-6)

[[第八章 向量]{.underline} 75](#第八章-向量)

[[8.1 导言]{.underline} 75](#导言-7)

[[8.2 向量计算指令]{.underline} 76](#向量计算指令)

[[8.3 向量寄存器和动态类型]{.underline} 76](#向量寄存器和动态类型)

[[8.4 向量的Load和Store操作]{.underline} 78](#向量的load和store操作)

[[8.5 向量操作期间的并行性]{.underline} 78](#向量操作期间的并行性)

[[8.6 向量运算的条件执行]{.underline} 79](#向量运算的条件执行)

[[8.7 其他向量指令]{.underline} 79](#其他向量指令)

[[8.8 例子：用RV32V写成的DAXPY程序]{.underline}
80](#例子用rv32v写成的daxpy程序)

[[8.9 RV32V，MIPS-32 MSA SIMD和x86-32 AVX SIMD的比较]{.underline}
81](#rv32vmips-32-msa-simd和x86-32-avx-simd的比较)

[[8.10 结束语]{.underline} 83](#结束语-7)

[[8.11 扩展阅读]{.underline} 84](#扩展阅读-7)

[[第九章 RV64：64位地址指令]{.underline} 87](#第九章-rv6464位地址指令)

[[9.1 导言]{.underline} 87](#导言-8)

[[9.2使用插入排序来比较RV64与其他64位ISA]{.underline}
91](#使用插入排序来比较rv64与其他64位isa)

[[9.3程序大小]{.underline} 93](#程序大小)

[[9.4结束语]{.underline} 93](#结束语-8)

[[9.5了解更多]{.underline} 94](#扩展阅读-8)

[[第十章 RV32/64特权架构]{.underline} 99](#第十章-rv3264特权架构)

[[10.1 导言]{.underline} 99](#导言-9)

[[10.2 简单嵌入式系统的机器模式]{.underline}
100](#简单嵌入式系统的机器模式)

[[10.3 机器模式下的异常处理]{.underline} 101](#机器模式下的异常处理)

[[10.4 嵌入式系统中的用户模式和进程隔离]{.underline}
104](#嵌入式系统中的用户模式和进程隔离)

[[10.5 现代操作系统的监管者模式]{.underline}
105](#现代操作系统的监管者模式)

[[10.6 基于页面的虚拟内存]{.underline} 106](#基于页面的虚拟内存)

[[10.7 结束语]{.underline} 110](#结束语-9)

[[10.8 扩展阅读]{.underline} 111](#扩展阅读-9)

[[第十一章 RISC-V未来的可选扩展]{.underline}
113](#第十一章-risc-v未来的可选扩展)

[[11.1 "B"标准扩展：位操作]{.underline} 113](#b标准扩展位操作)

[[11.2 "E"标准扩展：嵌入式]{.underline} 113](#e标准扩展嵌入式)

[[11.3 "H"特权态架构扩展：支持管理程序（Hypervisor）]{.underline}
113](#h特权态架构扩展支持管理程序hypervisor)

[[11.4 "J"标准扩展：动态翻译语言]{.underline}
113](#j标准扩展动态翻译语言)

[[11.5 "L"标准扩展：十进制浮点]{.underline} 113](#l标准扩展十进制浮点)

[[11.6 "N"标准扩展：用户态中断]{.underline} 113](#n标准扩展用户态中断)

[[11.7 "P"标准扩展：封装的单指令多数据（Packed-SIMD）指令]{.underline}
114](#p标准扩展封装的单指令多数据packed-simd指令)

[[11.8 "Q"标准扩展：四精度浮点]{.underline} 114](#q标准扩展四精度浮点)

[[11.9 结束语]{.underline} 114](#结束语-10)

[[附录A RISC-V指令列表]{.underline} 115](#附录a-risc-v指令列表)

对这本RISC-V手册的称赞

> 我喜欢RISC-V和这本书，因为它们优雅------简洁、扼要且完整。书中的评论无偿提供了一些历史，设计的动机，以及一些对于各种架构的批评。

------C. Gordan Bell，微软公司成员，Digital PDP-11和

VAX-11指令集架构的设计者

> 本书讲述了RISC-V可以做到什么，以及为什么它的设计师选择赋予它这些能力。更有趣的是，作者说出了为什么RISC-V省略了早期计算机中存在的一些东西。这些原因至少和RISC-V本身能做到什么与忽略了什么一样有意思。

------Ivan Sutherland，图灵奖获得者，被称作计算机图形学之父

> RISC-V会改变世界，这本书会助你成为改变的一部分。

------Michael B. Taylor，华盛顿大学教授

RISC-V是学生学习指令集架构和汇编级编程的理想选择，而它们是以后用高级语言工作的基础。这本写得很清楚的书提供了对RISC-V的很好的介绍，再加上一些对其演化历史的深刻见解及与其它常见架构的比较。以过去的指令集架构为鉴，RISC-V的设计者能够避免一些不必要的、不合理的特征，这让教学过程变得容易。即使它很简洁，它也足够强大，能在实际应用中广泛使用。很久以前我教过汇编编程的入门课，如果我现在去教这门课的话，我会很乐意用这本书作为教材。

------John Mashey，MIPS指令集架构的设计者之一

这本书对于任何使用RISC-V
ISA的人来说都是十分宝贵的参考。为了便于快速查阅，操作码按几种有用的格式呈现，这让编写和解释汇编代码变得简单。此外，对于如何使用这个ISA的解释和示例也让程序员的工作更容易。和其他ISA比较的部分很有意思，它们解释了RISC-V设计者们做出他们的设计决策的原因。

------Megan Wachs，博士，SiFive工程师

致谢
====

![](media/image3.png){width="2.954861111111111in" height="3.625in"}

David Patterson把这本书献给他的父母：

------给我的父亲David，我从他那儿继承了创造力、运动天赋和为正义奋斗的勇气；以及

------给我的母亲Lucy，我从她那儿继承了智慧、乐观和良好的性格。

感谢你们成为我如此伟大的榜样，你们让我明白了成为好的配偶、父亲和祖父的意义。

![](media/image4.PNG){width="2.952777777777778in"
height="4.441666666666666in"}

Andrew
Waterman把这本书献给他的父母John和Elizabeth，他们即便在千里之外也支持着他。

关于作者
========

> ![](media/image5.emf){width="1.1in"
> height="1.5055555555555555in"}David
> Patterson在加州大学伯克利分校担任计算机科学教授40年后于2016年退休，随后加入Google担任杰出工程师（distinguished
> engineer，Google的职位）。他还担任了RISC-V基金会董事会副主席。过去，他曾被任命为伯克利计算机科学部（Computer
> Science Division）主席，并当选为计算机研究协会（Computing Research
> Association）主席和计算机协会（ACM，Association for Computing
> Machinery）主席。在20世纪80年代，他领导了四代精简指令集计算机（RISC，Reduced
> Instruction Set Computer）项目，伯克利最新的RISC因此得名"RISC
> Five"。他和Andrew
> Waterman都是RISC-V四位架构师中的一员。除了RISC以外，他最著名的研究项目有廉价磁盘冗余阵列（RAID，Redundant
> Arrays of Inexpensive Disks）和工作站网络（NOW，Networks of
> Workstations）。这项研究让他发表了许多论文，出版了7本书，获得了超过35个荣誉，包括当选国家工程院和国家科学院院士，名列硅谷工程师名人堂，还成为了计算机历史博物馆、ACM、IEEE和两个AAAS组织的研究员。他的教学奖项包括杰出教学奖（加州大学伯克利分校），Karstrom杰出教育家奖（ACM），Mulligan教育奖章（IEEE）和本科教学奖（IEEE）。他还因为一本计算机体系结构方面的书和一本关于软件工程的书被文本和学术作家协会（Text
> and Academic Authors
> Association）授予计算机教科书卓越奖（"Texty"）。他在加州大学洛杉矶分校获得了他的所有学位，也被授予了杰出工程学院校友奖。他在南加州长大，乐趣是踢足球、和他的儿子一起骑自行车，以及和妻子在沙滩上散步。他们在高中时期就是情侣。在本书的测试版出版几天后，他们庆祝了50周年结婚纪念日。
>
> ![](media/image6.emf){width="1.108944663167104in"
> height="1.3740944881889763in"}Andrew
> Waterman是SiFive的总工程师和联合创始人。SiFive由RISC-V架构的创建者们建立，旨在提供基于RISC-V的低成本定制芯片。他在加州大学伯克利分校获得了计算机科学博士学位。在那里，他厌倦了现有的指令集架构的变幻莫测，于是共同设计了RISC-V
> ISA和第一台RISC-V微处理器。Andrew是基于开源RISC-V的Rocket芯片生成器、Chisel硬件构造语言以及Linux操作系统内核和GNU
> C编译器和C库的RISC-V端口的主要贡献者之一。他还有加州大学伯克利分校的硕士学位，这是RISC-V的RVC扩展的基础，他还有杜克大学的工学学士学位。

前言
====

**欢迎！**

RISC-V自2011年推出以来迅速地普及。我们认为一个精简的程序员指南将进一步促进它的发展，并促使新人理解为什么它是一个有吸引力的指令集，以及它与传统指令集架构(ISA)的不同。

我们的灵感部分来源于其它指令集架构书籍，但我们希望RISC-V自身的简洁性能让我们写得比See
MIPS
Run一类500多页的详尽书籍少很多。我们把全书的长度控制到了前述的三分之一，至少在这个意义上我们成功了。实际上，介绍模块化RISC-V指令集的每个组成部分的十章只用了100页------即便为了有助于快速阅读，平均每页用到了一张图片（一共75张）。

在解释指令集设计的原理之后，我们将阐述RISC-V架构师在设计指令集的时候，如何在过去40年的指令集的基础上取其精华，去其糟粕。要评判一个指令集架构，不仅要看它包括了什么，而且要看它省略了什么。

随后我们会按顺序介绍这个模块化架构的每个组成部分。每一章都会包含一个用RISC-V汇编语言写成的程序，这是为了展示那一章所述的指令的用法，这样有助于汇编语言程序员学习RISC-V汇编。有时，我们还会列出用ARM，MIPS和x86写成的同样的程序，从而突出RISC-V在简洁性，以及成本、功耗、性能方面的优势。

为了增加本书的趣味性，我们在页边加入了将近50个侧边栏，这里面放了一些有关书中内容的评论，希望它们能带来一些乐趣。我们还在页边放了大约75个图片，用于展示设计良好ISA的例子。（我们充分利用了侧边的空间！）最后，对于那些愿意钻研的读者，我们在全书中加入了大概25段补充说明。如果你对某个主题感兴趣，可以深入研究这些可选部分。略过这些部分不会影响对书中的其他内容的理解，所以如果你对他们不感兴趣的话，尽管跳过它们。对于计算机体系结构爱好者，我们援引的25篇论文和书籍能够开阔你的视野。在写这本书的过程中，我们从它们当中学到了很多东西！

**为什么引用了这么多名言？**

我们认为引用这些名言也能增加本书的趣味性，因此我们把这25个引用分散在整本书里。
它们同样是一种将智慧从前辈传递给初学者的有效机制，且有助于为良好的ISA设计设定文化标准。我们希望读者也能了解一点该领域的历史，这就是为什么我们在全书中引用了众多著名计算机科学家和工程师的名言。

**导言和参考**

我们打算将这本薄薄的书作为RISC-V的介绍和参考资料，供有兴趣编写RISC-V代码的学生和嵌入式系统程序员使用。本书假设读者事先已经了解过至少一个指令集。如果没有，您可能希望浏览基于RISC-V的相关入门架构手册：*Computer
Organization and Design RISC-V Edition: The Hardware Software
Interface。*

这本书中的参考资料包括：

-   **参考卡------**这个一页（两面）的RISC-V的精简描述囊括了RV32GCV和RV64GCV，同时包含了基本内容和所有已定义的指令扩展：RVI,
    RVM, RVA, RVF, RVD，甚至包括了尚处在开发阶段的RVV。

-   **指令图------**每个指令扩展的半页图形描述（它们是每章的第一个图）以同样的格式列出了所有RISC-V指令的全称，让大家可以轻松查看每条指令的不同变种。见图2.1、4.1、5.1、6.1、7.1、8.1、9.1、9.2、9.3和9.4。

-   **操作码映射------**这些表格在一页中显示了指令布局，操作码，格式类型和每页指令扩展的指令助记符。见图2.3、3.3、3.4、4.2、5.2、5.3、6.2、7.6、7.5、7.7、9.5和10.1。（这些指令图和操作码映射启发了我们在书的副标题中使用单词图集。）

-   **指令术语表------**附录A是对每个RISC-V指令和伪指令的详尽描述[^1]。它包括所有内容：操作名称和操作数、英文描述、寄存器传输语言定义、它所在的RISC-V扩展、指令的全称、指令格式、显示操作码的指令图，以及紧凑版本指令的参照。令人惊讶的是，所有这些加起来不到50页。

-   **索引------**它可以帮你通过指令全称或助记符找到描述指令说明、定义或图表的页面。它是按照字典的形式组织的。

**勘误和补充内容**

我们打算把勘误集中起来，每年发布几次更新。这本书的网站上会有本书的最新版本，还会简单介绍一下当前版本相对上一版本的改变。可在本书的网站（www.riscvbook.com）上查看勘误表的历史版本或报告新的错误。我们预先为您在这一版中发现的问题表示歉意。我们期待您的反馈意见，来帮助我们改进这本书。

**本书的诞生过程**

在2017年5月8日至11日在上海举行的第六届RISC-V研讨会上，我们认识到了对这么一本书的需求，几个星期后我们开始了编写。考虑到Patterson在写书方面的丰富经验，我们计划让他写大部分的章节。我们两人在组织方面进行了合作，并且是彼此章节的第一个评论者。Patterson撰写了第1、2、3、4、5、6、7、8、9、11章，参考卡和本前言，而Waterman写了第10章和附录A（本书的最大部分），并编写了书中的全部程序。Waterman还维护了Armando
Fox提供的LaTeX工具，使我们能做出这本书。

我们在2017年秋季学期为800名加州大学伯克利分校的学生提供了这本教科书的测试版本。在融入了他们的反馈后，当2017年学期结束以后，第一个正式版将于2017年11月28日至30日在硅谷举办的第七届RISC研讨会上及时发布。

RISC-V是一个伯克利研究项目的副产品。该项目正在针对更容易地同时构建硬件和软件的目标进行开发。

**致谢**

我们要感谢Armando
Fox，因为我们使用了他的LaTeX工具，以及采纳了他关于个人出版的建议。

我们最深切的感谢要送给那些读了本书早期的草稿并提出了有用建议的人，比如：Krste
Asanovi´c, Nikhil Athreya, C. Gordon Bell, Stuart Hoad, David Kanter,
John Mashey, Ivan Sutherland, Ted Speers, Michael Taylor, Megan
Wachs,....

最后，我们要感谢数百名加州大学伯克利分校学生在调试方面的付出以及他们的对这些素材的持续热忱！

David Patterson 和 Andrew Waterman

2017年9月1日于加州伯克利

译者序
======

大约四个月前的一天，我收到加州大学伯克利分校毕业的谭章熹博士的消息，告知图灵奖得主David
Patterson教授（谭博士的导师）希望将他和Andrew Waterman一起完成的《The
RISC-V
Reader》翻译成中文。这让我想起了大约四年前的一天，我收到了正在加州大学伯克利分校做博士后的钱学海博士的邮件，告知David
Patterson教授希望将他和Krste
Asanovic教授一起撰写的文章在中文杂志上发表。当我收到了中文翻译稿《指令系统应该免费：RISC-V的案例》后，动用了专栏编委的一点小权利，立刻向《中国计算机学会通讯》强烈推荐了这篇文章。文章很快于2015年2月发表，然而略显遗憾的是彼时它并未得到广泛关注，不过却让我们团队"近水楼台先得月"，成为国内最早将体系结构前沿研究全面转到了RISC-V平台的团队。这一次，怀着对RISC-V的感激之情、对Patterson教授的敬仰之心，更是为了便于更多中国爱好者了解RISC-V的愿望，我欣然接受了谭博士的请求。

过去几年深入接触RISC-V后，我心中时常呈现出一种愿景------RISC-V很可能像Linux那样开启开源芯片设计的黄金时代。事实上，伯克利的科研侠客们发明RISC-V就是希望"Instruction
Sets Want to be
Free"------全世界任何公司、大学、研究机构与个人都可以开发兼容RISC-V指令集的处理器，都可以融入到基于RISC-V构建的软硬件生态系统，而不需要为指令集付一分钱。这是伟大的理想！

在开源软件生态中，Linux是整个生态的基石。基于Linux，人们开发Python、LLVM、GCC等完整的工具链，创造MySQL、Apache、Hadoop等大量开源软件，实验各种创新思想与技术，逐渐形成一个价值超过150亿美元的开源软件生态。这对中国的互联网产业的意义尤为重大，不仅提升了BAT等互联网企业的技术研发能力，也大大降低了互联网产业创新的门槛，如今3-5位开发人员在几个月时间里就能快速开发出一个互联网应用。在芯片设计领域，RISC-V有望像Linux那样成为计算机芯片与系统创新的基石。但是只有RISC-V又是远远不够的，更重要的是要形成一个基于RISC-V的开源芯片设计生态，包括开源工具链、开源IP、开源SoC等等。

RISC-V还只是星星之火，却已展露出燎原之潜力。作为全世界最大的芯片用户，中国一直希望能把芯片产业做大做强，各方也都在努力。借鉴开源软件对于中国互联网产业发展的作用，也许开源芯片设计是一条值得尝试的道路。这本中文版《RISC-V手册》，希望能成为这条道路上一个小路标。

包云岗

2018年11月3日

翻译团队
--------

-   **包云岗**
    中科院计算所研究员，先进计算机系统研究中心主任，长期从事计算机体系结构研究

-   **勾凌睿**
    中国科学院大学计算机科学与技术专业本科生，有志于计算机体系结构研究

-   **黄成** 中科院计算所研究生，研究方向为计算机系统结构

-   **刘志刚**
    中科院计算所硕士研究生，开展基于RISC-V的前沿研究，曾获第二届全国大学生计算机系统能力培养大赛一等奖

第一章 为什么要有RISC-V？
=========================

简约是复杂的最终形式。 *------*列奥纳多·达·芬奇(Leonardo da Vinci)

1.1 导言
--------

> ![](media/image7.emf){width="1.2497692475940507in"
> height="2.870138888888889in"}RISC-V（"RISC
> five"）的目标是成为一个通用的指令集架构（ISA）：

-   它要能适应包括从最袖珍的嵌入式控制器，到最快的高性能计算机等各种规模的处理器。

-   它应该能兼容各种流行的软件栈和编程语言。

-   它应该适应所有实现技术，包括现场可编程门阵列（FPGA）、专用集成电路（ASIC）、全定制芯片，甚至未来的设备技术。

-   它应该对所有微体系结构样式都有效：例如微编码或硬连线控制;顺序或乱序执行流水线;
    单发射或超标量等等。

-   它应该支持广泛的专业化，成为定制加速器的基础，因为随着摩尔定律的消退，加速器的重要性日益提高。

-   它应该是稳定的，基础的指令集架构不应该改变。更重要的是，它不能像以前的专有指令集架构一样被弃用，例如AMD
    Am29000、Digital Alpha、Digital VAX、Hewlett Packard PA-RISC、Intel
    i860、Intel i960、Motorola 88000、以及Zilog Z8000。

> RISC-V的不同寻常不仅在于它是一个最近诞生的指令集架构（它诞生于最近十年，而大多数其他指令集都诞生于20世纪70到80年代），而且在于它是一个开源的指令集架构。与几乎所有的旧架构不同，它的未来不受任何单一公司的浮沉或一时兴起的决定的影响（这一点让许多过去的指令集架构都遭了殃）。它属于一个开放的，非营利性质的基金会。RISC-V基金会的目标是保持RISC-V的稳定性，仅仅出于技术原因缓慢而谨慎地发展它，并力图让它之于硬件如同Linux之于操作系统一样受欢迎。图1.1列出了RISC-V基金会最大的企业成员，作为其活力的证明。
>
> ![](media/image8.PNG){width="5.0185192475940505in"
> height="1.3395209973753281in"}
>
> **图1.1：2017年5月第六届RISC-V研讨会上RISC-V基金会的企业成员按年销售额排名。左栏公司的年销售额均超过500亿美元，中间栏目公司的销售额低于500亿美元但超过50亿美元，右栏的销售额低于50亿美元但超过5亿美元。RISC-V基金会包括另外25家小公司，5家初创公司（Antmicro
> Ltd，Blockstream，Esperanto Technologies，Greenwaves
> Technologies和SiFive），4家非营利组织（CSEM，Draper
> Laboratory，ICT和lowRISC）和6所大学（ETH Zurich，IIT Madras，National
> University of Defense Technology，Princeton和UC Berkeley）。
> 60个组织中的大多数总部都在美国以外。要了解更多信息，请访问[[www.riscv.org]{.underline}](http://www.riscv.org)。**

![](media/image9.PNG){width="5.111111111111111in"
height="2.5260181539807522in"}

**图1.2：x86指令集自诞生以来指令数量的增长。x86在1978年诞生时有80条指令，到2015年增长了16倍，到了1338条指令，并且仍在增长。令人惊讶的是这张图的数据仍显保守。2015年在英特尔的博客上有着3600条指令的统计结果\[Rodgers
and Uhlig
2017\]，这意味着x86指令的增长速率提高到了（在1978年到2015年之内）每四天增长一条。我们是用汇编语言指令计算的，他们想必算入了机器语言指令。正如第八章所解释的那样，这个增长的很大一部分是因为x86
ISA依赖于SIMD指令来实现数据级并行。**

![](media/image10.PNG){width="5.370370734908136in"
height="2.2565124671916013in"}

**图1.3：x86-32 ASCII Adjust after
Addition（**aaa**）指令的描述。它以二进制编码十进制数（BCD）形式进行计算机运算，这种方式已经被扔进信息技术历史的垃圾堆里。x86还有三个相似的指令，分别执行减法操作（**aas**），乘法操作（**aam**），和除法操作（**aad**）。由于他们都是单字节指令，它们加起来占用了宝贵的操作码空间的1.6%（4/256）。**

1.2 模块化与增量型ISA
---------------------

> 英特尔曾将其未来押在高端微处理器之上，但那时还需要很多年时间。为了对抗Zilog，英特尔开发了一款过渡产品，并给它起名为8086。它本应该是短命的，没有任何继任者，但事情并非如此。高端处理器姗姗来迟，等它最终出现时，它的性能并不如人意。因此，8086架构延续了下去------它变成32位处理器，最终演变为了64位处理器。它的名称不断变化（80186,80286，i386，i486，Pentium），但基础指令集保持不变。
>
> ------Stephen P. Morse, 8086的架构师\[Morse 2017\]

计算机体系结构的传统方法是增量ISA，新处理器不仅必须实现新的ISA扩展，还必须实现过去的所有扩展。目的是为了保持向后的二进制兼容性，这样几十年前程序的二进制版本仍然可以在最新的处理器上正确运行。这一要求与来自于同时发布新指令和新处理器的营销上的诱惑共同导致了ISA的体量随时间大幅增长。例如，图1.2显示了当今主导ISA
80x86的指令数量增长过程。这个指令集架构的历史可以追溯到1978年，在它的漫长生涯中，它平均每个月增加了大约三条指令。

这个传统意味着x86-32（我们用它表示32位地址版本的x86）的每个实现必须实现过去的扩展中的错误设计，即便它们不再有意义。例如，图1.3描述了x86的ASCII
Adjust after Addition（aaa）指令，该指令早已失效。

作为一个类比，假设一家餐馆只提供固定价格的餐点，最初只是一顿包含汉堡和奶昔的小餐。随着时间的推移，它会加入薯条，然后是冰淇淋圣代，然后是沙拉，馅饼，葡萄酒，素食意大利面，牛排，啤酒，无穷无尽，直到它成为一顿大餐。食客可以在那家餐厅找到他们过去吃过的东西，尽管总的来说这样做可能没什么意义。这样做的坏处是，用餐者为每次晚餐支付的宴会费用不断增加。

RISC-V的不同寻常之处，除了在于它是最近诞生的和开源的以外，还在于：和几乎所有以往的ISA不同，它是模块化的。它的核心是一个名为*RV32I*的基础ISA，运行一个完整的软件栈。RV32I是固定的，永远不会改变。这为编译器编写者，操作系统开发人员和汇编语言程序员提供了稳定的目标。模块化来源于可选的标准扩展，根据应用程序的需要，硬件可以包含或不包含这些扩展。这种模块化特性使得RISC-V具有了袖珍化、低能耗的特点，而这对于嵌入式应用可能至关重要。RISC-V编译器得知当前硬件包含哪些扩展后，便可以生成当前硬件条件下的最佳代码。惯例是把代表扩展的字母附加到指令集名称之后作为指示。例如，RV32IMFD将乘法（RV32M），单精度浮点（RV32F）和双精度浮点（RV32D）的扩展添加到了基础指令集（RV32I）中。

![](media/image11.PNG){width="0.7166666666666667in"
height="0.6180555555555556in"}![](media/image12.png){width="0.7034722222222223in"
height="0.425in"}![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}![](media/image14.png){width="0.6263888888888889in"
height="0.6069444444444444in"}![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}![](media/image17.png){width="0.7763888888888889in"
height="0.6409722222222223in"}继续用我们刚才的类比来说，RISC-V提供的是菜单，而不是一顿应有尽有的自助餐。主厨只需要烹饪顾客需要的东西（而不是每次都做出一顿盛宴），顾客只需要按他们的订单付费。RISC-V无需仅仅为了市场吸引力而添加指令。RISC-V基金会会决定什么时候在菜单里添加新的选项，而他们只会出于技术原因这样做，而且要在由软硬件专家组成的委员会进行专门的公开讨论以后才会添加。即使那些新选择出现在了菜单上，它们仍是可选的，不会像在增量ISA中那样成为未来所有实现的必要组成部分。

1.3 ISA设计 101
---------------

在介绍RISC-V这个ISA之前，了解计算机架构师在设计ISA时的基本原则和必须做出的权衡是有用的。如下的列表列出了七种衡量标准。页边放置了对应的七个图标，以突出显示RISC-V在随后章节中应对它们的实例。（印刷版的封底有所有图标的图例。）

-   成本（美元硬币）

-   简洁性（轮子）

-   性能（速度计）

-   架构和具体实现的分离（分开的两个半圆）

-   提升空间（手风琴）

-   程序大小（相对的压迫着一条线的两个箭头）

-   易于编程/编译/链接（儿童积木"像ABC一样简单"）

为了解释我们的意思，在这一节中我们会展示一些以往ISA所作出的选择。它们现在看起来是不明智的，而RISC-V通常会做出更好的决定。

**成本**
处理器通过集成电路实现，通常称为芯片或晶粒。它们叫做晶粒是因为，它们由一些单个的圆形晶片被切割成许多单独的片得到。图1.4显示了RISC-V处理器的晶圆。成本对晶粒面积十分敏感：

*cost ≈ f(die area^2^)*

显然，晶粒越小，每个晶圆上能切割出来的晶粒越多。晶粒的大部分成本来自于处理过的晶圆本身。不太直观的是，晶粒越小，产率（生产出的可用晶粒所占的比例）越高。原因在于目前的硅生产工艺会在晶圆上留下一些散布的小瑕疵。因此晶粒越小，有缺陷部分所占比重会越低。

> ![](media/image18.PNG){width="5.2288681102362204in"
> height="3.9351859142607175in"}

**图1.4：由SiFive设计的直径为8英寸的RISC-V晶圆。
它有两种类型的RISC-V芯片，使用较旧的较大加工线。
FE310芯片为2.65mm×2.72mm，SiFive测试芯片为2.89mm×2.72mm。
一片晶圆上有1846片FE310和1866片SiFive测试芯片，总共3712个芯片。**

架构师希望保持ISA的简洁性，从而缩小实现ISA的处理器的尺寸。我们将在随后的章节看到，RISC-V
ISA比ARM-32
ISA简洁得多。就简洁性造成的影响举例，我们把使用相同大小缓存（16KiB）的RISC-V
Rocket处理器和采用相同技术（TSMC40GPLUS）的ARM-32 Cortex
A5处理器进行比较。RISC-V晶粒的大小是0.27mm^2^，而ARM-32晶粒的大小是0.53mm^2^。由于面积大一倍，ARM-32
Cortex A5的晶粒成本是RISC-V
Rocket的约4（2^2^）倍。即使晶粒的大小只缩小10%，成本也将以1.2（1.1^2^）倍的比例缩小。

**简洁性**
鉴于成本对于复杂度的敏感性，架构师需要一个简单的ISA来缩小芯片面积。ISA的简洁性还能缩短芯片的设计和验证时间，而它们可能构成了芯片开发的大部分成本。这些成本必须算到芯片的成本当中。这个开销取决于发货芯片的数量。简洁性还能降低文档成本，让客户更容易了解如何使用这个ISA。

以下是ARM-32的ISA复杂性的一个明显示例：

ldmiaeq SP!, {R4-R7, PC}

![](media/image15.png){width="0.7in" height="0.6034722222222222in"}

该指令代表LoaD Multiple, Increment-Address, on
EQual。它执行5次数据加载并写入6个寄存器，但仅当EQ条件码置位时才执行。此外，它将结果写入PC，因此它也执行条件分支。真不少！

具有讽刺意味的是，即便需要实现的功能相同，简单指令也通常比复杂指令更容易被用到。例如，x86-32有一个enter指令，该指令本应该是在进入一个创建一个栈帧的过程中执行的第一条指令（见第三章）。大多数编译器用两条简单的x86-32指令来代替它：

> push ebp \# 将帧指针压入栈
>
> mov ebp, esp \# 把栈指针复制到帧指针

**性能**
除非是那些用于嵌入式应用的微型芯片，处理器的性能和成本通常都能成为架构师的关注对象。性能可以分解为如下三个因素：

$$\frac{\text{instructions}}{\text{program}} \times \frac{\text{average\ clock\ cycles}}{\text{instruction}} \times \frac{\text{time}}{\text{clock\ cycle}} = \frac{\text{time}}{\text{program}}$$

即使一个简单的ISA可能在每个程序执行的指令数方面多于复杂的ISA，但它可以通过更快的时钟频率或更低的平均单条指令周期数（CPI）来弥补。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}例如，运行CoreMark测试程序\[Gal-On, Levy
2012\]（100000次迭代）后，得到ARM-32 Cortex-A9的性能为：

$$\frac{32.27\ B\ instructi\text{ons}}{\text{program}} \times \frac{0.79\ clock\ cycles}{\text{instruction}} \times \frac{0.71\ ns}{\text{clock\ cycle}} = \frac{18.15\ \text{secs}}{\text{program}}$$

对应地，RISC-V的BOOM实现的性能为：

$$\frac{29.51\text{\ B\ instructi}\text{ons}}{\text{program}} \times \frac{0.72\text{\ clock\ cycles}}{\text{instruction}} \times \frac{0.67\text{\ ns}}{\text{clock\ cycle}} = \frac{14.26\ \text{secs}}{\text{program}}$$

在这个例子中，ARM处理器执行的指令并不比RISC-V处理器少。正如我们将要看到的，简单的指令也是最常用到的指令，因此ISA的简洁性是最为重要的指标。对于这个程序，RISC-V处理器在这三个因素中的每一个都获得了近10%的优势，它们加起来导致了近30%的性能优势。如果更简洁的ISA也能催生出更小的芯片，那么其性价比将非常出色。

![](media/image17.png){width="0.7763888888888889in"
height="0.6409722222222223in"}**架构和具体实现的分离**
架构和实现之间最初的分离可以追溯到20世纪60年代，具体表现为：机器语言程序员了解架构后能写出正确的程序，却不一定能保证性能。对于架构师来说，为了在性能和成本上对某一特定时间的某种实现进行优化，而在ISA中包含某些指令，有时候是一件有诱惑性的事情。但这样做会给其他实现或者今后的实现带来负担。

延迟分支是MIPS-32
ISA的一个令人遗憾的例子。条件分支导致流水线执行出现问题，因为处理器希望下一条要执行的指令总是已经在流水线上，但它不能确定它要的到底是顺序执行的下一条（如果分支未执行），还是分支目标地址的那一条（如果执行了分支）。对于它们的第一个五级流水的微处理器，这种优柔寡断可能导致流水线一个时钟周期的阻塞。MIPS-32通过把分支操作重新定义在分支指令的下一条指令执行完之后发生，因此分支指令的下一条指令永远会被执行。程序员或编译器编写者要做的是把一些有用的指令放入延迟槽。

唉，这个"解决方案"对接下来有着更多流水级（于是在计算出分支结果之前取了更多的指令）的MIPS-32处理器并无益处，反而让MIPS-32程序员，编译器编写者，以及处理器设计者（因为增量ISA需要向后兼容，见1.2节）的生活变得更加艰难。此外，它让MIPS-32的代码变得更加难懂（参见第29页图2.10）。

虽然架构师不该为了有助于某个时间点的某一个特定实现而特意加入某些功能，但他们也不应该放入阻碍某些实现的功能。例如，如上一页所述，ARM-32和其他一些ISA具有Load
Multiple指令。这些指令可以提高单发射流水线设计的性能，但会降低多发射流水线的效率。原因在于这种直截了当的实现排除了与其他指令并行地调度Load
Multiple的各个负载的可能，从而降低了这些处理器的指令吞吐量。

![](media/image12.png){width="0.7034722222222223in"
height="0.425in"}**提升空间** 随着摩尔定律（Moore's
law）的终结，对性价比进行重大改进的唯一途径是为特定领域（例如深度学习，增强现实，组合优化，图形等）添加自定义指令。这意味着如今的ISA必须保留操作码空间以供未来的提升。

在20世纪70年代和80年代，当摩尔定律如日中天的时候，很少有人考虑为未来的提升节省操作码空间。相反，架构师们重视长地址和立即数字段以减少每个程序执行的指令数（这是前一页上有关性能的方程式中的第一个因素）。

![](media/image19.png){width="4.918870297462817in"
height="2.8425929571303588in"}一个能说明缺少操作码空间的弊端的例子是，ARM-32的架构师后来试图通过向以前统一的32位ISA中添加16位指令来缩减代码长度，但根本就没有空间了。因此，唯一的解决方案是先用16位指令来创建一个新的ISA（Thumb），然后同时用16位指令和32位指令来组成另外一个ISA（Thumb-2），并用一个模式位在两种长度的指令间切换。为了切换模式，程序员或编译器会跳转到一个最低有效位为1的字节地址。这种方法有效的前提是，在正常的16位和32位指令中，该位应该是0。

**图1.5：RV32G，ARM-32，x86-32，RV32C和Thumb-2程序的相对大小。最后两个ISA是以短代码长度为目标的。
这些程序是使用GCC编译器的SPEC
CPU2006基准测试。与RV32C相比，Thumb-2的代码短小的优势是由于在进入程序时Load
and Store
Multiple的节省。RV32C没有包含它们，以保持与RV32G指令的一对一映射，RV32G省略了Load
and Store
Multiple以降低高端处理器的实现复杂性（见下文）。第七章介绍了RV32C。RV32G表示RISC-V扩展（RV32M，RV32F，RV32D和RV32A）的流行组合，正确称为RV32IMAFD。\[Waterman
2016\]**

![](media/image11.PNG){width="0.7166666666666667in"
height="0.6180555555555556in"}**程序大小**
程序越小，存储它所需的芯片面积就越小(这对于嵌入式设备来说可能是一个巨大的成本)。实际上，这个问题促使ARM架构师在Thumb和Thumb-2
ISA中追加了一些更短的指令。更小的程序还能减少指令缓存的未命中问题，从而节省了功耗（因为片外DRAM访问比片上SRAM访问耗能更多），也提高了性能。短的代码长度是ISA架构师的目标之一。

x86-32
ISA的指令可以短至1字节，也可以长达15字节。你可能会觉得x86的这种可变字节长度的指令写成的程序一定会比用一些ISA（比如ARM-32，RISC-V）中32位定长指令写的要更短。逻辑上，可变字节长度指令的程序也应该小于仅由16位和32位定长指令组成的ISA（比如Thumb-2和使用RV32C扩展的RISC-V，参见第七章）。图1.5显示，当所有指令都是32位长时，ARM-32和RISC-V代码比x86-32长6%到9%，而令人惊讶的是，x86-32代码比同时提供16位和32位指令的压缩版本（Thumb-2和RV32C）大26%。

虽然使用新的可变字节长度指令的新ISA可能会导致比RV32C和Thumb-2更短的代码，但20世纪70年代设计第一个x86的架构师并不关心这个问题。此外，考虑到增量ISA（第1.2节）对于向后二进制兼容性的要求，数百条新的x86-32指令比预期要长。它们有着一到两个字节长前缀的负担，这迫使它们使用原始x86的有限的空余操作码空间。

**易于编程/编译/链接**
由于寄存器中的数据访问起来要比存储器中的快得多，编译器在寄存器分配方面一定要做得很好。这件事在有许多寄存器的时候变得更加容易。鉴于这一点，ARM-32有16个寄存器，而x86-32只有8个。大多数现代ISA（包括RISC-V）都有32个整型寄存器。毫无疑问，有了更多的寄存器，编译器和汇编程序员的工作会更加轻松。

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}编译器和汇编语言程序员的另一个问题是弄清楚一个代码序列的执行速度。我们可以看到，一般每条RISC-V指令最多用一个时钟周期执行（忽略缓存未命中）。但正如我们之前看到的，ARM-32和x86-32都有需要很多个时钟周期执行（即使所有缓存都命中）的指令。此外，与ARM-32和RISC-V不同，x86-32的算术指令操作数可以在存储器中，而不必都在寄存器里。复杂的指令和位于存储器中的操作数使得处理器的设计人员难以保证性能的可预测性。

ISA支持位置无关代码（PIC）非常有用，因为这样它就支持动态链接（参见第3.5节），原因在于在不同程序中共享库代码可以驻留在不同地址。PC相关的分支和数据寻址是PIC的福音。虽然几乎所有的ISA都提供与PC相关的分支，但x86-32和MIPS-32省略了与PC相关的数据寻址。

1.4 全书的总览
--------------

本书假设您在RISC-V之前已经了解过其他指令集。如果没有，请查看我们基于RISC-V的相关入门架构书\[Patterson和Hennessy
2017\]。

第二章介绍了RV32I，它是RISC-V固定不变的基础整数指令集，是RISC-V的核心内容。第三章解释了第二章中没有介绍的其余RISC-V汇编语言内容，包括调用约定和一些用于链接的巧妙技巧。汇编语言包括所有符合规则的RISC-V指令和一些RISC-V指令集外的有用指令。这些伪指令是实际指令的巧妙变体，它们简化了编写汇编语言程序的过程，同时避免了使ISA复杂化。

接下来的三章阐述了RISC-V的标准扩展。当它们添加到RIV32I中的时候，我们统称RV32G（G代表一般）：

-   第四章：乘法和除法（RV32M）

-   第五章：浮点操作（RV32F和RV32D）

-   第六章：原子操作（RV32A）

第3页和第4页的RISC-V"参考卡"是本书中所有RISC-V指令（RV32G，RV64G和RV32 /
64V）的摘要。

第七章介绍了可选的压缩扩展RV32C，它是RISC-V优雅性的一个绝佳例子。通过把16位指令限制为现有32位RV32G指令的短版本，它们几乎是没有代价的。汇编程序可以选择指令大小，这使得汇编语言程序员和编译器忘记RV32C。将16位RV32C指令转换成32位RV32G指令的硬件解码器只需要400个门，这即使在最简单的RISC-V实现中也只占百分之几。

第八章介绍了向量扩展RV32V。当与众多强大的单指令多数据*（SIMD）*指令（ARM-32，MIPS-32，x86-32）相比时，向量指令成为了ISA优雅性的另一个例证。实际上，图1.2中添加到x86-32的数百条指令都是SIMD，还有数百条指令即将问世。RV32V甚至比大多数向量ISA更简单，因为它通过向量寄存器指定数据类型和长度，而不是将这两者嵌入到操作码中。RV32V也许是大家从传统的基于SIMD的ISA转到RISC-V的最为可能的原因。

第九章展示了RV64G，它是RISC-V的64位地址版本。正如该章节所说的那样，RISC-V的架构师只需要拓宽寄存器，并加入一些字、双字或长版的RV32G指令，就可以把地址从32位扩展为64位。

第十章介绍了系统指令，说明了RISC-V如何处理分页以及机器、用户和监管者权限模式。

![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}最后一章简要介绍了RISC-V基金会目前正在考虑增加的其它扩展。

接下来是本书最大的一个部分，附录A。它是按字母表顺序排列的指令集摘要。它定义了完整的RISC-V
ISA以及上面提到的所有扩展，还有大概50页的全部伪指令。这是RISC-V简洁性的证明。

这本书的最后一部分是索引。

1.5 结束语
----------

> 用形式逻辑的方法可以很容易看出，存在某种\[指令集\]在理论上足以控制和执行任意顺序的操作......从当前的观点出发，选择一个\[指令集\]时考虑得更多更实际的问题是：\[指令集\]要求的设备简单性，在实际重要的问题中有明确应用和解决该类问题的速度。
>
> ------冯·诺伊曼（von Neumann）等，1947

RISC-V是一个最新的，清晰的，简约的，开源的ISA，它以过去ISA所犯过的错误为鉴。RISC-V架构师的目标是让它在从最小的到最快的所有计算设备上都能有效工作。遵循冯诺依曼70年前的建议，这个ISA强调简洁性来保证它的低成本，同时有着大量的寄存器和透明的指令执行速度，从而帮助编译器和汇编语言程序员将实际的重要问题转换为适当的高效代码。

> ![](media/image20.png){width="4.787037401574803in"
> height="0.8817924321959755in"}

**图1.6：ISA手册的页数和字数来自\[Waterman and Asanovi\'c
2017a\]，\[Waterman and Asanovi\'c 2017b\]，\[Intel Corporation
2016\]，\[ARM Ltd.
2014\]。读完需要的时间按每分钟读200个单词，每周读40小时计算。
基于\[Baumann 2017\]的图1的一部分。**

> ![](media/image15.png){width="0.7in" height="0.6034722222222222in"}

复杂度的一个标准是文档的大小。图1.6显示了以页数和单词数衡量的RISC-V、ARM-32和x86-32指令集手册的大小。如果你把读手册作为全职工作，每天8小时，每周5天，那么需要半个月读完ARM-32手册，需要整整一个月读完x86-32手册。有这样的复杂程度，大概没有一个人能完全理解ARM-32或x86-32。用这种常识来度量，RISC-V的复杂度只有ARM-32的$\frac{1}{12}$,x86-32的$\frac{1}{10}$到$\frac{1}{30}$。实际上，包含所有扩展的RISC-V
ISA摘要只有两页（参见参考卡）。

这个袖珍的，开源的ISA于2011年推出，现在由一个基金会提供支持。该基金会通过长期讨论后严格依据技术理由添加可选扩展的方式来改进它。开源性让RISC-V的免费的、共享的实现成为可能，从而降低了成本，也减少了将不为人知的邪恶秘密隐藏在处理器之中的可能性。

![](media/image21.png){width="0.6560247156605424in"
height="0.674248687664042in"}然而，只有硬件不能组成一个系统。软件开发成本可能使硬件开发成本相形见绌。因此虽然稳定的硬件很重要，但稳定的软件更甚于此。这些软件需要包括操作系统，引导加载程序，参考软件和大众化的软件工具。基金会保证整个ISA的稳定性，而固定不变的基础指令集意味着核心的RV32I作为软件栈的目标永远不会改变。通过它的普适性和开源性，RISC-V可以挑战主流专有ISA的主导地位。

优雅是一个很少应用于ISA的词，但在阅读本书后，你可能会同意我们把它用于RISC-V。我们将用页边的蒙娜丽莎图标来凸显我们认为体现出优雅性的特征。

1.6 扩展阅读
------------

ARM Ltd. ARM Architecture Reference Manual: ARMv7-A and ARMv7-R Edition,
2014.

URL
[[http://infocenter.arm.com/help/topic/com.arm.doc.ddi0406c/]{.underline}](http://infocenter.arm.com/help/topic/com.arm.doc.ddi0406c/).

A. Baumann. Hardware is the new software. In *Proceedings of the 16th
Workshop on Hot*

*Topics in Operating Systems*, pages 132--137. ACM, 2017.

C. Celio, D. Patterson, and K. Asanovic. The Berkeley Out-of-Order
Machine (BOOM): an industry-competitive, synthesizable, parameterized
RISC-V processor. *Tech. Rep. UCB/EECS-2015--167, EECS Department,
University of California, Berkeley*, 2015.

S. Gal-On and M. Levy. Exploring CoreMark - a benchmark maximizing
simplicity and

efficacy. *The Embedded Microprocessor Benchmark Consortium*, 2012.

Intel Corporation. *Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume*

*2: Instruction Set Reference*. September 2016.

S. P. Morse. The Intel 8086 chip and the future of microprocessor
design. *Computer*, 50(4): 8--9, 2017.

D. A. Patterson and J. L. Hennessy. *Computer Organization and Design
RISC-V Edition: The Hardware Software Interface*. Morgan Kaufmann, 2017.

S. Rodgers and R. Uhlig. X86: Approaching 40 and still going strong,
2017.

J. L. von Neumann, A.W. Burks, and H. H. Goldstine. Preliminary
discussion of the logical design of an electronic computing instrument.
*Report to the U.S. Army Ordnance Department*, 1947.

A. Waterman. *Design of the RISC-V Instruction Set Architecture*. PhD
thesis, EECS Department, University of California, Berkeley, Jan 2016.
URL
[[http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-1.html]{.underline}](http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-1.html).

A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
Manual Volume II: Privileged Architecture Version 1.10*. May 2017a. URL
[[https://riscv.org/specifications/privileged-isa/]{.underline}](https://riscv.org/specifications/privileged-isa/).

A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
Manual, Volume I: User-Level ISA, Version 2.2*. May 2017b. URL
[[https://riscv.org/specifications/]{.underline}](https://riscv.org/specifications/).

**注记**

http://parlab.eecs.berkeley.edu

第二章 RV32I：RISC-V基础整数指令集
==================================

![](media/image22.emf){width="1.1in" height="2.2416666666666667in"}

...提升计算性能并且让用户能切实享受到性能提升的唯一方法是同时设计编译器和计算机。这样软件用不到的特性将不会被实现在硬件上...

------Frances Elizabeth "Fran" Allen, 1981

2.1 导言
--------

![](media/image24.PNG){width="3.375in"
height="0.6333333333333333in"}图2.1是RV32I基础指令集的一页图形表示。对于每幅图，将有下划线的字母从左到右连接起来，即可组成完整的RV32I指令集。对于每一个图，集合标志{}内列举了指令的所有变体，变体用加下划线的字母或下划线字符\_表示。特别的，下划线字符\_表示对于此指令变体不需用字符表示。例如，下图表示了这四个RV32I指令：slt，slti，sltu，sltiu:

我们使用这些图（下面几章的第一个图），旨在对本章的指令给出一个进行快速、深入的概述。

![](media/image15.png){width="0.7in" height="0.6034722222222222in"}2.2 RV32I指令格式
------------------------------------------------------------------------------------

![](media/image14.png){width="0.6263888888888889in"
height="0.6069444444444444in"}图2.2显示了六种基本指令格式，分别是：用于寄存器-寄存器操作的R类型指令，用于短立即数和访存load操作的I型指令，用于访存store操作的S型指令，用于条件跳转操作的B类型指令，用于长立即数的U型指令和用于无条件跳转的J型指令。图2.3使用图2.2的指令格式列出了图2.1中出现的所有RV32I指令的操作码。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}即使是指令格式也能从一些方面说明RISC-V
更简洁的ISA设计能提高提高性能功耗比。首先，指令只有六种格式，并且所有的指令都是32位长，这简化了指令解码。ARM-32，还有更典型的x86-32都有许多不同的指令格式，使得解码部件在低端实现中偏昂贵，在中高端处理器设计中容易带来性能挑战。第二，RISC-V指令提供三个寄存器操作数，而不是像x86-32一样，让源操作数和目的操作数共享一个字段。当一个操作天然就需要有三个不同的操作数，但是ISA只提供了两个操作数时，编译器或者汇编程序程序员就需要多使用一条move（搬运）指令，来保存目的寄存器的值。第三，在RISC-V中对于所有指令，要读写的寄存器的标识符总是在同一位置，意味着在解码指令之前，就可以先开始访问寄存器。在许多其他的ISA中，某些指令字段在部分指令中被重用作为源目的地，在其他指令中又被作为目的操作数（例如，ARM-32和MIPS-32）。因此，为了取出正确的指令字段，我们需要时序本就可能紧张的解码路径上添加额外的解码逻辑，使得解码路径的时序更为紧张。第四，这些格式的立即数字段总是符号扩展，符号位总是在指令中最高位。这意味着可能成为关键路径的立即数符号扩展，可以在指令解码之前进行。

![](media/image25.PNG){width="5.772222222222222in"
height="4.0368055555555555in"}

**图2.1：RV32I指令图示。把带下划线的字母从左到右连接就组成了RV32I指令。花括号{}表示集合中垂直方向上的每个项目都是指令的不同变体。集合中的下划线\_意味着不包含这个字母的也是一个指令名称。例如，左上角附近的符号表示以下六个指令：**and，or，xor，andi，ori，xori**。**

![](media/image26.PNG){width="5.772222222222222in"
height="1.8263888888888888in"}

**图2.2：RISC-V指令格式。我们用生成的立即数值中的位置（而不是通常的指令立即数域中的位置）(imm\[*x*\])标记每个立即数子域。第十章解释了控制状态寄存器指令使用I型格式的稍微不同的做法。（本图基于Waterman和Asanovi\'c
2017的图2.2）。 **

  imm\[31:12\]                 rd      0110111   U lui                                            
  ---------------------------- ------- --------- --------- ---------------- ----------- --------- -----------
  imm\[31:12\]                 rd      0010111   U auipc                                          
  imm\[20\|10:1\|11\|19:12\]   rd      1101111   J jal                                            
  imm\[11:0\]                  rs1     000       rd        1100111          I jalr                
  imm\[12\|10:5\]              rs2     rs1       000       imm\[4:1\|11\]   1100011     B beq     
  imm\[12\|10:5\]              rs2     rs1       001       imm\[4:1\|11\]   1100011     B bne     
  imm\[12\|10:5\]              rs2     rs1       100       imm\[4:1\|11\]   1100011     B blt     
  imm\[12\|10:5\]              rs2     rs1       101       imm\[4:1\|11\]   1100011     B bge     
  imm\[12\|10:5\]              rs2     rs1       110       imm\[4:1\|11\]   1100011     B bltu    
  imm\[12\|10:5\]              rs2     rs1       111       imm\[4:1\|11\]   1100011     B bgeu    
  imm\[11:0\]                  rs1     000       rd        0000011          I lb                  
  imm\[11:0\]                  rs1     001       rd        0000011          I lh                  
  imm\[11:0\]                  rs1     010       rd        0000011          I lw                  
  imm\[11:0\]                  rs1     100       rd        0000011          I lbu                 
  imm\[11:0\]                  rs1     101       rd        0000011          I lhu                 
  imm\[11:5\]                  rs2     rs1       000       imm\[4:0\]       0100011     S sb      
  imm\[11:5\]                  rs2     rs1       001       imm\[4:0\]       0100011     S sh      
  imm\[11:5\]                  rs2     rs1       010       imm\[4:0\]       0100011     S sw      
  imm\[11:0\]                  rs1     000       rd        0010011          I addi                
  imm\[11:0\]                  rs1     010       rd        0010011          I slti                
  imm\[11:0\]                  rs1     011       rd        0010011          I sltiu               
  imm\[11:0\]                  rs1     100       rd        0010011          I xori                
  imm\[11:0\]                  rs1     110       rd        0010011          I ori                 
  imm\[11:0\]                  rs1     111       rd        0010011          I andi                
  0000000                      shamt   rs1       001       rd               0010011     I slli    
  0000000                      shamt   rs1       101       rd               0010011     I srli    
  0100000                      shamt   rs1       101       rd               0010011     I srai    
  0000000                      rs2     rs1       000       rd               0110011     R add     
  0100000                      rs2     rs1       000       rd               0110011     R sub     
  0000000                      rs2     rs1       001       rd               0110011     R sll     
  0000000                      rs2     rs1       010       rd               0110011     R slt     
  0000000                      rs2     rs1       011       rd               0110011     Rsltu     
  0000000                      rs2     rs1       100       rd               0110011     R xor     
  0000000                      rs2     rs1       101       rd               0110011     R srl     
  0100000                      rs2     rs1       101       rd               0110011     R sra     
  0000000                      rs2     rs1       110       rd               0110011     R or      
  0000000                      rs2     rs1       111       rd               0110011     R and     
  0000                         pred    succ      00000     000              00000       0001111   I fence
  0000                         0000    0000      00000     001              00000       0001111   I fence.i
  000000000000                 00000   00        00000     1110011          I ecall               
  000000000000                 00000   000       00000     1110011          I ebreak              
  csr                          rs1     001       rd        1110011          I csrrw               
  csr                          rs1     010       rd        1110011          I csrrs               
  csr                          rs1     011       rd        1110011          I csrrc               
  csr                          zimm    101       rd        1110011          I csrrwi              
  csr                          zimm    110       rd        1110011          I cssrrsi             
  csr                          zimm    111       rd        1110011          I csrrci              

**图2.3：RV32I带有指令布局，操作码，格式类型和名称的操作码映射。（此图基于\[Waterman
and Asanovi\'c 2017\]的表19.2。）**

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}

![](media/image12.png){width="0.7034722222222223in"
height="0.425in"}为了帮助程序员，所有位全部是0是非法的RV32I指令。因此,
试图跳转到被清零的内存区域的错误跳转将会立即触发异常，这可以帮助调试。类似地，所有位全部是1的指令也是非法指令，它将捕获其他常见的错误，诸如未编程的非易失性内存设备、断开连接的内存总线或者坏掉的内存芯片。

![](media/image14.png){width="0.6263888888888889in"
height="0.6069444444444444in"}
为了给ISA扩展留出足够的空间，最基础的RV32I指令集只使用了32位指令字中的编码空间的不到八分之一。架构师们也仔细挑选了RV32I操作码，使拥有共同数据通路的指令的操作码位有尽可能多的位的值是一样的，这简化了控制逻辑。最后,当我们看到，B和J格式的分支和跳转地址必须向左移动1位以将地址乘以2，从而给予分支和跳转指令更大的跳转范围。RISC-V将立即数中的位从自然排布进行了一些移位轮换，将指令信号的扇出和立即数多路复用的成本降低了近两倍，这也简化了低端实现中的数据通路逻辑。

**有什么不同之处？**在这一章和后面的章节的结束部分，我们将描述RISC-V与其他指令集的不同之处。这种对比通常是描述相比于其他指令集，RISC-V少了什么。省略什么特性和包括什么特性一样，都能体现架构师的精心设计。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"} ARM-32
指令集12位的立即字段不仅仅是一个常量，而是一个函数的输入，此函数根据12位立即数的输入来产生一个常量：8位被零扩展到全宽度，然后被循环右移。右移的位数是12位立即数中剩余4位的值乘2。设计者希望在12位中编码更多有用的常数来减少执行指令的数量。在大多数指令格式中，ARM-32也将十分宝贵的四位编码空间拿出来专门用于条件执行。这些条件执行指令不仅使用频率低而且增加了乱序处理器的复杂性。

2.3 RV32I寄存器![](media/image16.png){width="0.6666666666666666in" height="0.3770833333333333in"}
-------------------------------------------------------------------------------------------------

图4列出了RV32I寄存器以及由RISC-V
应用程序二进制接口（ABI）所定义的寄存器名称。在我们的示例代码中，我们将使用ABI名称，使它们更容易阅读。为了满足汇编语言程序员和编译器编写者，RV32I有31寄存器加上一个值恒为0的x0寄存器。与之相比，ARM-32只有16个寄存器，x86-32甚至只有8
个寄存器。

![](media/image15.png){width="0.7in" height="0.6034722222222222in"}
**有什么不同之处？**为常量0单独分配一个寄存器是RISC-V
ISA能如此简单的一个很大的因素。第3章的第36页的图3给出了许多ARM-32和x86-32的原生指令操作，这两个指令集中没有零寄存器。我们可以用RV32I指令完成功能相同的操作，只需使用零寄存器作为操作数。

程序计数器（PC）是ARM-32的16个寄存器之一，这意味着任何改变寄存器的指令都有可能导致分支跳转。PC作为一个寄存器使硬件分支预测变得复杂，因为在典型的ISA中，仅10%-20%的指令为分支指令，而在ARM-32中，任何指令都有可能是分支指令。而分支预测的准确性对于良好的流水线性能至关重要。另外将PC作为一个寄存器也意味着可用的通用寄存器少了一个。

2.4 RV32I整数计算
-----------------

附录A给出了所有RISC-V指令的细节信息，包括格式和操作码。在本节以及接下来的章节的类似小节中，我们将给出ISA的一些概述。这能够让有基础的汇编语言程序员了解RISC-V，同时也顺便说明RISC-V的特性如何满足第一章中阐述的七个ISA指标。

简单的算术指令（add, sub）、逻辑指令（and, or,
xor），以及图2.1中的移位指令（sll, srl,
sra）和其他ISA差不多。他们从寄存器读取两个32位的值，并将32位结果写入目标寄存器。RV32I还提供了这些指令的立即数版本。和ARM-32不同，立即数总是进行符号扩展，这样子如果需要，我们可以用立即数表示负数，正因为如此，我们并不需要一个立即数版本的sub。

![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}程序可以根据比较结果生成布尔值。为应对这种使用场景下，RV32I提供一个当小于时置位的指令。如果第一个操作数小于第二个操作数，它将目标寄存器设置为1，否则为0。不出所料，对这个指令，有一个有符号版本（slt）和无符号版本（sltu），分别用于处理有符号和无符号整数比较。相应的，上述两条指令也有立即数版本的（slti，sltiu）。正如我们将要看到的，虽然RV32I分支指令可以检查两个寄存器之间的所有关系，但一些条件表达式涉及多对寄存器之间的关系。对于这些表达式，编译器或汇编语言程序员可以将slt以及与或异或等逻辑指令组合使用来解决更复杂的条件表达式。

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}
图2.1剩下的两条整数计算指令主要用于构造大的常量数值和链接。加载立即数到高位（lui）将20位常量加载到寄存器的高20位。接着便可以使用标准的立即指令来创建32位常量。这样子，仅使用2条32位RV32I指令，便可构造一个32位常量。向PC高位加上立即数（auipc）让我们仅用两条指令，便可以基于当前PC以任意偏移量转移控制流或者访问数据。将auipc中的20位立即数与jalr（参见下面）中12位立即数的组合，我们可以将执行流转移到任何32位PC相对地址。而auipc加上普通加载或存储指令中的12位立即数偏移量，使我们可以访问任何32位PC相对地址的数据。

![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}**有什么不同之处？**首先，RISC-V中没有字节或半字宽度的整数计算操作。操作始终是以完整的寄存器宽度。内存访问需要的能量比算术运算高几个数量级。因此低宽度的数据访问可以节省大量的能量，但低宽度的运算不会。ARM-32具有一个不寻常的功能，对于大多数算术逻辑运算中的一个操作数，你可以选择对它进行移位。尽管这些指令的使用频率很低，但它使数据路径和数据通路更加复杂。与此相对的是，RV32I提供了单独的移位指令。

![](media/image14.png){width="0.6263888888888889in"
height="0.6069444444444444in"}RV32I也不包含乘法和除法，它们包含在可选的RV32M扩展中（参见第4章）。与ARM-32和x86-32不同，即使处理器没有添加乘除法扩展，完整的RISC-V软件栈也可以运行，这可以缩小嵌入式芯片的面积。MIPS-32汇编程序可能用一系列移位以及加法指令来替换乘法，以提高性能，这可能会使程序员看到处理器执行了汇编程序中没有的指令，进而造成混淆。RV32I可以忽略了这些特性：循环移位指令和整数算术溢出检测，这两个特性都可以用若干条RV32I指令来实现（参见第2.6节）。

**图2.4：RV32I的寄存器。第3章解释了RISC-V调用约定，各种指针（sp，gp，tp，fp），保存寄存器（s0-s11）和临时寄存器（t0-t6）背后的基本原理（基于\[Waterman
and Asanovi\'c
2017\]的图2.1和表20.1）。**![](media/image27.PNG){width="5.7652777777777775in"
height="7.280555555555556in"}

2.5 RV32I的Load和Store
----------------------

除了提供32位字（lw，sw）的加载和存储外，图2.1中说明，RV32I
支持加载有符号和无符号字节和半字（lb，lbu，lh，lhu）和存储字节和半字（sb，sh）。有符号字节和半字符号扩展为32位再写入目的寄存器。即使是自然数据类型更窄，低位宽数据也是被扩展后再处理，这使得后续的整数计算指令能正确处理所有的32位。在文本和无符号整数中常用的无符号字节和半字，在写入目标寄存器之前都被无符号扩展到32位。

![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}加载和存储的支持的唯一寻址模式是符号扩展12位立即数到基地址寄存器，这在x86-32中被称为位偏移寻址模式\[Irvine
2014\]。

**有什么不同之处？**RV32I省略了ARM-32和x86-32的复杂寻址模式。另外，ARM-32提供的寻址模式并非适用于所有数据类型，但RV32I
寻址不会歧视任何数据类型。RISC-V可以模仿某些x86寻址模式。例如，将立即数字段设置为0即与x86中的寄存器间接寻址效果相同。与x86-32不同，RISC-V没有特殊的堆栈指令。将31个寄存器中的某一个作为堆栈指针（见图2.4），标准寻址模式使用起来和压栈（push）和出栈（pop）类似，并且不增加ISA的复杂性。与MIPS-32不同，RISC-V不支持延迟加载（*delayed
load*）。与延迟分支的设计相似，为了更好的适应五级流水线，MIPS-32重新定义了load指令的语义，load上来的数据在load指令两个指令后才可用。但是对于后来出现的更长的流水线，延迟加载带来的收益逐渐消失，因此RISC-V不支持延迟加载。

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}![](media/image14.png){width="0.6263888888888889in"
height="0.6069444444444444in"}
虽然ARM-32和MIPS-32要求存储在内存中的数据，要按照数据的自然大小进行边界对齐，但是RISC-V没有这个要求。移植旧的代码有时需要未对齐的访问。对于不对齐访问，一种选择是在基础ISA中禁止不对齐访问，然后提供一些单独的指令用于不对齐访问，例如MIPS-32中的Load
Word Left和Load Word Right。然而，这会使寄存器访问变得复杂，因为lwl
并且lwr需要对寄存器进行部分写，而不是简单地对寄存器进行完整的写。支持不对齐访问的，另一种方法就是让普通的加载和存储指令支持不对齐访问，这简化了整体设计。

2.6 RV32I条件分支
-----------------

RV32I可以比较两个寄存器并根据比较结果上进行分支跳转。比较可以是：相等（beq），不相等
（bne），大于等于（bge），或小于（blt）。最后两种比较有符号比较，RV32I也提供相应的无符号版本比较的：bgeu和bltu。剩下的两个比较关系（大于和小于等于）可以通过简单地交换两个操作数，即可完成比较。因为x
\< y表示y \> x且x ≥ y表示y ≤ x。

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}由于RISC-V指令长度必须是两个字节的倍数------关于可选的双字节指令
，请参考第七章------分支指令的寻址方式是12位的立即数乘以2，符号扩展它，然后将得到值加到PC上作为分支的跳转地址。PC相对寻址可用于位置无关的代码，简化了链接器和加载器的工作（第3章）。

![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}**有什么不同之处？**如上所述，RISC-V去掉了MIPS-32，Oracle
SPARC等指令集中被广为诟病的延迟分支特性等。对于条件分支，它还没有像ARM-32和x86-32那样使用条件码。条件码的存在使得大多数指令都需要隐式设置一些额外状态，这使乱序执行的依赖计算复杂化。最后，它省略了x86-32中的循环指令：loop，loope，loopz，loopne，loopnz。

2.7 RV32I无条件跳转
-------------------

![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}图2.1中的跳转并链接指令（jal）具有双重功能。若将下一条指令PC
+
4的地址保存到目标寄存器中，通常是返回地址寄存器ra（见图2.4），便可以用它来实现过程调用。如果使用零寄存器（x0）替换ra作为目标寄存器，则可以实现无条件跳转，因为x0不能更改。像分支一样，jal将其20位分支地址乘以2，进行符号扩展后再添加到PC上，便得到了跳转地址。

跳转和链接指令的寄存器版本（jalr）同样是多用途的。它可以调用地址是动态计算出来的函数，或者也可以实现调用返回（只需ra作为源寄存器，零寄存器（x0）作为目的寄存器）。Switch和case语句的地址跳转，也可以使用jalr指令，目的寄存器设为x0。

**有什么不同之处？**RV32I避开了错综复杂的程序调用指令，例如x86-32的进入和离开指令，或Intel
Itanium，Oracle SPARC和Cadence Tensilica中的寄存器窗口。

2.8 RV32I杂项
-------------

图2.1中的控制状态寄存器指令
(csrrc、csrrs、csrrw、csrrci、csrrsi、csrrwi)，使我们可以轻松地访问一些程序性能计数器。对于这些64位计数器,
我们一次可以读取32位。这些计数器包括了系统时间,
时钟周期以及执行的指令数目。

在RISC-V指令集中，ecall指令用于向运行时环境发出请求，例如系统调用。调试器使用ebreak指令将控制转移到调试环境。

fence指令对外部可见的访存请求，如设备I /
O和内存访问等进行串行化。外部可见指对处理器的其他核心、线程，外部设备或协处理器可见。fence.i指令同步指令和数据流。在执行fence.i指令之前，对于同一个硬件线程，RISC-V不保证用存储指令写到内存指令区的数据可以被取指令取到。

第10章介绍RISC-V系统指令。

![](media/image28.PNG){width="4.32537510936133in"
height="1.991839457567804in"}**图 2.5:**
**C语言版的插入排序。虽然看起来简单, 插入排序比复杂的排序算法有许多优势:
对于小数据集来说,
它是内存使用效率高、速度快，同时还有适应性强、稳定、能在线处理的特点。gcc编译器生成了以下四个数字的代码。我们设置优化标志以减少代码大小，因为这产生了最容易理解的代码。**

![](media/image29.PNG){width="5.772222222222222in"
height="0.5222222222222223in"}

**图 2.6:
插入排序在不同指令集下生成的指令数目以及指令大小。第7章会介绍ARM
Thumb-2, microMIPS以及RV32C指令集。**

![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}**有什么不同之处？**RISC-V使用内存映射I /
O而不是像x86-32一样，使用in，ins，insb，insw和out，out，outsb等指令来进行I/O。为支持字符串处理，RISC-V实现了字节存取，而不是像x86-32那样实现了
rep，movs，coms，scas，lods等16条特殊的字符串处理指令。

2.9 使用插入排序比较RV32I，ARM-32，MIPS-32和x86-32指令集
--------------------------------------------------------

我们已经介绍了RISC-V基本指令集，并说明了与ARM-32，MIPS-32和x86-32相比，它做了哪些取舍。我们现在通过真实程序来进行一场直接的较量。图2.5显示了我们的基准测试------用C实现的插入排序。图2.6是一个表，它总结了在编译到不同ISA后，插入排序的指令数和字节数。

图2.8至2.11显示了插入排序编译生成的RV32I，ARM-32，MIPS-32和x86-32的汇编代码。尽管强调简单性，RISC-V版本使用相同数目或更少的指令，
并且不同架构的代码大小非常接近。在此示例中，RISC-V的比较、执行分支指令和ARM-32和x86-32中花式繁多的寻址模式以及入栈出栈指令一样，能够节省大量指令。

2.10 结束语
-----------

那些不记得过去的人，注定要重复过去。------George Santayana, 1905

图2.7使用第1章中的七个ISA设计指标来组织前面提到的一些过去的指令集中学习到的经验教训，并说明了这些经验教训对RV32I设计的积极影响。我们并不是说RISC-V是第一个拥有这些积极结果的ISA。事实上，RV32I从RISC-I，它的曾祖父母\[Patterson
2017\]那里，继承了如下这些特性：

-   32位字节可寻址的地址空间

-   所有指令均为32位长

-   31个寄存器，全部32位宽，寄存器0硬连线为零

-   所有操作都在寄存器之间（没有寄存器到内存的操作）

-   加载/存储字加上有符号和无符号加载/存储字节和半字

-   所有算术，逻辑和移位指令都有立即数版本的指令

-   立即数总是符号扩展

-   仅提供一种数据寻址模式（寄存器+立即数）和PC相对分支

-   无乘法或除法指令

-   一个指令，用于将大立即数加载到寄存器的高位，这样加载32位常量到寄存器只需要两条指令

> ![](media/image21.png){width="0.6560247156605424in"
> height="0.674248687664042in"}

RISC-V的出现比过去的ISA晚了四分之一到三分之一个世纪后开始，这使它的设计者得以实践Santayana的建议，即借用之前指令集中好的设计，但不重复它们不好的瑕疵
-
包括RISC-I指令集中的瑕疵。另外RISC-V基金会将通过可选的指令集扩展的方式缓慢扩展着指令集，以避免出现困扰过去的成功指令集的疯狂的增量发展。

2.11 扩展阅读
-------------

Lindy effect, 2017. URL https://en.wikipedia.org/wiki/Lindy\_effect.

> T. Chen and D. A. Patterson. RISC-V genealogy. Technical Report
> UCB/EECS-2016-6, EECS Department, University of California, Berkeley,
> Jan 2016. URL
> http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-6.html.

W. Hohl and C. Hinds. *ARM Assembly Language: Fundamentals and
Techniques*. CRC

Press, 2016.

K. R. Irvine. *Assembly language for x86 processors*. Prentice Hall,
2014.

D. Patterson. How close is RISC-V to RISC-I?, 2017.

A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
Manual, Volume I:*

*User-Level ISA, Version 2.2*. May 2017. URL
[https://riscv.org/specifications/]{.underline}.

**注记**

http://parlab.eecs.berkeley.edu

+-------------+-------------+-------------+-------------+-------------+
|             | 过去的错误  | RV32I       |             |             |
|             |             | (2011)吸取的经验 |        |             |
|             | ARM-32      | 教训        |             |             |
|             | (1986)      |             |             |             |
|             | MIPS-32     |             |             |             |
|             | (1986)      |             |             |             |
|             | x86-32      |             |             |             |
|             | (1978)      |             |             |             |
+=============+=============+=============+=============+=============+
| 成本        | 必须支持整数乘除法 | 必须支持整数乘除法 | 8位以及16位操作、必 | 无8位、16位操作、可 |
|             |             |             | 须支持整数乘除法 | 选的整数乘除法支持(R |
|             |             |             |             | V32M)       |
+-------------+-------------+-------------+-------------+-------------+
| 简洁性      | 无零寄存器、条件指令执 | 立即数支持零扩展及符号 | 无零寄存器、复杂的过程 | 寄存器x0专门用于存放 |
|             | 行、复杂的寻址模式、栈 | 扩展、一些算术指令会造 | 调用指令(enter/ | 常数0、立即数只进行符 |
|             | 操作指令（push/p | 成溢出异常 | leave)、栈指令( | 号扩展 |
|             | op）、算术/逻辑指令 |     | push/pop)、复 | 、一种数据寻址模式、没 |
|             | 中存在移位  |             | 杂寻址模式、循环指令 | 有条件执行、没有复杂的 |
|             |             |             |             | 函数调用指令以及栈指令 |
|             |             |             |             | 、算术指令不抛异常、使 |
|             |             |             |             | 用单独的移位指令来处理 |
|             |             |             |             | 移位操作    |
+-------------+-------------+-------------+-------------+-------------+
| 性能        | 分支指令使用条件码、在 | 在不同格式的指令中，源 | 分支指令使用条件码、每 | 使用同一条指令实现比较 |
|             | 不同格式的指令中，源和 | 和目的寄存器的位置不同 | 个指令中最多只能使用两 | 及跳转（不使用条件码） |
|             | 目的寄存器的位置不同、 |  | 个寄存器    | 、每条指令三个寄存器 |
|             | 加载多个计算得到的立即 |  |             |             |
|             | 数、PC是一个通用寄存 |    |             | 、不能一次load多个 |
|             | 器          |             |             | 数据、不同指令格式中， |
|             |             |             |             | 源及目的寄存器字段位置 |
|             |             |             |             | 固定、立即数是常数（不 |
|             |             |             |             | 是由计算得出的）、PC |
|             |             |             |             | 不是通用寄存器 |
+-------------+-------------+-------------+-------------+-------------+
| 架构和具体实现的分离 | 将PC像普通寄存器一样 | 分支指令延迟槽、Loa | 寄存器不是通用的(AX | 分支指令没有延迟槽、L |
|             | 读写，这样暴露了流水线 | d指令延迟槽、乘除法使 | ,CX,DX, | oad指令无延迟槽、通 |
|             | 长度        | 用单独的HI，LO寄存 | DI,SI有特殊用途) | 用寄存器 |
|             |             | 器          |             |             |
+-------------+-------------+-------------+-------------+-------------+
| 增长空间    | 有限的指令码空间 | 有限的指令码空间 |   | 大量可用的指令码空间 |
+-------------+-------------+-------------+-------------+-------------+
| 程序大小    | 仅有32bit指令 | 仅32bit指令(mi | 指令长度可用是不同字节 | 32位指令+16位 |
|             |             | croMIPS是作为一 | ，但这是一个很不好的选 |  |
|             | (Thumb-2    | 个独立的ISA) | 择         | RV32C 扩展  |
|             | 是作为一个独立的ISA |     |             |             |
|             | )           |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| 易于编程/编译/链接 | 仅15个寄存器内存数据 | 内存数据必须对齐、不规 | 仅15个寄存器内存数据 | 31个寄存器、数据可用 |
|             | 必须对齐、不规则的数据 | 则的数据寻址模式、不一 | 必须对齐、不规则的数据 | 不对齐、PC相对的数据 |
|             | 寻址模式、不一致的性能 | 致的性能计数器 | 寻址模式、不一致的性能 | 寻址模式 |
|             | 计数器      |             | 计数器      | 、对称的数据寻址模式、 |
|             |             |             |             | 定义在架构中的性能计数 |
|             |             |             |             | 器          |
+-------------+-------------+-------------+-------------+-------------+

**图2.7：RISC-V架构师从过去指令集设计的错误中吸取的教训。通常的教训是避免过去的ISA"优化"。经验和教训按照第一章中提出的七个ISA指标进行分类。在成本，简单性和性能下列出的许多指令集特性可以互换，因为这只是设计的偏好问题，但不管它们出现在哪里，它们都很重要。**

![](media/image30.PNG){width="5.772222222222222in"
height="4.627777777777778in"}

**图2.8：插入排序的RV32I代码如图2.5所示。十六进制的地址在左边，
接下来是十六进制的机器语言代码，然后是汇编语言指令，最后是评论以及注释。RV32I分配两个寄存器用以指向a\[j\]和a\[j-1\]。RV32I有很多寄存器，其中一些被ABI预留用于函数调用。与其他ISA不同，它会跳过保存和恢复寄存器值到内存的过程。虽然代码大小大于x86-32，但使用可选的RV32C指令（请参阅第七章）缩小了指令大小的差距。注意RV32I中的一条比较和分支指令顶得上ARM-32和x86-32比较所需的三条指令。**

![](media/image31.PNG){width="5.772222222222222in"
height="3.9930555555555554in"}

**图2.9：图2.5中插入排序的ARM-32代码。十六进制的地址在左边，接下来是十六进制的机器语言代码，然后是汇编语言指令，最后是注释、评论。由于寄存器不足，为了腾出两个空寄存器，以便之后重用，ARM-32将两个寄存器的值保存到堆栈中（和返回地址放在一起）。它使用了一种将i和j缩放为字节地址的寻址方式。鉴于分支跳转需要同时适用于ARM-32和Thumb-2，bxcs首先设置返回的最低有效位保存前地址为0。条件码使得我们在递减j后在检查它时可以少用一条比较指令，但在其他地方比较仍然需要三条指令。**

![](media/image32.PNG){width="5.708333333333333in" height="5.325in"}

**图2.10：图2.5中插入排序的MIPS-32代码。十六进制的地址在左边，接下来是十六进制的机器语言代码，然后是汇编语言指令，最后是注释。MIPS-32代码中有三条**nop**指令，这增加了它的长度。两个是由于延迟分支，另一个是由于延迟加载。编译器无法找到有用的指令来填充延迟槽。延迟的分支也使代码更难理解，因为不管分支会不会跳转，延迟槽中的指令都会被执行。例如，地址5c处的最后一条指令（**addiu**）是循环的一部分，尽管它是在分支指令之后。**

![](media/image33.PNG){width="5.772222222222222in"
height="4.361805555555556in"}

**图2.11：图2.5中插入排序的x86-32代码。十六进制的地址在左边，接下来是十六进制的机器语言代码，然后是汇编语言指令，最后是注释。由于缺少寄存器，x86-32将将两个寄存器保存在堆栈中，以便腾出这两个寄存器供后续使用。而且，本来在RV32I中可以分配到寄存器的两个变量（n和指向a\[0\]的指针），现在是保存在内存中的。它使用扩展下标索引寻址模式，这对于访问\[i\]和\[j\]具有良好效果。
这里的20条x32-86指令中有7个是只有一个字节那么长，这使得对于这个简单的程序，x86-32的代码规模很小。x86有两个流行的汇编语言版本：Intel
/ Microsoft和AT＆T /
Linux。我们使用英特尔语法，部分原因是它将目的地放在左边，而源操作数放在右边，与RISC-V，ARM-32和MIPS-32的操作数顺序一致。而AT＆T的操作数顺序则与之相反（并且对于寄存器操作数，需要在名字前加上%）。对于一些程序员来说，这看似微不足道的事情几乎是一个宗教问题。我们这里做出这样的选择，纯粹是因为教学方便，而非因为所谓"正统的信仰"。**

第三章 RISC-V汇编语言
=====================

![](media/image34.png){width="1.0648151793525809in"
height="2.648148512685914in"}

给看似困难的问题找到简单的解法往往让人心满意足，而且最好的解法常常是都简单的。

------Ivan Sutherland

3.1 导言
--------

![](media/image36.png){width="3.702777777777778in"
height="2.620833333333333in"}图3.1表明了从C程序翻译成为可以在计算机上执行的机器语言程序的四个经典步骤。这一章的内容包括了后三个步骤，不过我们要从汇编语言在RISC-V函数调用规范中的作用开始说起。

**图3.1
从C源代码翻译为可运行程序的步骤。这是从逻辑上进行的划分，实际中一些步骤会被结合起来，加速翻译过程。我们在这里使用了Unix的文件后缀命名习惯，分别对应MS-DOS中的**.C**,**
.ASM**,** .OBJ**,** .LIB**和**.EXE**。**

3.2 函数调用规范（Calling convention）
--------------------------------------

函数调用过程通常分为6个阶段\[Patterson and Hennessy 2017\]。

1\. 将参数存储到函数能够访问到的位置；

2\. 跳转到函数开始位置（使用RV32I的jal指令）；

3\. 获取函数需要的局部存储资源，按需保存寄存器；

4\. 执行函数中的指令；

5\. 将返回值存储到调用者能够访问到的位置，恢复寄存器，释放局部存储资源；

6\. 返回调用函数的位置（使用ret指令）。

为了获得良好的性能，变量应该尽量存放在寄存器而不是内存中，但同时也要注意避免频繁地保存和恢复寄存器，因为它们同样会访问内存。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}
RISC-V有足够多的寄存器来达到两全其美的结果：既能将操作数存放在寄存器中，同时也能减少保存和恢复寄存器的次数。其中的关键在于，在函数调用的过程中不保留部分寄存器存储的值，称它们为临时寄存器；另一些寄存器则对应地称为保存寄存器。不再调用其它函数的函数称为叶函数。当一个叶函数只有少量的参数和局部变量时，它们可以都被存储在寄存器中，而不会"溢出（spilling）"到内存中。但如果函数参数和局部变量很多，程序还是需要把寄存器的值保存在内存中，不过这种情况并不多见。

函数调用中其它的寄存器，要么被当做保存寄存器来使用，在函数调用前后值不变；要么被当做临时寄存器使用，在函数调用中不保留。函数会更改用来保存返回值的寄存器，因此它们和临时寄存器类似；用来给函数传递参数的寄存器也不需要保留，因此它们也类似于临时寄存器。对于其它一些寄存器，调用者需要保证它们在函数调用前后保持不变：比如用于存储返回地址的寄存器和存储栈指针的寄存器。图3.2列出了寄存器的RISC-V应用程序二进制接口（ABI）名称和它们在函数调用中是否保留的规定。

![](media/image37.png){width="4.8489938757655295in"
height="3.5573173665791775in"}

**图3.2
RISC-V整数和浮点寄存器的汇编助记符。RISC-V有足够的寄存器，如果过程或方法不产生其它调用，就可以自由使用由ABI分配的寄存器，不需要保存和恢复。调用前后不变的寄存器也称为"由调用者保存的寄存器"，反之则称为"由被调用者保存的寄存器"。浮点寄存器将第5章进行解释。（这张图源于\[Waterman
and Asanovi´c 2017\]的表20.1。）**

根据ABI规范，我们来看看标准的RV32I函数入口和出口。下面是函数的开头：

![](media/image38.png){width="4.929503499562554in"
height="0.9857819335083114in"}

如果参数和局部变量太多，在寄存器中存不下，函数的开头会在栈中为函数帧分配空间，来存放。当一个函数的功能完成后，它的结尾部分释放栈帧并返回调用点：

![](media/image39.png){width="4.88625656167979in"
height="0.784582239720035in"}

我们很快将会看到使用这套ABI的一个例子，但首先我们需要对汇编的其它部分进行一些解释。

3.3 汇编器![](media/image15.png){width="0.7in" height="0.6034722222222222in"}
-----------------------------------------------------------------------------

在Unix系统中，这一步的输入是以.s为后缀的文件，比如foo.s；在MS-DOS中则是.ASM。

图3.1中的汇编器的作用不仅仅是从处理器能够理解的指令产生目标代码，还能翻译一些扩展指令，这些指令对汇编程序员或者编译器的编写者来说通常很有用。这类指令在巧妙配置常规指令的基础上实现，称为伪指令。图3.3和3.4列出了RISC-V伪指令，前者中要求x0寄存器始终为0，后者中则没有这种要求。例如，之前提到的ret实际上是一个伪指令，汇编器会用jalr
x0, x1,
0来替换它（见图3.3）。大多数的RISC-V伪指令依赖于x0。因此，把一个寄存器硬编码为0便于将许多常用指令------如跳转（jump）、返回（return）、等于0时转移（branch
on equal to zero）------作为伪指令，进而简化RISC-V指令集。

图3.5为经典的C程序Hello
World，编译器产生的汇编指令如图3.6，其中使用了图3.2的调用规范和图3.3、3.4的伪指令。

汇编程序的开头是一些汇编指示符（assemble
directives）。它们是汇编器的命令，具有告诉汇编器代码和数据的位置、指定程序中使用的特定代码和数据常量等作用。图3.9是RISC-V的汇编指示符。其中图3.6中用到的指示符有：

-   .text：进入代码段。

-   .align 2：后续代码按22字节对齐。

-   .globl main：声明全局符号"main"。

-   .section .rodata：进入只读数据段

-   .balign 4：数据段按4字节对齐。

-   .string "Hello, %s!\\n"：创建空字符结尾的字符串。

-   .string "world"：创建空字符结尾的字符串。

汇编器产生如图3.7的目标文件，格式为标准的可执行可链接文件（ELF）格式\[TIS
Committee 1995\]。

![](media/image40.png){width="4.697916666666667in"
height="5.260416666666667in"}

**图3.3
依赖于x0的RISC-V伪指令。附录A包含了这些RISC-V的伪指令和真实指令。在RV32I中，那些读取64位计数器的指令默认读取低32位，增加"h"时读取高32位。（这张图源于\[Waterman
and Asanovi´c 2017\]的表20.2和表20.3。）**

![](media/image41.png){width="5.724000437445319in"
height="5.6562915573053365in"}

**图3.4
不依赖于x0寄存器的RISC-V伪指令。在la指令一栏，GOT代表全局偏移表（Global
Offset
Table），记录动态链接库中的符号的运行时地址。附录A包含了这些RISC-V的伪指令和真实指令。（这张图源于\[Waterman
and Asanovi´c 2017\]的表20.2和表20.3。）**

![](media/image42.png){width="3.013888888888889in"
height="1.2111023622047243in"}

**图3.5 C语言的Hello World程序（**hello.c**）。**

![](media/image43.png){width="5.170138888888889in"
height="3.553614391951006in"}

**图3.6 RISC-V汇编语言的Hello World程序（**hello.s**）。**

![](media/image44.png){width="2.1458333333333335in"
height="2.114846894138233in"}

**图3.7 RISC-V机器语言的Hello
World程序（**hello.o**）。位置8到1c这六条指令的地址字段为0，将在后面由链接器填充。目标文件的符号表记录了链接器所需的标签和地址。**

3.4 链接器
----------

链接器允许各个文件独立地进行编译和汇编，这样在改动部分文件时，不需要重新编译全部源代码。链接器把新的目标代码和已经存在的机器语言模块（如函数库）等"拼接"起来。链接器这个名字源于它的功能之一，即编辑所有对象文件的跳转并链接指令（jump
and link）中的链接部分。它其实是链接编辑器（link
editor）的简称，图3.1中的这一步骤过去就被称为链接编辑。在Unix系统中，链接器的输入文件有.o后缀，输出a.out文件；在MS-DOS中输入文件后缀为.OBJ或.LIB，输出.EXE文件。

图3.10展示了一个典型的RISC-V程序分配给代码和数据的内存区域，链接器需要调整对象文件的指令中程序和数据的地址，使之与图中地址相符。如果输入文件中的是与位置无关的代码（PIC），链接器的工作量会有所降低。PIC中所有的指令转移和文件内的数据访问都不受代码位置的影响。如第2章所言，RV32I的相对转移（PC-relative
branch）特性使得程序更易于实现PIC。

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}![](media/image45.png){width="4.320833333333334in"
height="2.2777777777777777in"}
除了指令，每个目标文件还包含一个符号表，存储了程序中标签，由链接过程确定地址。其中包括了数据标签和代码标签。图3.6中有两个数据标签（string1和string2）和两个代码标签（main和printf）需要确定。由于在单个32位指令中很难指定一个32位的地址，RV32I的链接器通常需要为每个标签调整两条指令。如图3.6所示：数据标签需要调整lui和addi，代码标签需要调整auipc和jalr。图3.8显示了图3.7中的目标文件链接后产生的a.out文件。

**图3.8 链接后的RISC-V机器语言Hello
World程序。在Unix系统中，它的文件名是**a.out**。**

RISC-V编译器支持多个ABI，具体取决于F和D扩展是否存在。RV32的ABI分别名为ilp32，ilp32f和ilp32d。ilp32表示C语言的整型（int），长整型（long）和指针（pointer）都是32位，可选后缀表示如何传递浮点参数。在lip32中，浮点参数在整数寄存器中传递；在ilp32f中，单精度浮点参数在浮点寄存器中传递；在ilp32d中，双精度浮点参数也在浮点寄存器中传递。

自然，如果想在浮点寄存中传递浮点参数，需要相应的浮点ISA添加F或D扩展（见第5章）。因此要编译RV32I的代码（GCC选项-march=rv32i），必须使用ilp32
ABI（GCC选项-mabi=lib32）。反过来，调用约定并不要求浮点指令一定要使用浮点寄存器，因此RV32IFD与ilp32，ilp32f和ilp32d都兼容。

链接器检查程序的ABI是否和库匹配。尽管编译器本身可能支持多种ABI和ISA扩展的组合，但机器上可能只安装了特定的几种库。因此，一种常见的错误是在缺少合适的库的情况下链接程序。在这种情况下，链接器不会直接产生有用的诊断信息，它会尝试进行链接，然后提示不兼容。这种错误常常在从一台计算机上编译另一台计算机上运行的程序（交叉编译）时发生。

![](media/image46.png){width="5.03200021872266in"
height="4.47788167104112in"}

**图3.9 常见RISC-V汇编指示符。**

![](media/image47.png){width="2.0930818022747157in"
height="2.083999343832021in"}

**图3.10
RV32I为程序和数据分配内存。图中的顶部是高地址，底部是低地址。在RISC-V软件规范中，栈指针（**sp**）从0xbffffff0开始向下增长；程序代码段从0x00010000开始，包括静态链接库；程序代码段结束后是静态数据区，在这个例子中假设从0x10000000开始；然后是动态数据区，由C语言中的malloc()函数分配，向上增长，其中包含动态链接库。**

3.5 静态链接和动态链接
----------------------

上一节对静态链接（static
linking）进行了说明，在程序运行前所有的库都进行了链接和加载。如果这样的库很大，链接一个库到多个程序中会十分占用内存。另外，链接时库是绑定的，即使它们后来的更新修复了bug，强制的静态链接的代码仍然会使用旧的、有bug的版本。

为了解决这两个问题，现在的许多系统使用动态链接（dynamic
linking），外部的函数在第一次被调用时才会加载和链接。后续所有调用都使用快速链接（fast
linking），因此只会产生一次动态开销。每次程序开始运行，它都会按照需要链接最新版本的库函数。另外，如果多个程序使用了同一个动态链接库，库代码在内存中只会加载一次。

编译器产生的代码和静态链接的代码很相似。其不同之处在于，跳转的目标不是实际的函数，而是一个只有三条指令的存根函数（stub
function）。存根函数会从内存中的一个表中加载实际的函数的地址并跳转。不过，在第一次调用时，表中还没有实际的函数的地址，只有一个动态链接的过程的地址。当这个动态链接过程被调用时，动态链接器通过符号表找到实际要调用的函数，复制到内存中，更新记录实际的函数地址的表。后续的每次调用的开销就是存根函数的三条指令的开销。

3.6 加载器
----------

类似图3.8的程序以一个可执行文件的形式存储在计算机的存储设备上。运行时，加载器的作用是把这个程序加载到内存中，并跳转到它开始的地址。如今的"加载器"就是操作系统。换句话说，加载a.out是操作系统众多的任务之一。

动态链接程序的加载稍微有些复杂。操作系统不直接运行程序，而是运行一个动态链接器，再由动态链接器开始运行程序，并负责处理所有外部函数的第一次调用，把它们加载到内存中，并且修改程序，填入正确的调用地址。

3.7 结束语
----------

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}保持简洁，保持功能单一。

------Kelly Johnson，提出"KISS原则"的航空工程师，1960

![](media/image14.png){width="0.6263888888888889in"
height="0.6069444444444444in"}

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"} 汇编器向RISC-V
ISA中增加了60条伪指令，使得RISC-V代码更易于读写，并且不增加硬件开销。将一个寄存器硬编码为0使得其中许多伪指令更容易实现。使用加载高位立即数（lui）和程序计数器与高位立即数相加（auipc）两条指令，简化了编译器和链接器寻找外部数据/函数的地址的过程。使用相对地址转移的代码与位置无关，减少了链接器的工作。大量的寄存器减少了寄存器保存和恢复的次数，加速函数调用和返回。

![](media/image21.png){width="0.6560247156605424in"
height="0.674248687664042in"}
RISC-V提供了一系列简单又有影响力的机制，降低成本，提高性能，并且使得编写程序更加容易。

3.8 扩展阅读
------------

D. A. Patterson and J. L. Hennessy*. Computer Organization and Design
RISC-V Edition:*

*The Hardware Software Interface*. Morgan Kaufmann, 2017.

> TIS Committee. Tool interface standard (TIS) executable and linking
> format (ELF) specification version 1.2. *TIS Committee*, 1995.
>
> A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
> Manual, Volume I: User-Level ISA, Version 2.2*. May 2017. URL
> <https://riscv.org/specifications/>.

**注记**

http://parlab.eecs.berkeley.edu

第四章 乘法和除法指令
=====================

![](media/image48.emf){width="1.2497692475940507in" height="2.25in"}

若非必要，勿增实体。------奥卡姆的威廉（William of Occam），1320

4.1 导言
--------

RV32M向RV32I中添加了整数乘法和除法指令。图4.1是RV32M扩展指令集的图形表示，图4.2列出了它们的操作码。

除法是直截了当的。可以回想起如下的式子：

$$商 = (被除数 - 余数) \div 除数$$

或者

$$被除数 = 除数 \times 商 + 余数$$

$$余数 = 被除数 - (商 \times 除数)$$

RV32M具有有符号和无符号整数的除法指令：divide(div)和divide
unsigned(divu)，它们将商放入目标寄存器。在少数情况下，程序员需要余数而不是商，因此RV32M提供remainder(rem)和remainder
unsigned(remu)，它们在目标寄存器写入余数，而不是商。

![](media/image49.PNG){width="4.665445100612423in"
height="1.7575765529308836in"}

**图4.1：RV32M指令的图示**

![](media/image50.PNG){width="5.768055555555556in"
height="1.7243055555555555in"}

**图4.2：RV32M操作码映射包含指令布局，操作码，指令格式类型和它们的名称（\[Waterman
and Asanovic 2017\]的表19.2是此图的基础。）**

乘法的式子很简单：

$$积 = 被乘数 \times 乘数$$

它比除法要更为复杂，是因为积的长度是乘数和被乘数长度的和。将两个32位数相乘得到的是64位的乘积。为了正确地得到一个有符号或无符号的64位积，RISC-V中带有四个乘法指令。要得到整数32位乘积（64位中的低32位）就用mul指令。要得到高32位，如果操作数都是有符号数，就用mulh指令；如果操作数都是无符号数，就用mulhu指令；如果一个有符号一个无符号，可以用mulhsu指令。在一条指令中完成把64位积写入两个32位寄存器的操作会使硬件设计变得复杂，所以RV32M需要两条乘法指令才能得到一个完整的64位积。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}
对许多微处理器来说，整数除法是相对较慢的操作。如前述，除数为2的幂次的无符号除法可以用右移来代替。事实证明，通过乘以近似倒数再修正积的高32位的方法，可以优化除数为其它数的除法。例如，图4.3显示了3为除数的无符号除法的代码。

![](media/image51.PNG){width="5.768055555555556in"
height="1.1722222222222223in"}

**图4.3：RV32M中用乘法来实现除以常数操作的代码。要证明该算法适用于任何除数需要仔细的数值分析，而对于其它除数，其中的修正步骤更为复杂。算法正确性的证明以及产生倒数和修正步骤的算法在\[Granlund
and Montgomery 1994\]中可以找到。**

**有什么不同之处？**
长期以来，ARM-32只有乘法而无除法指令。直到第一台ARM处理器诞生的大约20年后（2005年），除法指令才成为ARM的必要组成部分。MIPS-32使用特殊寄存器（HI和LO）作为乘法和除法指令的唯一目标寄存器。虽然这种设计降低了早期MIPS处理器实现的复杂性，但它需要额外的移动指令以使用乘法或除法的结果，这可能会降低性能。HI和LO寄存器也会增加架构状态，使得在任务之间切换的速度稍慢。

4.2 结束语
----------

最便宜，最快，并且最可靠的组件是那些没有出现的组件。

------C. Gordan Bell，著名小型计算机的架构师

![](media/image14.png){width="0.6263888888888889in"
height="0.6069444444444444in"}

为了为嵌入式应用提供最小的RISC-V处理器，乘法和除法被归入RISC-V的第一个可选标准扩展的一部分RV32M。许多RISC-V处理器将包括RV32M。

4.3 扩展阅读
------------

T. Granlund and P. L. Montgomery. Division by invariant integers using
multiplication. In *ACM SIGPLAN Notices*, volume 29, pages 61--72. ACM,
1994.

A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
Manual, Volume I: User-Level ISA, Version 2.2*. May 2017. URL
[[https://riscv.org/specifications/]{.underline}](https://riscv.org/specifications/).

**注记**

http://parlab.eecs.berkeley.edu

第五章 RV32F和RV32D：单精度和双精度浮点数
=========================================

![](media/image52.emf){width="1.2497692475940507in"
height="2.183333333333333in"}

只有当没有任何东西可以去除，而不是没有东西可以添加时，我们才最终达到了完美。

------Antoine de Saint Exup'ery, L'Avion, 1940

5.1 导言
--------

尽管RV32F和RV32D是分开的，单独的可选指令集扩展，他们通常是包括在一起的。为简洁起见，我们在一章中介绍了几乎所有的单精度和双精度（32位和64位）浮点指令。图5.1是一个
RV32F和RV32D扩展指令集的图形表示。图5.2列出
RV32F的操作码，图5.3列出了RV32D的操作码。和几乎所有其他现代ISA一样，RISC-V服从IEEE
754-2008浮点标准\[IEEE标准委员会2008\]。

5.2浮点寄存器
-------------

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}RV32F和RV32D使用32个独立的f寄存器而不是x寄存器。使用两组寄存器的主要原因是：处理器在不增加RISC-V指令格式中寄存器描述符所占空间的情况下使用两组寄存器来将寄存器容量和带宽是乘2，这可以提高处理器性能。使用两组寄存器对RISC-V指令集的主要影响是，必须要添加新的指令来加载和存储数据f寄存器，还需要添加新指令用于在x和f寄存器之间传递数据。图5.4列出了RV32D和RV32F寄存器及对应的由RISC-V
ABI确定的寄存器名称。

如果处理器同时支持RV32F和RV32D扩展，则单精度数据仅使用f寄存器中的低32位。与RV32I中的x0不同，寄存器f0不是硬连线到常量0，而是和所有其他31个
f寄存器一样，是一个可变寄存器。

IEEE
754-2008标准提供了几种浮点运算舍入的方法，这有助于确定误差范围和编写数值库。最准确且最常见的舍入模式是舍入到最近的偶数（RNE）。舍入模式可以通过浮点控制和状态寄存器fcsr进行设置。图5.5显示了fcsr并列出了舍入选项。它还包含标准所需的累积异常标志。

**有什么不同之处？**
ARM-32和MIPS-32都有32个单精度浮点寄存器但都只有16个双精度寄存器。它们都将两个单精度寄存器映射到双精度寄存器的左右两半。x86-32浮点数算术没有任何寄存器，而是使用堆栈代替。堆栈条目是80位宽度提高精度，因此浮点数负载将32位或64位操作数转换为80位，对于存储指令，反之亦然。x86-32的一个后续版本增加了8个传统的64位浮点寄存器以及相关的操作指令。与RV32FD和MIPS-32不同，ARM-32和x86-32忽视了在浮点和整数寄存器之间直接移动数据的指令。唯一的解决方案是先将![](media/image54.PNG){width="5.772222222222222in"
height="3.3125in"}浮点寄存器的内容存储在内存中，然后将其从内存加载到整数寄存器，反之亦然。

**图5.1：RV32F和RV32D的指令图示。**

5.3浮点加载，存储和算术指令
---------------------------

对于RV32F和RV32D，RISC-V有两条加载指令（flw，fld）和两条存储指令（fsw，fsd）。他们和lw和sw拥有相同的寻址模式和指令格式。添加到标准算术运算中的指令有：（fadd.s，fadd.d，fsub.s，fsub.d，fmul.s，fmul.d，fdiv.s，fdiv.d），RV32F和RV32D还包括平方根（fsqrt.s，fsqrt.d）指令。它们也有最小值和最大值指令（fmin.s，fmin.d，fmax.s，fmax.d），这些指令在不使用分支指令进行比较的情况下，将一对源操作数中的较小值或较大值写入目的寄存器。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}许多浮点算法（例如矩阵乘法）在执行完乘法运算后会立即执行一条加法或减法指令。因此，RISC-V提供了指令用于先将两个操作数相乘然后将乘积加上（fmadd.s，fmadd.d）或减去（fmsub.s，fmsub.d）第三个操作数，最后再将结果写入目的寄存器。它还有在加上或减去第三个操作数之前对乘积取反的版本：fnmadd.s，fnmadd.d，fnmsub.s，fnmsub.d。这些融合的乘法
-
加法指令比单独的使用乘法及加法指令更准确，也更快，因为它们只（在加法之后）舍入过一次，而单独的乘法及加法指令则舍入了两次（先是在乘法之后，然后在加法之后）。这些指令需要一条新指令格式指定第4个寄存器，称为R4。图5.2和5.3显示了R4格式，它是R格式的一个变种。

RV32F和RV32D没有提供浮点分支指令，而是提供了浮点比较指令，这些根据两个浮点的比较结果将一个整数寄存器设置为1或0：feq.s，feq.d，flt.s，flt.d，fle.s，fle.d。这些指令允许整数分支指令根据浮点数比较指令设置的条件进行分支跳转。例如，这段代码在f1
\<f2时，则分支跳转到Exit：

> flt x5，f1，f2 ＃如果f1 \< f2，则x5 = 1;否则x5 = 0
>
> bne x5，x0，Exit ＃如果x5！= 0，则跳转到Exit

  imm\[11:0\]   rs1     010   rd    0000111      I flw                   
  ------------- ------- ----- ----- ------------ --------- ------------- --------------------
  imm\[11:5\]   rs2     rs1   010   imm\[4:0\]   0100111   S fsw         
  rs3           00      rs2   rs1   rm           rd        1000011       R4 fmadd.s fmadd.
  rs3           00      rs2   rs1   rm           rd        1000111       R4 fmsub.s fmadd.
  rs3           00      rs2   rs1   rm           rd        1001011       R4 fnmsub.s fmadd.
  rs3           00      rs2   rs1   rm           rd        1001111       R4 fnmadd.s fmadd.
  0000000       rs2     rs1   rm    rd           1010011   R fadd.s      
  0000100       rs2     rs1   rm    rd           1010011   R fsub.s      
  0001000       rs2     rs1   rm    rd           1010011   R fmul.s      
  0001100       rs2     rs1   rm    rd           1010011   R fdiv.s      
  0001100       00000   rs1   rm    rd           1010011   R fsqrt.s     
  0010000       rs2     rs1   000   rd           1010011   R fsgnj.s     
  0010000       rs2     rs1   001   rd           1010011   R fsgnjn.s    
  0010000       rs2     rs1   010   rd           1010011   R fsgnjx.s    
  0010100       rs2     rs1   000   rd           1010011   R fmin.s      
  0010100       rs2     rs1   001   rd           1010011   R fmax.s      
  1100000       00000   rs1   rm    rd           1010011   R fcvt.w.s    
  1100000       00001   rs1   rm    rd           1010011   R fcvt.wu.s   
  1110000       00000   rs1   000   rd           1010011   R fmv.x.w     
  1010000       rs2     rs1   010   rd           1010011   R feq.s       
  1010000       rs2     rs1   001   rd           1010011   R flt.s       
  1010000       rs2     rs1   000   rd           1010011   R fle.s       
  1110000       00000   rs1   001   rd           1010011   R fclass.s    
  1101000       00000   rs1   rm    rd           1010011   R fcvt.s.w    
  1101000       00001   rs1   rm    rd           1010011   R fcvt.s.wu   
  1111000       00000   rs1   000   rd           1010011   R fmv.w.x     

**图5.2：RV32F操作码表包含了指令布局，操作码，格式类型和名称。这张表与下一张表在编码上的主要区别是：对于这张表，前两个指令第12位是0，并且对于其余指令，第25位为0，而在下一张表中，RV32D中的这两个位均为1（基于\[Waterman
and Asanovic 2017\]的表19.2）。**

  imm\[11:0\]   rs1     011   rd    0000111      I fld                   
  ------------- ------- ----- ----- ------------ --------- ------------- --------------------
  imm\[11:5\]   rs2     rs1   011   imm\[4:0\]   0100111   S fsd         
  rs3           01      rs2   rs1   rm           rd        1000011       R4 fmadd.d fmadd.
  rs3           01      rs2   rs1   rm           rd        1000111       R4 fmsub.d fmadd.
  rs3           01      rs2   rs1   rm           rd        1001011       R4 fnmsub.d fmadd.
  rs3           01      rs2   rs1   rm           rd        1001111       R4 fnmadd.d fmadd.
  0000001       rs2     rs1   rm    rd           1010011   R fadd.d      
  0000101       rs2     rs1   rm    rd           1010011   R fsub.d      
  0001001       rs2     rs1   rm    rd           1010011   R fmul.d      
  0001101       rs2     rs1   rm    rd           1010011   R fdiv.d      
  0001101       00000   rs1   rm    rd           1010011   R fsqrt.d     
  0010001       rs2     rs1   000   rd           1010011   R fsgnj.d     
  0010001       rs2     rs1   001   rd           1010011   R fsgnjn.d    
  0010001       rs2     rs1   010   rd           1010011   R fsgnjx.d    
  0010101       rs2     rs1   000   rd           1010011   R fmin.d      
  0010101       rs2     rs1   001   rd           1010011   R fmax.d      
  0100000       00001   rs1   rm    rd           1010011   R fcvt.s.d    
  0100001       00000   rs1   rm    rd           1010011   R fcvt.d.s    
  1010001       Rs2     rs1   010   rd           1010011   R feq.d       
  1010001       rs2     rs1   001   rd           1010011   R flt.d       
  1010001       rs2     rs1   000   rd           1010011   R fle.d       
  1110001       00000   rs1   001   rd           1010011   R fclass.d    
  1100001       00000   rs1   rm    rd           1010011   R fcvt.w.d    
  1100001       00001   rs1   rm    rd           1010011   R fcvt.wu.d   
  1101001       00000   rs1   rm    rd           1010011   R fmv.d.w     
  1101001       00001   rs1   rm    rd           1010011   R fmv.d.wu    

**图5.3：RV32D操作码表包含了指令布局，操作码，格式类型和名称。这两个图中的一些指令并不仅仅是数据宽度不同。只有这张表有**fcvt.s.d**和**fcvt.d.s**指令，而只有另一张表有**fmv.x.w**和**fmv.w.x**.指令（基于\[Waterman
and Asanovic 2017\]的表19.2）。**

       f0 / ft0     FP Temporary
  ---- ------------ ------------------------------------
       f1 / ft1     FP Temporary
       f2 / ft2     FP Temporary
       f3 / ft3     FP Temporary
       f4 / ft4     FP Temporary
       f5 / ft5     FP Temporary
       f6 / ft6     FP Temporary
       f7 / ft7     FP Temporary
       f8 / fs0     FP Saved register
       f9 / fs1     FP Saved register
       f10 / fa0    FP Function argument, return value
       f11 / fa1    FP Function argument, return value
       f12 / fa2    FP Function argument
       f13 / fa3    FP Function argument
       f14 / fa4    FP Function argument
       f15 / fa5    FP Function argument
       f16 / fa6    FP Function argument
       f17 / fa7    FP Function argument
       f18 / fs2    FP Saved register
       f19 / fs3    FP Saved register
       f20 / fs4    FP Saved register
       f21 / fs5    FP Saved register
       f22 / fs6    FP Saved register
       f23 / fs7    FP Saved register
       f24 / fs8    FP Saved register
       f25 / fs9    FP Saved register
       f26 / fs10   FP Saved register
       f27 / fs11   FP Saved register
       f28 / ft8    FP Temporary
       f29 / ft9    FP Temporary
       f30 / ft10   FP Temporary
       f31 / ft11   FP Temporary
  32   32           

**图5.4：RV32F和RV32D的浮点寄存器。单精度寄存器占用了32个双精度寄存器中最右边的一半。第3章解释了RISC-V对于浮点寄存器的调用约定，阐述了FP参数寄存器（fa0-fa7），FP保存寄存器（fs0-fs11）和FP
临时寄存器（ft0-ft11）背后的基本原理（基于\[Waterman and Asanovic
2017\]的表20.1）。**

![](media/image55.PNG){width="5.772222222222222in"
height="0.8229166666666666in"}**图5.5：浮点控制和状态寄存器。它保存舍入模式和异常标志。舍入模式包括向最近的偶数舍入（**frm**中的rte，000）;**
**向零舍入（rtz，001）;
向下**$\mathbf{(}\mathbf{-}\mathbf{\infty)}$**舍入（rdn，010）;
向上**$\mathbf{(}\mathbf{+}\mathbf{\infty)}$**舍入（rup，011）;
以及向最近的最大值舍入（rmm，100）。
五个累积异常标志表示自上次由软件重置字段以来在任何浮点运算指令上出现的异常条件：NV表示非法操作;
DZ表示除以零; OF表示上溢; UF表示下溢; NX表示不精确（基于\[Waterman
andAsanovic 2017\]的图8.2）。**

![](media/image56.PNG){width="5.772222222222222in"
height="1.3965277777777778in"}

**图5.6：RV32F和RV32D转换指令。在列中列出了源数据类型，在行中列出转换的目标数据类型。**

5.4浮点转换和搬运
-----------------

RV32F和RV32D支持在在32位有符号整数，32位无符号整数，32位浮点和64位之间浮点进行所有组合的转换（只要这个转换是有用，有意义的）。图5.6按源数据类型以及转换后的目的数据类型，罗列了这10条指令。

RV32F还提供了将数据从f寄存器（fmv.x.w）移动到x寄存器的指令，以及反方向移动数据的指令（fmv.w.x）。

5.5其他浮点指令
---------------

RV32F和RV32D提供了不寻常的指令，有助于编写数学库以及提供有用的伪指令。（IEEE
754浮点标准需要一种复制并且操作符号并对浮点数据进行分类的方式，这启发我们添加了这些指令。）

第一个是符号注入指令，它从第一个源操作数复制了除符号位之外的所有内容。符号位的取值取决于具体是什么指令：

1.  浮点符号注入（fsgnj.s，fsgnj.d）：结果的符号位是rs2的符号位。

2.  浮点符号取反注入（fsgnjn.s，fsgnjn.d）：结果的符号位与rs2的符号位相反。

3.  浮点符号异或注入（fsgnjx.s，fsgnjx.d）：结果符号位是rs1和rs2的符号位异或的结果。

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}除了有助于数学库中的符号操作，基于符号注入指令我们还提供了三种流行的浮点伪指令（参见第37页的图3.4）：

1.  复制浮点寄存器：

> fmv.s rd，rs事实上是fsgnj.s rd，rs，rs
>
> fmv.d rd，rs事实上是sgnj.d rd，rs，rs。

![](media/image57.PNG){width="5.0680555555555555in"
height="1.332638888888889in"}**图5.7:用C编写的 浮点运算密集型的DAXPY
程序 **

![](media/image58.PNG){width="6.764583333333333in" height="0.75625in"}

**图5.8：DAXPY在四个ISA上生成的指令数和代码大小。它列出了每个循环的指令数量以及指令总数。第7章介绍ARM
Thumb-2，microMIPS和RV32C指令集。**

2.  否定：

> fneg.s rd，rs映射到fsgnjn.s rd，rs，rs
>
> fneg.d rd，rs映射到fsgnjn.d rd，rs，rs。

3.  绝对值（因为0⊕0= 0且1⊕1= 0）：

> fabs.s rd，rs变成了fsgnjx.s rd，rs，rs
>
> fabs.d rd，rs变成了sgnjx.d rd，rs，rs。

第二个不常见的浮点指令是classify分类指令（fclass.s，fclass.d）。分类指令对数学库也很有帮助。他们测试一个源操作数来看源操作数满足下列10个浮点数属性中的哪些属性（参见下表），然后将测试结果的掩码写入目的整数寄存器的低10位。十位中仅有一位被设置为1，其余为都设置为0。

  *x\[rd\]*位   含义
  ------------- -----------------------------------
  0             f \[*rs1*\]为$- \infty$。
  1             f \[*rs1*\]是负规格化数。
  2             f \[*rs1*\]是负的非规格化数。
  3             f \[*rs1*\]是-0。
  4             f \[*rs1*\]是+0。
  5             f \[*rs1*\]是正的非规格化数。
  6             f \[*rs1*\]是正的规格化数。
  7             f \[*rs1*\]为+$\infty$。
  8             f \[*rs1*\]是信号(signaling)NaN。
  9             f \[*rs1*\]是一个安静(quiet)NaN。

5.6使用DAXPY程序比较RV32FD，ARM-32，MIPS-32和x86-32
---------------------------------------------------

![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}我们现在将使用DAXPY作为我们的浮点基准对不同ISA进行比较（图5.7）。它以双精度计算$Y\  = \ a \times X + \ Y$，其中X和Y是矢量，a是标量。图5.8总结了DAXPY在四个不同的ISA下对应的指令数和字节数。他们的代码如图5.9至5.12所示。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}与第2章中的插入排序一样，尽管RISC-V指令集强调本身的简单性，RISC-V版本的不管是指令数量还是代码大小，都接近或者优于其他ISA。在此示例中，RISC-V的比较和执行分支指令和ARM-32和x86-32中更复杂的寻址模式，以及入栈、退栈指令节省了差不多数量的指令。

5.7结束语
---------

少即是多。

------Robert Browning,
1855，极简主义（建筑）建筑学派在20世纪80年代采用这首诗作为公理。

IEEE 754-2008浮点标准\[IEEE Standards Committee
2008\]定义了浮点数据类型，计算精度和所需操作。它的广泛流行大大降低了移植浮点程序的难度，这也意味着不同ISA中的浮点数部分可能比其他章节中描述的其他部分的指令更一致。

5.8 扩展阅读
------------

IEEE Standards Committee. 754-2008 IEEE standard for floating-point
arithmetic. *IEEE*

*Computer Society Std*, 2008.

A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
Manual, Volume I:*

*User-Level ISA, Version 2.2*. May 2017. URL
[[https://riscv.org/specifications/]{.underline}](https://riscv.org/specifications/).

**注记**

http://parlab.eecs.berkeley.edu

![](media/image59.PNG){width="5.772222222222222in"
height="2.8722222222222222in"}

**图5.9：图5.7中DAXPY的RV32D代码。十六进制的地址位于机器的左侧，接下来是十六进制的语言代码，然后是汇编语言指令，最后是注释。比较和分支指令避免了ARM-32和X86-32代码中的两条比较指令。**

![](media/image60.PNG){width="5.772222222222222in" height="2.45625in"}

**图5.10：图5.7中DAXPY的ARM-32代码。
与RISC-V相比，ARM-32的自动增量寻址模式可以节省两条指令。与插入排序不同，DAXPY在ARM-32上不需要压栈和出栈寄存器。**

**\
**

![](media/image61.PNG){width="5.772222222222222in"
height="2.7534722222222223in"}

**图5.11：图5.7中DAXPY的MIPS-32代码。三个分支延迟槽中的两个填充了有用的指令。检查两个寄存器之间是否相等的指令避免了ARM-32和x86-32中的两条比较指令。与整数加载不同，浮点加载没有延迟槽。**

![](media/image62.PNG){width="5.772222222222222in"
height="3.6944444444444446in"}

**图5.12：图5.7中DAXPY的x86-32代码。在这个例子中，x86-32缺少寄存器的劣势在这里表现得很明显------有四个变量被分配到了内存，而在其他ISA中，这些变量是被存放在寄存器中的。它展示了x86-32中，如何将寄存器与零比较（**test
ecx，ecx**）以及如何将一个寄存器清零（**xor eax,eax**）。**

第六章 原子指令
===============

![](media/image63.jpeg){width="1.1976017060367454in"
height="2.5833333333333335in"}所有的事物都应该尽量简单，但是不能太过简单。

------阿尔伯特·爱因斯坦（Albert Einstein），1933

6.1 导言
--------

我们假定你已经了解了ISA对如何支持多进程，所以我们在这儿只对RV32A指令和它们的行为进行解释。如果你觉得需要一些背景知识补充，可以看一下维基百科上的"同步（计算机科学）"词条（英文维基地址：<https://en.wikipedia.org/wiki/Synchronization>
中文地址：<https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5>
）或者阅读《RISC-V体系结构》2.1节\[Patterson and Hennessy 2017\]。

RV32A有两种类型的原子操作：

-   内存原子操作（AMO）

-   加载保留/条件存储（load reserved / store conditional）

图6.1是RV32A扩展指令集的示意图，图6.2列出了它们的操作码和指令格式。

![](media/image65.png){width="3.6492891513560806in"
height="2.42252624671916in"}

![](media/image66.png){width="5.7500415573053365in"
height="2.0260564304461943in"}**图6.1 RV32A指令图示**

**图6.2 RV32A指令格式、操作码、格式类型和名称。（这张图源于\[Waterman
and Asanovi´c 2017\]的表19.2。）**

AMO指令对内存中的操作数执行一个原子操作，并将目标寄存器设置为操作前的内存值。原子表示内存读写之间的过程不会被打断，内存值也不会被其它处理器修改。

加载保留和条件存储保证了它们两条指令之间的操作的原子性。加载保留读取一个内存字，存入目标寄存器中，并留下这个字的保留记录。而如果条件存储的目标地址上存在保留记录，它就把字存入这个地址。如果存入成功，它向目标寄存器中写入0；否则写入一个非0的错误代码。

为什么RV32A要提供两种原子操作呢？因为实际中存在两种不同的使用场景。

编程语言的开发者会假定体系结构提供了原子的比较-交换（compare-and-swap）操作：比较一个寄存器中的值和另一个寄存器中的内存地址指向的值，如果它们相等，将第三个寄存器中的值和内存中的值进行交换。这是一条通用的同步原语，其它的同步操作可以以它为基础来完成\[Herlihy
1991\]。

![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}尽管将这样一条指令加入ISA看起来十分有必要，它在一条指令中却需要3个源寄存器和1个目标寄存器。源操作数从两个增加到三个，会使得整数数据通路、控制逻辑和指令格式都变得复杂许多。（RV32FD的多路加法（multiply-add）指令有三个源操作数，但它影响的是浮点数据通路，而不是整数数据通路。）不过，加载保留和条件存储只需要两个源寄存器，用它们可以实现原子的比较交换（见图6.3的上半部分）。

![](media/image67.png){width="4.4631944444444445in"
height="2.4583333333333335in"}

**图6.3
同步的两个例子。第一个例子使用加载保留lr.w/条件存储sc.w实现比较-交换操作；第二个例子使用原子交换amoswap.w实现互斥。**

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}

另外还提供AMO指令的原因是，它们在多处理器系统中拥有比加载保留/条件存储更好的可扩展性，例如可以用它们来实现高效的归约。AMO指令在于I/O设备通信时也很有用，可以实现总线事务的原子读写。这种原子性可以简化设备驱动，并提高I/O性能。图6.3的下半部分展示了如何使用原子交换实现临界区。

**有什么不同之处？** 原始的MIPS-32没有同步机制，设计者在后来的MIPS
ISA中加入了加载保留/条件存储指令。

6.2 结束语
----------

RV32A是可选的，一个RISC-V处理器如果没有它就会更加简单。然而，正如爱因斯坦所言，一切事物都应该尽量简单，但不应该太过简单。RV32A正是如此，许多的场景都离不开它。

6.3 扩展阅读
------------

> S. V. Adve and K. Gharachorloo. Shared memory consistency models: A
> tutorial. *Computer*, 29(12):66--76, 1996.
>
> M. Herlihy. Wait-free synchronization. *ACM Transactions on
> Programming Languages and Systems*, 1991.
>
> D. A. Patterson and J. L. Hennessy. *Computer Organization and Design
> RISC-V Edition: The Hardware Software Interface*. Morgan Kaufmann,
> 2017.

A.  Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
    Manual, Volume I: User-Level ISA, Version 2.2*. May 2017. URL
    [[https://riscv.org/specifications/]{.underline}](https://riscv.org/specifications/).

**注记**

http://parlab.eecs.berkeley.edu

![](media/image68.emf){width="1.2497692475940507in" height="2.9814818460192476in"}第七章 压缩指令
=================================================================================================

小即是美。 ------E. F. Schumacher, 1973

7.1 导言
--------

以前的ISA为了缩短代码长度而显著扩展了指令和指令格式的数量，比如添加了一些只有两个（而不是三个）操作数的指令，减小立即数域，等等。ARM和MIPS为了能缩小代码，重新设计了两遍指令集，ARM设计出了ARM
Thumb和Thumb
2，MIPS先后设计出了MIPS16和microMIPS。这些新的ISA为处理器和编译器增加了负担，同时也增加了汇编语言程序员的认知负担。

RV32C采用了一种新颖的方法：每条短指令必须和一条标准的32位RISC-V指令一一对应。此外，16位指令只对汇编器和链接器可见，并且是否以短指令取代对应的宽指令由它们决定。编译器编写者和汇编语言程序员可以幸福地忽略RV32C指令及其格式，他们能感知到的则是最后的程序大小小于大多数其它ISA的程序。图7.1是RV32C扩展指令集的图形化表示。

![](media/image70.PNG){width="5.572916666666667in"
height="3.842534995625547in"}![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}![](media/image11.PNG){width="0.7166666666666667in"
height="0.6180555555555556in"}
为了能在一系列的程序上得到良好的代码压缩效果，RISC-V架构师精心挑选了RVC扩展中的指令。同时，基于以下的三点观察，架构师们成功地将指令压缩到了16位。第一，对十个常用寄存器（a0-a5，s0-s1，sp以及ra）访问的频率远超过其他寄存器；第二，许多指令的写入目标是它的源操作数之一；第三，立即数往往很小，而且有些指令比较喜欢某些特定的立即数。因此，许多RV32C指令只能访问那些常用寄存器；一些指令隐式写入源操作数的位置；几乎所有的立即数都被缩短了，load和store操作只使用操作数整数倍尺寸的无符号数偏移量。

**图7.1：RV32C的指令图示。移位指令的立即数域和c.addi4spn是零扩展的，其它指令采用符号位扩展。**

![](media/image71.PNG){width="5.768055555555556in"
height="1.0027777777777778in"}

**图7.2：用压缩指令集写成的插入排序和DAXPY程序的指令数和代码长度。**

图7.3和7.4列出了插入排序和DAXPY程序的RV32C代码。我们展示了这些RV32C指令，从而清楚地显示了这些压缩操作的效果，但是通常这些指令在汇编程序中是不可见的。注释中在括号内标出了与RV32C指令对应的等效32位指令。附录A中完整列出了16位RV32C指令和32位RISC-V指令的对应关系。

例如，在图7.3的插入排序程序中地址为4的地方，汇编器将如下的32位RV32I指令：

addi a4,x0,1 \# i = 1

替换为了这条16位RV32C指令：

c.li a4,1 \# （可扩展为 addi a4,x0,1） i = 1

RV32C的load立即数指令比较短，是因为它只能指定一个寄存器和一个小的立即数。c.li的机器码在图7.3中只有4个十六进制数，这表明c.li指令确实只有2字节长。

另一个例子在图7.3中地址为10的地方，汇编器将：

add a2,x0,a3 \# a2是指向a\[j\]的指针

换成了这条16位RV32C指令：

c.mv a2,a3 \#（可扩展为add a2,x0,a3） a2是指向a\[j\]的指针

RV32C的move指令只有16位长，因为它只指定两个寄存器。

![](media/image14.png){width="0.6263888888888889in"
height="0.6069444444444444in"}
尽管处理器的设计者们不能忽略RV32C的存在，但是有一个技巧可以让实现的代价变小：在执行之前用一个解码器将所有的16位指令转换为等价的32位指令。图7.6到7.8列出了解码器可以转换的RV32C指令的格式和操作码。最小的不支持任何扩展的32位RISC-V处理器要用到8000个门电路，而解码器只要400个门。如果它在这么小的设计中都只占5%的体量，那么它在约有100,000个门的中等大小带有cache的处理器中相当于不占资源。

**有什么不同之处？**RV32C中没有字节或半字指令，因为其他指令对代码长度的影响更大。第9页图1.5中Thumb-2相对于RV32C，在代码长度上更有优势，这是由于Load
and Store
Multiple对于过程（函数、子例程）进入和退出时可以节省不少代码。为了保证能和RV32G中的指令一一对应，RV32C中没有包括它们。而RV32G为了降低高端处理器的实现复杂性而省略了这些指令。由于Thumb-2是独立于ARM-32的ISA，但是处理器可以在两个ISA间切换。为了支持两套ISA，硬件必须有两个指令解码器，一个用于ARM-32，一个用于Thumb-2。RV32GC是一个单独的ISA，因此RISC-V处理器只需要一个解码器。

7.2 RV32GC，Thumb-2，microMIPS和x86-32的比较
--------------------------------------------

图7.2汇总了这四个ISA写成的插入排序和DAXPY程序的代码大小。

在插入排序的原始19条RV32I指令中，12条被替换成了RV32C指令，所以代码长度从$19 \times 4 = 76$个字节变成了$12 \times 2 + 7 \times 4 = 52$个字节，节省了$24/76 = 32\%$。DAXPY程序从$11 \times 4 = 44$个字节缩减到了$8 \times 2 + 3 \times 4 = 28$个字节，节省了$16/44 = 36\%$。

这两个小例子的结果与第二章第9页的图1.5惊人的一致，那里提到说，对于更多更复杂的程序，RV32G代码比RV32GC代码长37%。要达到这种程度的长度缩减，程序中必须有一半的指令可以被替换成RV32C指令。

7.3 结束语
----------

我本可以把信写得更短，但我没有时间。------Blaise Pascal, 1656

![](media/image11.PNG){width="0.7166666666666667in"
height="0.6180555555555556in"}他是建造了第一台机械计算器的数学家，因此图灵奖得主Niklaus
Wirth用他的名字命名了一门编程语言。

![](media/image21.png){width="0.6560247156605424in"
height="0.674248687664042in"}
RV32C让RISC-V程序拥有了当今几乎最小的代码尺寸。你几乎可以将它们视为硬件协助的伪指令。但是，现在汇编器将它们在汇编语言程序员和编译器编写者面前隐藏起来。这里我们没有像第三章那样，将能提升RISC-V代码易用性与易读性的常用操作的组织成指令，来扩展真实的指令集。这两种方法都有助于提供程序员的工作效率。

RISC-V提倡用一套简洁、有效的机制来提升性价比，RV32C就是一个极佳的范例。

7.4 扩展阅读
------------

A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
Manual, Volume I: User-Level ISA, Version 2.2*. May 2017. URL
https://riscv.org/specifications/.

**注记**

http://parlab.eecs.berkeley.edu

**图7.3：插入排序的RV32C代码。12条16位指令使得代码长度缩减**![](media/image72.PNG){width="5.768055555555556in"
height="4.0472222222222225in"}**了32%。每条指令的宽度可以很容易地得知。RV32C指令（以**c.**开头）在这个例子中显式出现，但通常汇编语言程序员和编译器无法看到它们。**

![](media/image73.PNG){width="5.768055555555556in"
height="2.3520833333333333in"}

**图7.4：DAXPY的RV32DC代码。8条十六位指令将代码长度缩减了36%。每条指令的宽度见第二列的十六进制字符个数。RV32C指令（以**c.**开头）在这个例子中显式出现，但通常汇编语言程序员和编译器无法看到它们。**

**\
**

![](media/image74.PNG){width="5.768055555555556in"
height="3.0506944444444444in"}

**图7.5：RV32C操作码映射（bits\[1:0\] =
01）列出了指令布局，操作码，指令格式和指令名称。rd',rs1'和rs2'指的是10个常用的寄存器**a0-a5，s0-s1，sp**和**ra**。（本图来源于\[Waterman
and Asanovi´c 2017\]的表12.5。）**

![](media/image75.PNG){width="5.768055555555556in"
height="1.7895833333333333in"}

**图7.6：RV32C操作码表（bits\[1:0\] =
00）列出了指令布局，操作码，指令格式和指令名称。rd',rs1'和rs2'指的是10个常用的寄存器**a0-a5，s0-s1，sp**和**ra**。（本图来源于\[Waterman
and Asanovi´c 2017\]的表12.4。）**

**\
**

![](media/image76.PNG){width="5.768055555555556in"
height="2.6194444444444445in"}

**图7.7：RV32C操作码表（bits\[1:0\] =
10）列出了指令布局，操作码，指令格式和指令名称。（本图来源于\[Waterman
and Asanovi´c 2017\]的表12.6。）**

![](media/image77.PNG){width="5.768055555555556in"
height="1.7444444444444445in"}

**图7.8：16位RVC压缩指令的格式。**rd',rs1'**和**rs2'**指的是10个常用的寄存器**a0-a5，s0-s1，sp**和**ra**。（本图来源于\[Waterman
and Asanovi´c 2017\]的表12.1。）**

第八章 向量
===========

![](media/image78.emf){width="1.2497692475940507in"
height="2.0277777777777777in"}

我追求简洁。我理解不了那些复杂的东西。------Seymour Cray

8.1 导言
--------

本章重点介绍数据并行，当存在大量数据可供应用程序同时计算时，我们称之为数据级并行性。数组是一个常见的例子。虽然它是科学应用的基础，但它也被多媒体程序使用。前者使用单精度和双精度浮点数据，后者通常使用8位和16位整数数据。

最著名的数据级并行架构是单指令多数据(SIMD，Single Instruction Multiple
Data)。SIMD最初的流行是因为它将64位寄存器的数据分成许多个8位、16位或32位的部分，然后并行地计算它们。操作码提供了数据宽度和操作类型。数据传输只用单个（宽）SIMD寄存器的load和store进行。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}把现有的64位寄存器进行拆分的做法由于其简单性而显得十分诱人。为了使SIMD更快，架构师随后加宽寄存器以同时计算更多部分。由于SIMD
ISA属于增量设计阵营的一员，并且操作码指定了数据宽度，因此扩展SIMD寄存器也就意味着要同时扩展SIMD指令集。将SIMD寄存器宽度和SIMD指令数量翻倍的后续演进步骤都让ISA走上了复杂度逐渐提升的道路，这一后果由处理器设计者、编译器编写者和汇编语言程序员共同承担。

![](media/image80.PNG){width="5.197916666666667in"
height="4.0in"}一个更老的，并且在我们看来更优雅的，利用数据级并行性的方案是向量架构。本章解释了我们在RISC-V中使用向量而不是SIMD的理由。

**图8.1：RV32V的指令图示。由于采用了动态寄存器类型，这个指令图示也可以不加改变地用于第九章的RV64V**

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}![](media/image17.png){width="0.7763888888888889in"
height="0.6409722222222223in"}向量计算机从内存中中收集数据并将它们放入长的，顺序的向量寄存器中。在这些向量寄存器上，流水线执行单元可以高效地执行运算。然后，向量架构将结果从向量寄存器中取出，并将其并分散地存回主存。向量寄存器的大小由实现决定，而不是像SIMD中那样嵌入操作码中。我们将会看到，将向量的长度和每个时钟周期可以进行的最大操作数分离，是向量体系结构的关键所在：向量微架构可以灵活地设计数据并行硬件而不会影响到程序员，程序员可以不用重写代码就享受到长向量带来的好处。此外，向量架构比SIMD架构拥有更少的指令数量。而且，与SIMD不同，向量架构有着完善的编译器技术。

![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}向量架构比SIMD架构更少出现，因此知晓向量ISA的读者也更少。因此，本章会比前几章更加具有教程的风格。如果你想深入了解向量架构，请阅读\[Hennessy
and Patterson
2011\]的第4章和附录G。RV32V还有一些简化了ISA的新颖功能。即使你已经熟悉了向量架构，也可能需要阅读我们的进一步解释。

8.2 向量计算指令
----------------

图8.1是RV32V扩展指令集的图形表示。RV32V的编码尚未最终确定，所以本版不包含通常的指令布局图。

前面章节提到的每一个整数和浮点计算指令基本都有对应的向量版本：图8.1中的指令继承了来自RV32I、RV32M、RV32F、RV32D和RV32A的操作。每个向量指令都有几种类型，具体取决于源操作数是否都是向量（.vv后缀），或者源操作数包含一个向量和一个标量（.vs后缀）。一个标量后缀意味着有一个操作数来自x或f寄存器，另一个来自向量寄存器（v）。比方说，我们的DAXPY程序（见第55页第五章图5.7）计算$Y = a \times X + Y$。其中$X$和$Y$是向量，$a$是标量。对于向量-标量操作，rs1域指定了要访问的标量寄存器。

对诸如减法和除法之类的非对称运算，他们还会使用向量指令的第三种变体。其中第一个操作数是标量，第二个是向量（.sv后缀）。像$Y = a - X$这样的操作就会使用这种变体。这种变体对于加法和乘法等对称运算来说是多余的，因此这些指令没有.sv的版本。融合的（fused）乘法-加法指令有三个操作数，因此它们有着最多的向量和标量选项的组合：.vvv、.vvs，.vsv和.vss。

读者可能会注意到，图8.1忽略了向量运算的数据类型和宽度。下一节解释了这么做的原因。

8.3 向量寄存器和动态类型
------------------------

RV32V添加了32个向量寄存器，它们的名称以v开头，但每个向量寄存器的元素个数不同。该数量取决于操作的宽度和专用于向量寄存器的存储大小，而这取决于处理器的设计者。比方说，如果处理器为向量寄存器分配了4096个字节，则这足以让这些32个向量寄存器中有16个64位元素，或者32个32位元素，或者64个16位元素，或128个8位元素。

为了在向量ISA中保持元素数量的灵活性，向量处理器会计算会最大向量长度（mvl），即在给定的容量限制下，向量程序使用这个向量寄存器可以运算的最大向量长度。向量长度寄存器（vl）为特定操作设定了向量中含有的元素数量，这有助于数组维度不是mvl的整数倍时的编程。我们将在下面的小节中更详细地演示mvl，vl和8个谓词寄存器（vpi）的应用。

RV32V采用了一种新颖的方法，即将数据类型和长度与向量寄存器而不是与指令操作![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}码相关联。程序在执行向量计算指令之前用它们的数据类型和宽度标记向量寄存器。使用动态寄存器类型会减少向量指令的数量。这一点很重要，因为每个向量指令通常有六个整数版本和三个浮点版本，如图8.1所示。我们将在第8.9节看到，当我们面对众多的SIMD指令时，使用动态寄存器类型的向量架构减少了汇编语言程序员的认知负担以及编译器生成代码的难度。

动态类型的另一个优点是程序可以禁用未使用的向量寄存器。此功能可以将所有的向量存储器分配给已启用的向量寄存器。比如，假设只启用了两个64位浮点类型的向量寄存器，处理器有1024字节的向量寄存器空间。处理器将这些空间对半分，给每个向量寄存器512字节（512/8=64个元素），因此将mvl设置位64。因此我们可以看到，mvl是动态的，但它的值由处理器设置，不能由软件直接改变。

源寄存器和目标寄存器决定了操作的类型和大小以及结果，因此动态类型隐含了转换。例如，处理器可以将双精度浮点数的向量乘以单精度标量，而无需先将操作数转换为相同的精度。这个额外的好处减少了向量指令的总数和实际执行的指令的数量。

可以用vsetdcfg指令来设置向量寄存器的类型。图8.2显示了RV32V可用的向量寄存器类型以及RV64V的更多类型（见第九章）。RV32V要求向量浮点运算也有标量版本。因此，要使用F32类型，你也必须用到RV32FV；要使用F64类型，你也必须用到RV32FDV。RV32V引入了16位浮点类型F16。如果一个实现同时支持RV32V和RV32F，则它必须支持F16和F32类型。

![](media/image81.PNG){width="4.152777777777778in"
height="1.1234569116360456in"}

**图8.2：RV32V向量寄存器类型的编码。字段的最右边三位指示了数据的位宽，左边两位给出其类型。X64和U64仅适用于RV64V。F16和F32需要RV32F扩展，F64需要RV32F和RV32D。F16是IEEE
754-2008
16位浮点格式（binary16）。将**vetype**设置为00000会禁用向量寄存器。（本图基于\[Waterman
and Asanovic 2017\]的表17.4。）**

8.4 向量的Load和Store操作
-------------------------

向量Load和Store操作的最简单情况是处理按顺序存储在内存中的一维数组。向量Load用以vld指令中地址为起始地址的顺序存储的数据来填充向量寄存器。向量寄存器的数据类型确定数据元素的大小，向量长度寄存器vl中设置了要取的元素数量。向量store执行vld的逆操作。

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}例如，如果a0中存有1024，且v0的类型是X32，则vld
v0,
0(a0)会生成地址1024，1028，1032，1036，......直到达到由vl设置的限制。

对于多维数组，某些访问不是顺序的。如果二维数组以行优先序存储，且对列元素进行顺序访问，则相邻列元素之间的地址差正好是行大小。向量架构通过跨步数据传输来支持vlds和vsts数据访问。对于vlds与vsts，虽然可以通过将步长设置为元素大小来达到与vld和vst相同的效果，但vld和vst保证了所有的访问都是顺序的，这可以提供更高的内存带宽。另一个原因是，对于常见的按单位步长访问，使用vld和vst可以缩减代码长度，并减少执行的指令数。毕竟使用vlds和vsts指令来需要指定两个源寄存器，一个给出起始地址，另一个给出以字节为单位的步长，而对于单位步长的访问，多花指令来设置第二个寄存器，无遗是一种浪费。

例如，假设a0中的起始地址是地址1024，且a1中行的长度是64字节。vlds v0, a0,
a1会将这个地址序列发送到内存：$1024,\ 1088(1024 + 1 \times 64),\ 1152(1024 + 2 \times 64),\ 1216(1024 + 3 \times 64)$，以此类推，直到向量长度寄存器vl告诉它停止。返回的数据被顺序写入目标向量寄存器的各个元素。

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}到目前为止，我们都假设该程序在对密集数组进行操作。为了支持稀疏数组，向量架构用vldx和vstx提供索引数据传输。这些指令的一个源寄存器是向量寄存器，另一个是标量寄存器。标量寄存器具有稀疏数组的起始地址，向量寄存器的每个元素包含稀疏数组的非零元素的字节索引。

假设a0中的起始地址是地址1024，向量寄存器v1在前四个元素中有这些字节索引：16，48，80，160。vldx
v0, a0,
v1会将这个地址序列发送到内存：$1040（1024 + 16）,\ 1072(1024 + 48),\ 1104(1024 + 80),\ 1184(1024 + 160)$。它将返回的数据顺序写入目标向量寄存器的元素中。

以上我们把稀疏数组访问作为索引Load和Store操作的主要支持目标，但是还有许多其他算法通过索引表来间接访问数据。

![](media/image13.png){width="0.7833333333333333in" height="0.4388888888888889in"}8.5 向量操作期间的并行性
----------------------------------------------------------------------------------------------------------

虽然简单的向量处理器一次操作一个向量元素，但由于元素操作根据定义是独立的，所以理论上处理器可以同时计算所有这些元素。RV32G的数据位宽最大位64位，而如今的向量处理器通常在每个时钟周期内操作两个、四个或八个64位元素。当向量长度不是每个时钟周期执行的元素数量的倍数时，由硬件处理处理这些边缘情况。

与SIMD一样，对于较小数据的操作数量是较窄数据的位宽和较宽数据的位宽之比。因此，每个时钟周期计算4个64位操作的向量处理器通常每个时钟周期可以做8个32位，16个16位或32个8位操作。

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}
在SIMD中，ISA架构师在设计过程中决定了每个时钟周期可以并行操作的最大数据数和每个寄存器的元素个数。相比之下，RV32V处理器设计人员无需更改ISA或编译器就可以选择它们的值，而对于SIMD，寄存器每增加一倍都会使SIMD指令的数量翻倍，并且需要修改SIMD编译器。这种隐藏的灵活性意味着相同的RV32V程序不用改变，就可以在最简单或最复杂的向量处理器上运行。

8.6 向量运算的条件执行
----------------------

一些向量计算包括if语句。向量架构不依赖于条件分支，而是包含了一个掩码，这个掩码禁止向量操作作用于某些元素。图8.1中的谓词指令在两个向量或向量和标量之间执![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}行条件测试，如果条件成立则在掩码向量的每一个元素中写入一个1，反之写入0。（掩码向量必须和向量寄存器有相同的元素个数。）任何后续的向量指令都可以使用这个掩码。第i位为1表示元素i会被向量运算更改，为0表示该元素不会由向量运算改变。

RV32V为掩码向量提供了8个向量谓词寄存器（vpi）。vpand，vpandn，vpor，vpxor和vpnot指令在它们之间执行逻辑运算，从而有效处理嵌套条件语句。

RV32V指定vp0或vp1作为控制向量操作的掩码。要对所有元素执行一个正常的操作，必须将这两个谓词寄存器中的一个设置为全1。RV32V中有一条vpswap指令，用于将其他六个谓词寄存器的一个快速交换到vp0或vp1。谓词寄存器也是动态启用的，禁用它们可以快速清除所有谓词寄存器中的值。

例如，假设向量寄存器v3中的所有偶数元素都是负整数，所有奇数元素都是正整数。考虑如下的代码：

vplt.vs vp0,v3,x0 \# 将 v3 \< 0的掩码位置1

add.vv,vp0 v0,v1,v2 \# 将v0的掩码为1的对应元素替换为v1+v2

这段代码将把vp0中所有的偶数位设为1，奇数位设为0，并且将把v0中所有的偶数元素替换为v1和v2中对应元素的和。v0中的奇数元素不会改变。

8.7 其他向量指令
----------------

除了之前提到过的设置向量寄存器数据类型的指令（vsetdcfg），其他指令还有setvl，它将向量长度寄存器（vl）设置为源操作数和最大向量长度（mvl）中的较小值。选择较小值的原因是，在循环中我们需要判断这些向量代码到底是可以按最大向量长度（mvl）运行，还是要以一个较小值运行，从而能处理循环尾部剩下的元素。因此，为了处理循环尾部的元素，每次循环迭代都执行setvl。

RV32V中还有三条指令可以操作向量寄存器中的元素。

向量选择（vselect）按第二个源向量（索引向量）指定的元素位置，从第一个源数据向量中取得元素，从而生成一个新的结果向量：

\# vindices存有0到mvl-1的值，它们用来从vsrc中选取元素

vselect vedst, vsrc, vindices

因此，如果v2的前四个元素是8、0、4、2，那么vselect v0, v1,
v2将用v1的第8个元素替换v0的第0个元素；v1的第0个元素替换v0的第1个元素；v1的第4个元素替换v0的第2个元素；v1的第2个元素替换v0的第3个元素。

向量合并（vmerge）类似于向量选择，但它用向量谓词寄存器来选择源向量中要用到元素。新的结果向量由根据谓词寄存器从两个源寄存器之一取得元素产生。若谓词向量寄存器元素为0，则新元素来自vsrc1；如果为1，则来自vsrc2。

\# vp0的第i位决定vdest中新元素i来自vsrc1（若第i位是0）

\# 还是vsrc2（第i位为1）

vmerge,vp0 vdest, vsrc1, vsrc2

因此，如果vp0的前四个元素是1、0、0、1，v1的前四个元素是1、2、3、4，v2的前四个元素是10、20、30、40，那么vmerge,vp0
v0, v1, v2将把v0的前四个元素变为10、2、3、40。

向量提取指令从一个向量的中间开始取元素，并将它们放在第二个向量寄存器的开头：

\# start是一个标量寄存器，其中存储着从vsrc中取元素的起始位置

vextract vdest, vsrc, start

例如，如果向量长度vl是64，而a0的值是32，那么vextract
v0,v1,a0会把v1中的后32个元素复制到v0的前三十二个元素。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}
对于任意的二元结合运算符，可以利用vextract指令以递归减半的方法进行缩减运算。例如，要对向量寄存器的所有元素求和，可以用vextract将向量的后半部分复制到另一个向量寄存器的前半部分，这就将向量长度缩短了一半。接下来，将这两个向量寄存器加到一起，并将它们的和作为新一轮递归的操作数，直到向量长度减少到1。此时第零个元素中的结果就是原向量寄存器中所有元素的和。

**图8.3：图5.7中DAXPY程序的RV32V代码。没有出现机器语言是因为RV32V的操作码还未定义。**![](media/image82.PNG){width="5.768055555555556in"
height="3.0131944444444443in"}

8.8 例子：用RV32V写成的DAXPY程序
--------------------------------

图8.3显示了用RV32V汇编写成的DAXPY程序（见第五章第55页图5.7），我们一次解释一个步骤。

RV32V
DAXPY程序做的第一件事是启用这个函数需要的向量寄存器。它只需要两个向量寄存器保存x和y的部分元素，这些元素一个个都是8字节宽的双精度浮点数。第一条指令生成一个常量，第二条指令将它写入配置向量寄存器的控制状态寄存器（vcfgd），从而获得两个F64类型的寄存器（见图8.2）。根据定义，硬件按数字顺序分配配置好的寄存器，这样便有了v0和v1。

假设我们的RV32V处理器由1024字节的空间专门用于向量寄存器。硬件平均地给这两个双精度浮点型（8字节）的向量寄存器分配空间。每个向量寄存器有$512/8 = 64$个元素，因此处理器将此函数的最大向量长度（mvl）设置为64。

循环中的第一条指令为接下来的向量指令设置向量长度。setvl指令把mvl和n中的小值写入vl和t0。其中的深刻原因是，如果循环的迭代次数大于n，那么这段代码最快可以一次处理64个值，所以把mvl的值写入vl。如果n比mvl小，那么我们的读写不能超出x和y的范围，所以我们应该在循环最后一次迭代中只计算最后剩下的n个元素。setvl还写入t0，用于保存vl的值，在地址为10的循环控制变量中会用到。

地址c处的指令vld是一个向量load操作，按照标量寄存器a1中存储的变量x的地址从x中取值。它把x的vl个元素从内存传输到v0。下面的移位指令slli将向量长度乘以数据的宽度（8字节），以便稍后用于递增指向x和y的指针。

地址14处的指令（vld）将来自内存的vl个元素load到v1中，接下来的一条指令（add）将指向x的指针进行了递增。

地址1c处的指令是最重要的部分。vfmadd将x（v0）中的vl个元素乘以标量a（f0）并将每个乘积加上y（v1）中的vl个元素，最后将这vl个和存回y（v1）。

剩下的就是将结果存到内存中以及一些必须的循环开销。在地址20处的指令（sub）将n（a0）的减去vl，以记录在本次迭代中完成的操作数。接下来的一条指令（vst）将vl个结果写入内存中y数组中。地址28处的指令（add）将指向y数组的指针递增。接下来的指令判断n（a0）是否为0，若不是则继续循环，反之执行最后一条ret指令返回调用点。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}
向量架构的强大之处在于，这个包含10条指令的循环的每次迭代都会进行$3 \times 64 = 192$次访存操作和$2 \times 64 = 128$个浮点乘加（假设n至少为64）。这意味着每条指令平均有19次访存和13次运算。我们将在下一节看到，SIMD的这些数据要差一个数量级。

8.9 RV32V，MIPS-32 MSA SIMD和x86-32 AVX SIMD的比较
--------------------------------------------------

我们即将看到SIMD和向量架构执行DAXPY程序的对比。如果你换一种角度来看，也可以把SIMD视为有着短向量寄存器（8个8位"元素"）的受限向量架构，但它没有向量长度寄存器，也没有跨步或索引数据传输。

**MIPS SIMD** 第83页的图8.5显示了DAXPY程序的MIPS
SIMD架构（MSA）版本。由于MSA寄存器为128位宽，所以每个MSA
SIMD指令可以操作两个双精度浮点数。

与RV32V不同，由于没有向量长度寄存器，MSA需要额外的指令来检查n的值是否有问题。当n为奇数时，计算单个浮点数的乘-加运算需要额外的代码，因为MSA必须对成对的操作数进行操作。该代码位于图8.5的地址3c到4c处。尽管概率不大，但n也有可能为0。在这种情况下，地址为10处的分支将跳过主计算循环。

如果没有在循环附近执行分支跳转，则地址为18处的指令（splati.d）把a的值同时放入SIMD寄存器w2的两半中。在SIMD中，要加一个标量数据，我们需要将其复制拓宽到与SIMD寄存器等宽。

在循环内部，地址为1c处的ld.d指令将y的两个元素load到SIMD寄存器w0中，然后将指向y的指针进行递增。然后它将x的两个元素load到SIMD寄存器w1中。接下来地址28处的指令执行将指向x的指针进行递增，紧接在后面的是地址为2c处的最重要的乘加指令。

循环结束时的分支指令（带延迟槽）判断指向y的指针是否已经超出了y的范围。如果没有，循环继续。地址34处的延迟槽中的SIMD
store指令将结果写入y的两个元素。

主循环终止后，代码检查n是否是奇数。若n是奇数，用第五章的标量指令执行最后一次乘加操作。最后一条指令返回到调用点。

MIPS MSA
DAXPY代码核心的循环部分包含了7条指令，执行了6次双精度访存操作和4次浮点乘加。平均每个指令大约有1个访存和0.5个运算操作。

![](media/image83.PNG){width="5.083333333333333in"
height="1.165262467191601in"}**图8.4：向量ISA的DAXPY指令数和代码大小。他列出了指令总数（静态），代码大小，每个循环的指令数和运算结果数，以及执行的指令数（n
=
1000）。带MSA的microMIPS将代码大小缩减到64字节，RV32FDCV将代码缩减到40字节。**

**x86 SIMD**
在84页的图8.6的代码中我们可以看到，Intel公司经历了多代SIMD扩展。SSE扩展到了128位SIMD，带来了xmm寄存器和可以使用这些寄存器的指令；AVX的一部分带来了256位SIMD，以及ymm寄存器及其指令。

地址0到25的第一组指令从内存中load变量，在256位ymm寄存器中创建a的四个副本，并在进入主循环之前进行测试，以确保n至少为4。这用到了两条SSE指令和一条AVX指令。（图8.6的标题中有更详细的解释）

主循环是DAXPY计算的核心。地址27处的AVX指令vmovapd将x的4个元素load到ymm0中。地址2c处的AVX指令vfmadd213pd将a（ymm2）乘以x（ymm0）的4个元素的4个副本，加上y的四个元素（在内存中地址为ecx+edx\*8处），并将4个和放入ymm0。接下来地址32处的AVX指令vmovapd将4个结果存储到变量y中。随后的三条指令执行计数器的递增操作并在需要的时候重复循环。

与MIPS
MSA的情况一样，地址3e和57之间的"边缘"代码处理了n不是4的倍数的情况。它用到了三个SSE指令。

x86-32 AVX2
DAXPY代码中主循环的6条指令执行了12次双精度访存和8次浮点的乘法和加法操作。这样每条指令平均有约2次访存和1次运算。

8.10 结束语
-----------

如果代码能向量化，最好的架构就是向量架构。

------Jim Smith于1994年在国际计算机体系结构研讨会上的主旨演讲

图8.4总结了RV32IFDV，MIPS-32 MSA和x86-32
AVX2的DAXPY程序中的指令数和字节数。SIMD架构程序中用于计算的代码比用于循环控制的代码要少不少。MIPS-32
MSA和x86-32
AVX2代码中的三分之二到四分之三是SIMD开销：这些额外的代码要么是在为主SIMD循环准备数据，要么是在n不是SIMD寄存器中浮点数个数的倍数时处理那些边缘元素。

图8.3中的RV32V代码不需要这样的循环控制代码，因此它的指令数量少了一半。与SIMD不同，RV32V有一个向量长度寄存器，使得不论n为何值，向量指令都可以工作。你可能会觉得n为0时RV32V会出现问题。实际上它不会，因为RV32V中的向量指令在![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}vl=0时不会做出任何改变。

但是，SIMD和向量处理之间的最为显著的区别不在于代码的长短。SIMD执行的指令数比RV32V多10到20倍，因为每个SIMD循环在向量模式下只操作2到4个元素，而不是RV32V的64个元素。额外的取指和译码意味着在执行相同任务时要耗费更多的能量。

![](media/image13.png){width="0.7833333333333333in"
height="0.4388888888888889in"}
将图8.4中的结果与第五章中第29页的图5.8中的DAXPY的标量版本进行比较，我们发现SIMD大概使得代码的指令数和字节数加倍，但主循环的大小相同。执行的动态指令的数量以2或4的因子减少，这取决于SIMD寄存器的宽度。然而，RV32V的向量代码大小变为原来的1.2倍（主循环1.4倍），但动态指令数是原来的1/43！

即使动态指令的数量差别很大，但在我们看来，这并不是SIMD和向量架构的最主要的差异。没有向量长度寄存器会让指令数和循环控制代码暴增。像MIPS-32和x86-32这些遵循增量主义的ISA必须每次在将SIMD寄存器宽度翻倍时，都复制所有那些为较窄的SIMD寄存器定义的指令。于是不出意外地，在许多代SIMD
ISA的传承中一共创造了数百条MIPS-32和x86-32指令，而且将来还会有数以百计的新指令出现。汇编语言程序员一定因这种粗暴的ISA演变方式而承担了难以承受的认知负担。像vfmadd213pd这样的指令，谁能记住它的含义并知道什么时候要用它？

![](media/image17.png){width="0.7763888888888889in"
height="0.6409722222222223in"}![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}
相比之下，RV32V代码不受向量寄存器的可用存储空间的大小影响。如果向量内存变大，不仅RV32V不会改变，而且你甚至不用重新编译。处理器提供了最大向量长度mvl的值，因此无论处理器将用于向量的存储空间从1024字节提升到了4096字节，还是将其降低到256字节，图8.3中的代码都不受影响。

不同于SIMD中由ISA指示所需的硬件，而且更改ISA意味着更改编译器那样，RV32V
ISA允许处理器设计人员为其应用分配合适资源用于数据并行，而不必影响程序员或编译器。可以说SIMD违反了第一章中将ISA架构和实现分离开来的ISA设计原则。

![](media/image21.png){width="0.6560247156605424in"
height="0.674248687664042in"}
我们认为RV32V的模块化向量实现对比ARM-32、MIPS-32和x86-32的增量式SIMD架构在成本-能耗-性能、复杂度和编程简易性等方面的极大优势，可能是选用RISC-V的最有说服力的论据。

8.11 扩展阅读
-------------

H. Falk. What went wrong V: Reaching for a gigaflop: The fate of the
famed Illiac IV was shaped by both research brilliance and real-world
disasters. *IEEE spectrum*, 13(10):65--70, 1976.

J. L. Hennessy and D. A. Patterson. *Computer architecture: a
quantitative approach*. Elsevier, 2011.

A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
Manual, Volume I: User-Level ISA, Version 2.2*. May 2017. URL
[[https://riscv.org/specifications/]{.underline}](https://riscv.org/specifications/).

**注记**

http://parlab.eecs.berkeley.edu

![](media/image84.PNG){width="6.475694444444445in"
height="4.683333333333334in"}

**图8.5：图5.7中DAXPY的MIPS-32
MSA代码。将此代码与图8.3中的RV32V代码进行比较时，SIMD的循环控制开销显而易见。MIPS
MSA代码的第一部分（地址0到18）复制了SIMD寄存器中的标量变量a，并在进入主循环之前执行确保n至少为2的检查。当n不是2的倍数时，MIPS
MSA代码的第三部分（地址38到4c）处理了这种边界情况情况。在RV32V中不需要这样的代码，因为向量长度寄存器**vl**和**setvl**指令使得该循环的代码适用于n的所有值，不论是奇数还是偶数。**

**\
**

![](media/image85.PNG){width="6.377083333333333in"
height="6.235416666666667in"}**图8.6：图5.7中DAXPY的x86-32
AVX2代码。地址a处的SSE指令**vmovsd**把a
load到128位**xmm1**寄存器的一半。地址14处的SSE指令**vmovddup**将a复制到**xmm1**的全部两半，以用于接下来的SIMD计算。地址1d处的AVX指令**vinsertf128**从**xmm1**中的a的两个副本，在**ymm2**中生成a的四个副本。地址42到4d的三个AVX指令（**vmovsd，vfmadd213sd，vmovsd）**处理**$\mathbf{\text{mod}}\mathbf{（}\mathbf{n}\mathbf{，}\mathbf{4}\mathbf{）}\mathbf{\neq}\mathbf{0}$**的情况。它们以一次一个元素的方式执行DAXPY操作，循环在这个函数正好进行了n次乘-加操作的时候停止。再提一次，RV32V不需要这样的代码，因为向量长度寄存器**vl**和**setvl**指令使得那些循环代码适用于n为任意值的情况。**

第九章 RV64：64位地址指令
=========================

![](media/image86.jpeg){width="1.225in" height="3.1759251968503937in"}

在计算机设计中只能出现一个错误是难以恢复的------没有足够的地址位用于存储器寻址和存储器管理。

------C. Gordon Bell, 1976

9.1 导言
--------

图9.1至9.4是RV32G指令集的64位版本RV64G指令集的图示。由图可见，要切换到64位ISA，ISA只添加了少数指令。指令集只添加了32位指令对应的字(word)，双字(doubleword)和长整数(long)版本的指令，并将所有寄存器（包括PC）扩展为64位。因此，RV64I中的sub操作的是两个64位数字而不是RV32I中的32位数字。RV64很接近RV32但实际上又有所不同;它添加了少量指令同时基础指令做的事情与RV32中稍有不同。

例如，图9.8中RV64I版本的插入排序与第2章第27页的图2.8中RV32I版本的插入排序非常相似。它们指令数量和大小都相同。唯一的变化是加载和存储字指令变为加载并存储双字，地址增量从对应字的4（4字节）变为对应双字的8（8字节）。图9.5列出了图9.1到9.4中的RV64GC指令的操作码。

尽管RV64I有64位地址且默认数据大小为64位，32位字仍然是程序中的有效数据类型。因此，RV64I需要支持字，就像RV32I需要支持字节和半字一样。更具体地说，由于寄存器现在是64位宽，RV64I添加字版本的加法和减法指令：addw，addiw，subw。这些指令将计算结果截断为32位，结果符号扩展后再写入目标寄存器。
RV64I也包括字版本的移位指令（sllw，slliw，srlw，srliw，sraw，sraiw），以获得32位移位结果而不是64位移位结果。要进行64位数据传输，RV64提供了加载和存储双字指令：ld，sd。最后，就像RV32I中有无符号版本的加载单字节和加载半字的指令，RV64I也有一个无符号版本的加载字：lwu。

出于类似的原因，RV64需要添加字版本的乘法，除法和取余指令：mulw，divw，divuw，remw，remuw。为了支持对单字及双字的同步操作，RV64A为其所有的11条指令都添加了双字版本。

![](media/image88.PNG){width="5.772222222222222in"
height="3.6173611111111112in"}

**图9.1：RV64I指令图示。带下划线的字母从左到右连起来构成RV64I指令。灰色部分是扩展到64位寄存器的旧RV64I指令，而暗（红色）部分是RV64I的新指令。**

![](media/image89.PNG){width="5.772222222222222in"
height="2.3652777777777776in"}

**图9.2：RV64M和RV64A指令图示**

![](media/image90.PNG){width="5.772222222222222in"
height="3.5083333333333333in"}**图9.3：RV64F和RV64D指令图**

![](media/image91.PNG){width="5.772222222222222in"
height="3.892361111111111in"}

**图9.4L：RV64C指令图**

  imm\[11:0\]   rs1     110   rd    0000011      I lwu     
  ------------- ------- ----- ----- ------------ --------- ---------
  imm\[11:0\]   rs1     011   rd    0000011      I ld      
  imm\[11:5\]   rs2     rs1   011   imm\[4:0\]   0100011   S sd
  0000000       shamt   rs1   001   rd           0010011   I slli
  0000000       shamt   rs1   101   rd           0010011   I srli
  0100000       shamt   rs1   101   rd           0010011   I srai
  imm\[11:0\]   rs1     000   rd    0011011      I addiw   
  0000000       shamt   rs1   001   rd           0011011   I slliw
  0000000       shamt   rs1   101   rd           0011011   I srliw
  0100000       shamt   rs1   101   rd           0011011   I sraiw
  0000000       rs2     rs1   000   rd           0111011   R addw
  0100000       rs2     rs1   000   rd           0111011   R subw
  0000000       rs2     rs1   001   rd           0111011   R sllw
  0000000       rs2     rs1   101   rd           0111011   R srlw
  0100000       rs2     rs1   101   rd           0111011   R sraw

**RV64M Satndard Extension (in addition to RV32M)**

  0000001   rs2   rs1   000   rd   0111011   R mulw
  --------- ----- ----- ----- ---- --------- ---------
  0000001   rs2   rs1   100   rd   0111011   R divw
  0000001   rs2   rs1   101   rd   0111011   R divuw
  0000001   rs2   rs1   110   rd   0111011   R remw
  0000001   rs2   rs1   111   rd   0111011   R remuw

**RV64A Satndard Extension (in addition to RV32A)**

  00010   aq   rl   00000   rs1   011   rd   0101111   R lr.d
  ------- ---- ---- ------- ----- ----- ---- --------- --------------
  00011   aq   rl   rs2     rs1   011   rd   0101111   R sc.d
  00001   aq   rl   rs2     rs1   011   rd   0101111   R amoswap..d
  00000   aq   rl   rs2     rs1   011   rd   0101111   R amoadd.d
  00100   aq   rl   rs2     rs1   011   rd   0101111   R amoxor.d
  01100   aq   rl   rs2     rs1   011   rd   0101111   R amoand.d
  01000   aq   rl   rs2     rs1   011   rd   0101111   R amoor.d
  10000   aq   rl   rs2     rs1   011   rd   0101111   R amomin.d
  10100   aq   rl   rs2     rs1   011   rd   0101111   R amomax.d
  11000   aq   rl   rs2     rs1   011   rd   0101111   R amominu.d
  11100   aq   rl   rs2     rs1   011   rd   0101111   R amomaxu.d

**RV64F Satndard Extension (in addition to RV32F)**

  1100000   00010   rs1   rm   rd   1010011   R fcvt.l.s
  --------- ------- ----- ---- ---- --------- -------------
  1100000   00011   rs1   rm   rd   1010011   R fcvt.lu.s
  1101000   00010   rs1   rm   rd   1010011   R fcvt.s.l
  1101000   00011   rs1   rm   rd   1010011   R fcvt.s.lu

**RV64D Satndard Extension (in addition to RV32D)**

  1100001   00010   rs1   rm    rd   1010011   R fcvt.l.d
  --------- ------- ----- ----- ---- --------- -------------
  1100001   00011   rs1   rm    rd   1010011   R fcvt.lu.d
  1110001   00000   rs1   000   rd   1010011   R fmv.x.d
  1101001   00010   rs1   rm    rd   1010011   R fcvt.d.l
  1101001   00011   rs1   rm    rd   1010011   R fcvt.d.lu
  1111001   00000   rs1   000   rd   1010011   R fmv.d.x

**图9.5：RV64基本指令和可选扩展指令的的操作码表。这张图包含了指令布局，操作码，格式类型和名称(基于\[Waterman
and Asanovic 2017\]的表19.2）。**

RV64F和RV64D添加了整数双字转换指令，并称它们为长整数，以避免与双精度浮点数据混淆：fcvt.l.s，fcvt.l.d，fcvt.lu.s，fcvt.lu.d，fcvt.s.l，fcvt.s.lu，fcvt.d.l，fcvt.d.lu.由于整数x寄存器现在是64位宽，它们现在可以保存双精度浮点数据，因此RV64D增加了两个浮点指令：fmv.x.w和fmv.w.x.

RV64和RV32之间基本是超集关系，但是有一个例外是压缩指令。
RV64C取代了一些RV32C指令，因为其他一些指令对于64位地址可以取得更好的代码压缩效果。RV64C放弃了压缩跳转并链接（c.jal）和整数和浮点加载和存储字指令（c.lw，c.sw，c.lwsp，c.swsp，

c.flw，c.fsw，c.flwsp和c.fswsp）。在他们的位置，RV64C添加了更受欢迎的字加减指令（c.addw，c.addiw，c.subw）以及加载和存储双字指令（c.ld，c.sd，c.ldsp，c.sdsp）。

9.2使用插入排序来比较RV64与其他64位ISA
--------------------------------------

正如Gordon
Bell在本章开头所说，一个架构致命的缺陷是用光了地址位。随着程序使用的内存大小逐渐逼近32位地址空间的极限，不同指令集的架构师开始了设计他们指令集的64位地址版本\[Mashey
2009\]。

最早的是MIPS，在1991年，它将所有寄存器以及程序计数器从32扩展至64位并添加了新的64位版本的MIPS-32指令。
MIPS-64汇编语言指令都以字母"d"开头，例如daddu或dsll（参见图9.10）。程序员可以在同一个程序中混合使用MIPS-32和MIPS-64指令。

MIPS-64删除了MIPS-32中的加载延迟槽（流水线在侦测到写后读相关时会停止）。

十年之后，是x86-32指令集也迎来了64位。架构师们在拓展地址空间的同时，也借机在x86-64中进行了一系列改进：

-   整数寄存器的数量从8增加到16（r8-r15）;

-   将SIMD寄存器的数量从8增加到16（xmm8-xmm15）并且添加了PC相关数据寻址，以更好地支持与位置无关的代码。

-   添加了PC相关数据寻址，以更好地支持与位置无关的代码。

这些改进部分缓和了x86-32指令集长久以来的一些弊端。

通过比较插入排序的x86-32版本（第2章第30页上图2.11中）和x86-64版本（图9.11中）的指令，我们可以发现x86-64指令集的优势。新的64位ISA将所有变量分配在寄存器中，而不是像x86-32一样，要将多个变量保存到内存中，这将指令的数量从20条减少到了15条。尽管64位代码指令数量比32位少，但是代码大小实际上要大一个字节，从45变成了46字节。原因是为了挤进新的操作码以便操作更多的寄存器，x86-64添加了一个前缀字

![](media/image92.PNG){width="5.772222222222222in"
height="0.7506944444444444in"}**图9.6：四个ISA的插入排序的指令数和代码大小。
ARM Thumb-2和microMIPS是32位地址ISA，因此不适用于ARM-64和MIPS-64。**

节来识别新指令。从x86-32到x86-64平均指令长度增长了。

又过了十年，ARM也遇到了同样的地址问题。但是他们没有像x86-64那样，把旧的ISA扩展到支持64位地址。他们利用这个机会发明了一个全新的ISA。从头设计一个新ISA，使得他们不必继承ARM-32的许多尴尬特性，他们重新设计了一个现代ISA：

-   将整数寄存器的数量从15增加到31;

-   从寄存器组中删除PC;

-   为大多数指令提供硬连线到零的寄存器（r31）;

-   与ARM-32不同，ARM-64的所有数据寻址模式都适用于所有数据大小和类型;

-   ARM-64去除了ARM-32的加载存储多个数据的指令

-   ARM-64去除了ARM-32指令的条件执行选项。

ARM-32的一些弱点依然存在于ARM-64指令集中：分支指令使用的条件码，指令中源和目标寄存器字段并不固定，条件移动指令，复杂寻址模式，不一致的性能计数器，以及只支持32位长度的指令。另外ARM-64无法切换到Thumb-2
ISA，因为Thumb-2仅适用于32位地址。

与RISC-V不同，ARM决定采用最大主义的方法来设计ISA。虽然ISA比ARM-32更好，但它也更大。例如，它有超过1000条指令并且ARM-64手册长3185页\[ARM
2015\]。而且，它的指令数仍然在增长。自公布几年以来，ARM-64已经经历了三次扩展。

图9.9中插入排序的ARM-64代码看起来更接近RV64I代码或x86-64代码，而不太像ARM-32代码。例如，因为有31个寄存器可用，就没有必要从堆栈中保存和恢复寄存器。而且由于PC不再存放于通用寄存器中，ARM-64单独增加了一条返回指令。

图9.6总结了插入排序在不同ISA下的指令数和字节数。图9.8到9.11显示了RV64I，ARM-64，MIPS-64和x86-64的代码。这四段代码注释中括号内的短语阐明了第2章中的RV32I版本与这些RV64I版本之间的差异。

MIPS-64用到了最多的指令，主要是因为它需要使用nop指令来填充无法有效利用起来的分支延迟槽。由于比较和分支用一条指令完成，而且分支指令没有延迟槽，RV64I需要的指令更少。虽然相较于RV64I，对于每个分支，ARM-64和x86-64需要多使用两条指令，但它们的缩放寻址模式避免了RV64I中所需的地址算术指令，可以让它们少使用一些指令。但是总的而言，RV64I
+ RV64C代码大小要小得多，具体原因会在下一节阐述。

![](media/image93.PNG){width="5.772222222222222in"
height="3.317361111111111in"}

**图9.7：RV64G，ARM-64和x86-64与RV64GC的相对程序大小比较。我们使用了比图9.6中更大的程序来进行对比。该图第2章中第9页的图1.5中的32位ISA比较的对应的64位ISA比较
.RV32C代码大小与RV64C几乎一致;仅比RV64C小1％。
ARM-64没有Thumb-2选项，因此其他64位ISA的代码大小明显大于RV64GC代码。测量的程序是SPEC
CPU2006基准测试，使用的GCC编译器\[Waterman 2016\]。**

9.3程序大小
-----------

图9.7比较了RV64，ARM-64和x86-64的平均相对代码大小。将这个图见第1章第9页的图1.5比较。首先，RV32GC代码的大小与RV64GC几乎相同;它只比RV64GC小1％。
RV32I和RV64I的代码大小也很接近。而ARM-64代码比ARM-32代码小8％，由于没有64位地址版本的Thumb-2，所以所有指令都保持32位长。因此，ARM-64代码比ARMThumb-2代码大25％。由于添加了前缀操作码以装下新的指令以及扩展的寄存器，x86-64的代码比x86-32代码大7％。因此，就程序大小而言，RV64GC更优秀，因为ARM-64代码比RV64GC大23％，x86-64代码比RV64GC大34％。程序大小的差异如此得大，以至于RV64可以较低的指令高速缓存缺失率来提供更高的性能，或者可以使用更小的指令缓存来降低成本，但依然能提供令人满意的缺失率。

9.4结束语
---------

成为先驱者的一个问题是你总是犯错误，而我永远不会想成为先驱者。最好是在看到先驱者所犯的错误后，赶紧来做这件事情，成为第二个做这件事情的人。

------Seymour Cray，第一台超级计算机的架构师，1976年

耗尽地址位是计算机体系结构的致命弱点，许多架构因为这个缺点而消亡。
ARM-32和Thumb-2仍然是32位架构，所以他们对大型程序没有帮助。像MIPS-64和x86-64这样的一些ISA在转型中幸存下来，但x86-64并不是ISA设计的典范，而写这篇文章的时候，MIPS-64的前路依然迷茫。ARM-64是一个新的大型ISA，时间会告诉我们它会有多成功。

RISC-V受益于同时设计32位和64位架构，而较老的ISA必须依次设计它们。不出所料，对于RISC-V程序员和编译器编写者来说，32位到64位之间的过渡是最简单的;
RV64I
ISA几乎包含了所有RV32I指令。这也就是为什么我们只用两页参考卡片，就可以列出RV32GCV和RV64GCV指令集。更重要的是，同步设计意味着64位架构指令集不必被狭窄的32位操作码空间限制。
RV64I有足够的空间用于可选的指令扩展，特别是RV64C，这使它成为代码大小比其他所有64位ISA都要小。

我们认为64位架构更能体现RISC-V设计上的优越性，毕竟我们设计64位ISA比先行者们晚了20年，这样我们可以可以学习先行者们的好的设计并从他们的错误中吸取教训。

9.5 扩展阅读
------------

> I. ARM. Armv8-a architecture reference manual. 2015.
>
> M. Kerner and N. Padgett. A history of modern 64-bit computing.
> Technical report, CS Department,University of Washington, Feb 2007.
> URL http://courses.cs.washington.edu/cou
>
> rses/csep590/06au/projects/history-64-bit.pdf.
>
> J. Mashey. The long road to 64 bits. *Communications of the ACM*,
> 52(1):45--53, 2009.
>
> A.Waterman. *Design of the RISC-V Instruction Set Architecture*. PhD
> thesis, EECS Department,
>
> University of California, Berkeley, Jan 2016. URL
> http://www2.eecs.berkeley.edu/Pubs
>
> /TechRpts/2016/EECS-2016-1.html.
>
> A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
> Manual, Volume I:*
>
> *User-Level ISA, Version 2.2*. May 2017. URL
> https://riscv.org/specifications/.
>
> J. Woodruff, R. N. Watson, D. Chisnall, S. W. Moore, J. Anderson, B.
> Davis, B. Laurie, P. G. Neumann, R. Norton, and M. Roe. The CHERI
> capability model: Revisiting RISC in an age of risk. In *Computer
> Architecture (ISCA), 2014 ACM/IEEE 41st International Symposium on*,
> pages 457--468. IEEE, 2014.

![](media/image94.PNG){width="5.772222222222222in" height="4.64375in"}

**图9.8：图2.5中插入排序的RV64I代码。
RV64I汇编语言程序与第2章中第27页的图2.8中的RV32I汇编语言程序类似。我们在注释中的括号内列出了差异。数据的大小现在是8个字节而不是4个，所以三条指令中的常数从4变到了8.由于数据宽度的变化，两个加载字（lw）相应变成了加载双字（ld）和两个存储字（sw）相应变成了存储双字（sd）。**

**\
**

![](media/image95.PNG){width="5.772222222222222in"
height="3.9652777777777777in"}

**图9.9：图2.5所示的插入排序的ARM-64代码。
ARM-64汇编语言程序是第2章中第30页图2.11中的ARM-32汇编语言不同，它是一套全新的指令系统。寄存器以x开始而不是以a开头。数据寻址模式支持将寄存器移位3位用于将索引缩放为字节地址。使用31个寄存器，所以无需保存和恢复寄存器堆栈。由于PC不是寄存器之一，因此它使用了单独的返回指令。事实上，代码看起来更接近RV64I代码或x86-64代码而不是ARM-32代码。**

**\
**

![](media/image96.PNG){width="5.772222222222222in"
height="4.768055555555556in"}

**图9.10：图2.5中所示的插入排序的MIPS-64代码。MIPS-64汇编语言程序与第2章第29页图2.10中的MIPS-32汇编语言有一些不同之处。首先，对于64位数据的大多数操作都在其名称前加上"d"：daddiu，daddu，dsll。如图9.8，由于数据大小从4字节增加到8字节，因此有三条指令将常量从4更改为8。再次与RV64I类似，增加的数据宽度，使得两个加载字（lw）变成了加载双字（ld），两个存储字（sw）变成了存储双字（sd）。最后，MIPS-64没有了MIPS-32中的加载延迟槽;当出现写后读依赖时，流水线会阻塞。**

**\
**

![](media/image97.PNG){width="5.772222222222222in"
height="3.473611111111111in"}

**图9.11：图2.5中插入排序的x86-64代码。
x86-64汇编语言程序与第2章中第30页图2.11中的x86-32汇编语言非常不同。首先，与RV64I不同，较宽的寄存器有不同的名称rax，rcx，rdx，rsi，rdi，r8。第二，因为x86-64增加了8个寄存器，现在可以将所有变量保存在寄存器而不是内存中。第三，x86-64指令比x86-32更长，因为许多指令需要预先添加8位或16位前缀码，才能使得操作码空间中放得下这些新指令。例如，递增或递减寄存器（inc，dec）在x86-32中只需要1字节，但x86-64中需要3个字节。因此，对于Insertion
Sort，虽然x86-64指令数比x86-32少，但代码大小为几乎与x86-32相同：45个字节对46个字节。**

第十章 RV32/64特权架构
======================

![](media/image98.emf){width="1.2497692475940507in" height="2.1in"}

简洁性是可靠性的前提。------Edsger W. Dijkstra

10.1 导言
---------

到目前为止，本书主要关注RISC-V对通用计算的支持：我们引入的所有指令都在用户模式（应用程序的代码在此模式下运行）下可用。本章介绍两种新的权限模式：运行最可信的代码的机器模式（machine
mode），以及为Linux，FreeBSD和Windows等操作系统提供支持的监管者模式（supervisor
mode）。这两种新模式都比用和模式有着更高的权限，这也是本章标题的来源。有更多权限的模式通常可以使用权限较低的模式的所用功能，并且它们还有一些低权限模式下不可用的额外功能，例如处理中断和执行I/O的功能。处理器通常大部分时间都运行在权限最低的模式下，处理中断和异常时会将控制权移交到更高权限的模式。

嵌入式系统运行时（runtime）和操作系统用这些新模式的功能来响应外部事件，如网络数据包的到达；支持多任务处理和任务间保护；抽象和虚拟化硬件功能等。鉴于这些主题的广度，为此而编撰的全面的程序员指南会是另外一本完整的书。但我们的这一章节旨在强调RISC-V这部分功能的亮点。对嵌入式系统运行时和操作系统不感兴趣的程序员可以跳过或略读本章。

![](media/image15.png){width="0.7in" height="0.6034722222222222in"}
图10.1是RISC-V特权指令的图形表示，图10.2列出了这些指令的操作码。显然，特权架构添加的指令非常少。作为替代，几个新的控制状态寄存器（CSR）显示了附加的功能。

![](media/image99.PNG){width="5.768055555555556in"
height="0.9006944444444445in"}
本章将RV32和RV64特权架构一并介绍。一些概念仅在整数寄存器的大小上有所不同，因此为了描述简洁，我们引入术语XLEN来指代整数寄存器的宽度（以位为单位）。对于RV32，XLEN为32；对RV64，XLEN则是64。

![](media/image100.PNG){width="4.01875in"
height="1.4375in"}**图10.1：RISC-V特权指令的指令图示。**

**图10.2：RISC-V特权指令的指令布局、操作码、指令类型和名称。（来自\[Waterman
and Asanovic 2017\]中的表6.1。）**

**\
**

10.2 简单嵌入式系统的机器模式
-----------------------------

机器模式（缩写为M模式，M-mode）是RISC-V中*hart*（hardware
thread，硬件线程）可以执行的最高权限模式。在M模式下运行的hart对内存，I/O和一些对于启动和配置系统来说必要的底层功能有着完全的使用权。因此它是唯一所有标准RISC-V处理器都必须实现的权限模式。实际上简单的RISC-V微控制器仅支持M模式。这类系统是本节的重点。

![](media/image17.png){width="0.7763888888888889in"
height="0.6409722222222223in"}
机器模式最重要的特性是拦截和处理异常（不寻常的运行时事件）的能力。RISC-V将异常分为两类。一类是同步异常，这类异常在指令执行期间产生，如访问了无效的存储器地址或执行了具有无效操作码的指令时。另一类是中断，它是与指令流异步的外部事件，比如鼠标的单击。RISC-V中实现精确例外：保证异常之前的所有指令都完整地执行了，而后续的指令都没有开始执行（或等同于没有执行）。图10.3列出了触发标准例外的原因。

在M模式运行期间可能发生的同步例外有五种：

-   访问错误异常
    当物理内存的地址不支持访问类型时发生（例如尝试写入ROM）。

-   断点异常 在执行ebreak指令，或者地址或数据与调试触发器匹配时发生。

-   环境调用异常 在执行ecall指令时发生。

-   非法指令异常 在译码阶段发现无效操作码时发生。

-   非对齐地址异常
    在有效地址不能被访问大小整除时发生，例如地址为0x12的amoadd.w。

![](media/image101.PNG){width="4.936111111111111in"
height="4.090277777777778in"}

**图10.3：RISC-V异常和中断的原因。中断时**mcause**的最高有效位置1，同步异常时置0，且低有效位标识了中断或异常的具体原因。只有在实现了监管者模式时才能处理监管者模式中断和页面错误异常（参见第10.5节）。（来自\[Waterman
and Asanovic 2017\]中的表3.6。）**

![](media/image17.png){width="0.7763888888888889in"
height="0.6409722222222223in"}如果你还记得第二章声明允许非对齐的load和store，你可能会问为什么图10.3中还会有非对齐的load和store地址异常。原因有两个，首先，第六章的原子内存操作需要自然对齐的地址；其次，一些实现者选择省略对于非对齐的常规load和store的硬件支持，因为它是一个难以实现的不常用特性。没有这种硬件的处理器依赖于异常处理程序，用一系列较小的对齐load和store来模拟软件中非对齐的load和store。应用程序代码并没有变得更好：虽然速度很慢，非对齐访存操作仍按预期进行，而硬件仍然很简单。或者，在更高性能的处理器中可以硬件实现非对齐的load和store。这种实现上的灵活性归功于RISC-V允许非对齐load和store与常规load和store共用操作码。这遵照了第一章将架构和具体实现隔离开的准则。

有三种标准的中断源：软件、时钟和外部来源。软件中断通过向内存映射寄存器中存数来触发，并通常用于由一个hart中断另一个hart（在其他架构中称为处理器间中断机制）。当hart的时间比较器（一个名为mtimecmp的内存映射寄存器）大于实时计数器mtime时，会触发时钟中断。外部中断由平台级中断控制器（大多数外部设备连接到这个中断控制器）引发。不同的硬件平台具有不同的内存映射并且需要中断控制器的不同特性，因此用于发出和消除这些中断的机制因平台而异。所有RISC-V系统的共同问题是如何处理异常和屏蔽中断，这是下一节的主题。

10.3 机器模式下的异常处理
-------------------------

八个控制状态寄存器（CSR）是机器模式下异常处理的必要部分：

-   mtvec（Machine Trap Vector）它保存发生异常时处理器需要跳转到的地址。

-   mepc（Machine Exception PC）它指向发生异常的指令。

-   mcause（Machine Exception Cause）它指示发生异常的种类。

-   mie（Machine Interrupt
    Enable）它指出处理器目前能处理和必须忽略的中断。

-   mip（Machine Interrupt Pending）它列出目前正准备处理的中断。

-   mtval（Machine Trap
    Value）它保存了陷入（trap）的附加信息：地址例外中出错的地址、发生非法指令例外的指令本身，对于其他异常，它的值为0。

-   mscratch（Machine Scratch）它暂时存放一个字大小的数据。

-   ![](media/image102.PNG){width="5.527777777777778in"
    height="1.4118055555555555in"}mstatus（Machine
    Status）它保存全局中断使能，以及许多其他的状态，如图10.4所示。

**图10.4：**mstatus**控制状态寄存器。在仅有机器模式且没有F和V扩展的简单处理中，有效的域只有全局中断使能、MIE和MPIE（它在异常发生后保存MIE的旧值）。RV32的XLEN时32，RV64是40。（来自\[Waterman
and Asanovic
2017\]中的表3.6；有关其他域的说明请参见该文档的第3.1节。）**

处理器在M模式下运行时，只有在全局中断使能位mstatus.MIE置1时才会产生中断.此外，每个中断在控制状态寄存器mie中都有自己的使能位。这些位在mie中的位置对应于图10.3中的中断代码。例如，mie\[7\]对应于M模式中的时钟中断。控制状态寄存器mip

**图10.5：RISC-V的权限模式和它们的编码**![](media/image103.PNG){width="3.5368055555555555in"
height="1.101388888888889in"}

具有相同的布局，并且它指示当前待处理的中断。将所有三个控制状态寄存器合在一起考虑，如果mstatus.MIE
= 1，mie\[7\] = 1，且mip\[7\] = 1，则可以处理机器的时钟中断。

当一个hart发生异常时，硬件自动经历如下的状态转换：

-   异常指令的PC被保存在mepc中，PC被设置为mtvec。（对于同步异常，mepc指向导致异常的指令；对于中断，它指向中断处理后应该恢复执行的位置。）

-   根据异常来源设置mcause（如图10.3所示），并将mtval设置为出错的地址或者其它适用于特定异常的信息字。

-   把控制状态寄存器mstatus中的MIE位置零以禁用中断，并把先前的MIE值保留到MPIE中。

-   发生异常之前的权限模式保留在mstatus的MPP域中，再把权限模式更改为M。图10.5显示了MPP域的编码（如果处理器仅实现M模式，则有效地跳过这个步骤）。

> 为避免覆盖整数寄存器中的内容，中断处理程序先在最开始用mscratch和整数寄存器（例如a0）中的值交换。通常，软件会让mscratch包含指向附加临时内存空间的指针，处理程序用该指针来保存其主体中将会用到的整数寄存器。在主体执行之后，中断程序会恢复它保存到内存中的寄存器，然后再次使用mscratch和a0交换，将两个寄存器恢复到它们在发生异常之前的值。最后，处理程序用mret指令（M模式特有的指令）返回。mret将PC设置为mepc，通过将mstatus的MPIE域复制到MIE来恢复之前的中断使能设置，并将权限模式设置为mstatus的MPP域中的值。这基本是前一段中描述的逆操作。
>
> 图10.6展示了遵循此模式的基本时钟中断处理程序的RISC-V汇编代码。它只对时间比较器执行了递增操作，然后继续执行之前的任务。更实际的时钟中断处理程序可能会调用调度程序，从而在任务之间切换。它是非抢占的，因此在处理程序的过程中中断会被禁用。不考虑这些限制条件的话，它就是一个只有一页的RISC-V中断处理程序的完整示例！
>
> ![](media/image15.png){width="0.7in"
> height="0.6034722222222222in"}有时需要在处理异常的过程中转到处理更高优先级的中断。唉，mepc，mcause，mtval和mstatus这些控制寄存器只有一个副本，处理第二个中断的时候如果软件不进行一些帮助的话，这些寄存器中的旧值会被破坏，导致数据丢失。可抢占的中断处理程序可以在启用中断之前把这些寄存器保存到内存中的栈，然后在退出之前，禁用中断并从栈中恢复寄存器。
>
> ![](media/image16.png){width="0.6666666666666666in"
> height="0.3770833333333333in"}除了上面介绍的mret指令之外，M模式还提供了另外一条指令：wfi（Wait
> For
> Interrupt）。wfi通知处理器目前没有任何有用的工作，所有它应该进入低功耗模式，直到任何使能有效的中断等待处理，即$\text{mie}\& mip \neq 0$。RISC-V处理器以多种方式实现该指令，包括到中断待处理之前都停止时钟。有的时候只把这条指令当作nop来执行。因此，wfi通常在循环内使用。

![](media/image104.PNG){width="5.768055555555556in"
height="6.523611111111111in"}

**图10.6；简单的RISC-V时钟中断处理程序代码。代码中假定了全局中断已通过置位**mstatus**.MIE启用；时钟中断已通过置位**mie\[7\]**启用；**mtvec
**CSR已设置为此处理程序的入口地址；而且**mscratch
**CSR已经设置为有16个字节用于保存寄存器的临时空间的地址。第一部分保存了五个寄存器，把**a0**保存在**mscratch**中，**a1**到**a4**保存在内存中。然后它检查**mcause**来读取异常的类别：如果**mcause**\<0则是中断，反之则是同步异常。如果是中断，就检查**mcause**的低位是否等于7，如果是，就是M模式的时钟中断。如果确定是时钟中断，就给时间比较器加上1000个时钟周期，于是下一个时钟中断会发生在大约1000个时钟周期之后。最后一段恢复了**a0**到**a4**和**mscratch**，然后用**mret**指令返回。**

**\
**

![](media/image105.PNG){width="5.768055555555556in"
height="1.2180555555555554in"}

![](media/image106.PNG){width="5.768055555555556in"
height="3.1118055555555557in"}**图10.7：PMP地址和配置寄存器。地址寄存器右移两位，如果物理地址位宽小于XLEN-2，则高位为0。R、W和X域分别对应读、写和执行权限。A域设置是否启用此PMP，L域锁定了PMP和对应的地址寄存器。**

**图10.8：**pmpcfg
**CSR中PMP配置的布局。对于RV32（上半部分），16个配置寄存器被分配到4个CSR中。对于RV64（下半部分），它们则分配到了两个偶数编号的CSR中。**

10.4 嵌入式系统中的用户模式和进程隔离
-------------------------------------

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}
虽然机器模式对于简单的嵌入式系统已经足够，但它仅适用于那些整个代码库都可信的情况，因为M模式可以自由地访问硬件平台。更常见的情况是，不能信任所有的应用程序代码，因为不能事先得知这一点，或者它太大，难以证明正确性。因此，RISC-V提供了保护系统免受不可信的代码危害的机制，并且为不受信任的进程提供隔离保护。

必须禁止不可信的代码执行特权指令（如mret）和访问特权控制状态寄存器（如mstatus），因为这将允许程序控制系统。这样的限制很容易实现，只要加入一种额外的权限模式：用户模式（U模式）。这种模式拒绝使用这些功能，并在尝试执行M模式指令或访问CSR的时候产生非法指令异常。其它时候，U模式和M模式的表现十分相似。通过将mstatus.MPP设置为U（如图10.5所示，编码为0），然后执行mret指令，软件可以从M模式进入U模式。如果在U模式下发生异常，则把控制移交给M模式。

这些不可信的代码还必须被限制只能访问自己那部分内存。实现了M和U模式的处理器具有一个叫做物理内存保护（PMP，Physical
Memory
Protection）的功能，允许M模式指定U模式可以访问的内存地址。PMP包括几个地址寄存器（通常为8到16个）和相应的配置寄存器。这些配置寄存器可以授予或拒绝读、写和执行权限。当处于U模式的处理器尝试取指或执行load或store操作时，将地址和所有的PMP地址寄存器比较。如果地址大于等于PMP地址i，但小于PMP地址i+1，则PMP
i+1的配置寄存器决定该访问是否可以继续，如果不能将会引发访问异常。

图10.7显示了PMP地址寄存器和配置寄存器的布局。两者都是CSR，地址寄存器名为pmpaddr0到pmpaddrN，其中N+1是实现的PMP个数。地址寄存器右移两位，因为PMP以四字节为单位。配置寄存器密集地填充在CSR中以加速上下文切换，如图10.8所示。PMP的配置由R、W和X位组成，他们分别对于load，store和fetch操作，还有另一个域A，当它为0时禁用此PMP，当它为1时启用。PMP配置还支持其他模式，还可以加锁，\[Waterman
and Asanovic 2017\]中描述了这些功能。

10.5 现代操作系统的监管者模式
-----------------------------

上一节中描述的PMP方案对嵌入式系统的实现很有吸引力，因为它以相对较低的成本提供了内存保护，但它的一些缺点限制了它在通用计算中的使用。由于PMP仅支持固定数量的内存区域，因此无法对它进行扩展从而适应复杂的应用程序。而且由于这些区域必须在物理存储中连续，因此系统可能产生存储碎片化的问题。另外，PMP不能有效地支持对辅存的分页。

更复杂的RISC-V处理器用和几乎所有通用架构相同的方式处理这些问题：使用基于页面的虚拟内存。这个功能构成了监管者模式（S模式）的核心，这是一种可选的权限模式，旨在支持现代类Unix操作系统，如Linux，FreeBSD和Windows。S模式比U模式权限更高，但比M模式低。与U模式一样，S模式下运行的软件不能使用M模式的CSR和指令，并且受到PMP的限制。本届介绍S模式的中断和异常，下一节将详细介绍S模式下的虚拟内存系统。

默认情况下，发生所有异常（不论在什么权限模式下）的时候，控制权都会被移交到M模式的异常处理程序。但是Unix系统中的大多数例外都应该进行S模式下的系统调用。M模式的异常处理程序可以将异常重新导向S模式，但这些额外的操作会减慢大多数异常的处理速度。因此，RISC-V提供了一种异常委托机制。通过该机制可以选择性地将中断和同步异常交给S模式处理，而完全绕过M模式。

mideleg（Machine Interrupt
Delegation，机器中断委托）CSR控制将哪些中断委托给S模式。与mip和mie一样，mideleg中的每个位对应于图10.3中相同的异常。例如，mideleg\[5\]对应于S模式的时钟中断，如果把它置位，S模式的时钟中断将会移交S模式的异常处理程序，而不是M模式的异常处理程序。

委托给S模式的任何中断都可以被S模式的软件屏蔽。sie（Supervisor Interrupt

**图10.9：**sstatus![](media/image107.PNG){width="5.120370734908136in"
height="1.6317869641294838in"}
**CSR。**sstatus**是**mstatus**（图10.4）的一个子集，因此它们的布局类似。SIE和SPIE中分别保存了当前的和异常发生之前的中断使能，类似于**mstatus**中的MIE和MPIE。RV32的XLEN为32，RV64为40。（来自\[Waterman
and Asanovic
2017\]中的图4.2；有关其他域的说明请参见该文档的第4.1节。）**

Enable，监管者中断使能）和sip（Supervisor Interrupt
Pending，监管者中断待处理）CSR是S模式的控制状态寄存器，他们是mie和mip的子集。它们有着和M模式下相同的布局，但在sie和sip中只有与由mideleg委托的中断对应的位才能读写。那些没有被委派的中断对应的位始终为零。

M模式还可以通过medeleg
CSR将同步异常委托给S模式。该机制类似于刚才提到的中断委托，但medeleg中的位对应的不再是中断，而是图10.3中的同步异常编码。例如，置上medeleg\[15\]便会把store
page fault（store过程中出现的缺页）委托给S模式。

请注意，无论委派设置是怎样的，发生异常时控制权都不会移交给权限更低的模式。在M模式下发生的异常总是在M模式下处理。在S模式下发生的异常，根据具体的委派设置，可能由M模式或S模式处理，但永远不会由U模式处理。

![](media/image15.png){width="0.7in" height="0.6034722222222222in"}
S模式有几个异常处理CSR：sepc、stvec、scause、sscratch、stval和sstatus，它们执行与10.2中描述的M模式CSR相同的功能。图10.9显示了sstatus寄存器的布局。监管者异常返回指令sret与mret的行为相同，但它作用于S模式的异常处理CSR，而不是M模式的CSR。

S模式处理例外的行为已和M模式非常相似。如果hart接受了异常并且把它委派给了S模式，则硬件会原子地经历几个类似的状态转换，其中用到了S模式而不是M模式的CSR：

-   发生例外的指令的PC被存入sepc，且PC被设置为stvec。

-   scause按图10.3根据异常类型设置，stval被设置成出错的地址或者其它特定异常的信息字。

-   把sstatus CSR中的SIE置零，屏蔽中断，且SIE之前的值被保存在SPIE中。

-   发生例外时的权限模式被保存在sstatus的SPP域，然后设置当前模式为S模式。

10.6 基于页面的虚拟内存
-----------------------

S模式提供了一种传统的虚拟内存系统，它将内存划分为固定大小的页来进行地址转换和对内存内容的保护。启用分页的时候，大多数地址（包括load和store的有效地址和PC中的地址）都是虚拟地址。要访问物理内存，它们必须被转换为真正的物理地址，这通过遍历一种称为页表的高基数树实现。页表中的叶节点指示虚地址是否已经被映射到了真正的物理页面，如果是，则指示了哪些权限模式和通过哪种类型的访问可以操作这个页。

![](media/image108.PNG){width="4.009027777777778in"
height="0.6090277777777777in"}**图10.10：一个RV32 Sv32页表项（PTE）。**

**图10.11：一个RV64**![](media/image109.PNG){width="5.768055555555556in"
height="0.6118055555555556in"} **Sv39页表项（PTE）。**

访问未被映射的页或访问权限不足会导致页错误例外（page fault exception）。

RISC-V的分页方案以SvX的模式命名,其中X是以位为单位的虚拟地址的长度。RV32的分页方案Sv32支持4GiB的虚址空间，这些空间被划分为2^10^个4
MiB大小的巨页。每个巨页被进一步划分为2^10^个4
KiB大小的基页（分页的基本单位）。因此，Sv32的页表是基数为2^10^的两级树结构。页表中每个项的大小是四个字节，因此页表本身的大小是4
KiB。页表的大小和每个页的大小完全相同，这样的设计简化了操作系统的内存分配。

图10.10显示了Sv32页表项（page-table
entry，PTE）的布局，从左到右分别包含如下所述的域：

-   V位决定了该页表项的其余部分是否有效（V = 1时有效）。若V =
    0，则任何遍历到此页表项的虚址转换操作都会导致页错误。

-   R、W和X位分别表示此页是否可以读取、写入和执行。如果这三个位都是0，那么这个页表项是指向下一级页表的指针，否则它是页表树的一个叶节点。

-   U位表示该页是否是用户页面。若U =
    0，则U模式不能访问此页面，但S模式可以。若U =
    1，则U模式下能访问这个页面，而S模式不能。

-   G位表示这个映射是否对所有虚址空间有效，硬件可以用这个信息来提高地址转换的性能。这一位通常只用于属于操作系统的页面。

-   A位表示自从上次A位被清除以来，该页面是否被访问过。

-   D位表示自从上次清除D位以来页面是否被弄脏（例如被写入）。

-   RSW域留给操作系统使用，它会被硬件忽略。

-   PPN域包含物理页号，这是物理地址的一部分。若这个页表项是一个叶节点，那么PPN是转换后物理地址的一部分。否则PPN给出下一节页表的地址。（图10.10将PPN划分为两个子域，以简化地址转换算法的描述。）

RV64支持多种分页方案，但我们只介绍最受欢迎的一种，Sv39。Sv39使用和Sv32相同的4
KiB大的基页。页表项的大小变成8个字节，所以它们可以容纳更大的物理地址。为了保证页表大小和页面大小一致，树的基数相应地降到2^9^，树也变为三层。Sv39的512
GiB地址空间划分为2^9^个1
GiB大小的吉页。每个吉页被进一步划分为2^9^个巨页。在Sv39中这些巨页大小为2
MiB，比Sv32中略小。每个巨页再进一步分为2^9^个4 KiB大小的基页。

图10.11显示了Sv39页表项的布局。它和Sv32完全相同，只是PPN字段被扩展到了44位，以支持56位的物理地址，或者说2^26^
GiB大小的物理地址空间。

**图10.12：**satp![](media/image110.PNG){width="5.768055555555556in"
height="1.2458333333333333in"} **CSR。来自\[Waterman and Asanovic
2017\]中的图4.11和4.12。**

![](media/image111.PNG){width="4.242034120734908in"
height="2.100181539807524in"}

**图10.13：**satp **CSR中MODE域的编码。来自\[Waterman and Asanovic
2017\]中的表4.3。**

一个叫satp（Supervisor Address Translation and
Protection，监管者地址转换和保护）的S模式控制状态寄存器控制了分页系统。如图10.12所示，satp有三个域。MODE域可以开启分页并选择页表级数，图10.13展示了它的编码。ASID（Address
Space
Identifier，地址空间标识符）域是可选的，它可以用来降低上下文切换的开销。最后，PPN字段保存了根页表的物理地址，它以4
KiB的页面大小为单位。通常M模式的程序在第一次进入S模式之前会把零写入satp以禁用分页，然后S模式的程序在初始化页表以后会再次进行satp寄存器的写操作。

**图10.14：Sv32中地址转换过程的图示。**![](media/image112.PNG){width="4.765031714785652in"
height="3.8574070428696414in"}

当在satp寄存器中启用了分页时，S模式和U模式中的虚拟地址会以从根部遍历页表的方式转换为物理地址。图10.14描述了这个过程：

1.  satp.PPN给出了一级页表的基址，VA\[31:22\]给出了一级页号，因此处理器会读取位于地址$(satp.PPN \times 4096 + VA\lbrack 31:22\rbrack \times 4)$的页表项。

2.  该PTE包含二级页表的基址，VA\[21:12\]给出了二级页号，因此处理器读取位于地址$(PTE.PPN \times 4096 + VA\lbrack 21:12\rbrack \times 4)$的叶节点页表项。

3.  叶节点页表项的PPN字段和页内偏移（原始虚址的最低12个有效位）组成了最终结果：物理地址就是$(\text{Leaf}PTE.PPN \times 4096 + VA\left\lbrack 11:0 \right\rbrack)$

随后处理器会进行物理内存的访问。Sv39的转换过程几乎和Sv32相同，区别在于其具有较大的PTE和更多级页表。本章末尾的图10.19给出了页表遍历算法的完整描述，详细说明了例外条件和超页面转换的特殊情况。

![](media/image14.png){width="0.6263888888888889in"
height="0.6069444444444444in"}除了一点以外，我们几乎讲完了RISC-V分页系统的所有内容。如果所有取指，load和store操作都导致多次页表访问，那么分页会大大地降低性能！所有现代的处理器都用地址转换缓存（通常称为TLB，全称为Translation
Lookaside
Buffer）来减少这种开销。为了降低这个缓存本身的开销，大多数处理器不会让它时刻与页表保持一致。这意味着如果操作系统修改了页表，那么这个缓存会变得陈旧而不可用。S模式添加了另一条指令来解决这个问题。这条sfence.vma会通知处理器，软件可能已经修改了页表，于是处理器可以相应地刷新转换缓存。它需要两个可选的参数，这样可以缩小缓存刷新的范围。一个位于rs1，它指示了页表哪个虚址对应的转换被修改了；另一个位于rs2，它给出了被修改页表的进程的地址空间标识符（ASID）。如果两者都是x0，便会刷新整个转换缓存。

**\
**

![](media/image113.PNG){width="5.768055555555556in"
height="0.6701388888888888in"}**图10.15：机器中断寄存器。它们是宽为XLEN位的读/写寄存器，用于保存待处理的中断（**mip**）和中断使能位（**mie**）CSR。只有与**mip**中的位对应的低权限软件中断（USIP，SSIP）、时钟中断（UTIP，STIP）和外部中断（UEIP，SEIP）的位才能通过该CSR的地址写入；其余的位是只读的。**

![](media/image114.PNG){width="4.123148512685915in"
height="0.648180227471566in"}

**图10.16：监管者中断寄存器。它们是宽为XLEN位的读/写寄存器，用于保存待处理的中断（**sip**）和中断使能位（sie）CSR。**

![](media/image115.PNG){width="5.768055555555556in"
height="0.5618055555555556in"}

**图10.17：机器和监管者自陷向量（trap-vector）基地址寄存器（**mtvec**和**stvec**）CSR。他们是位宽为XLEN的读/写寄存器，用于保存自陷向量的配置，包括向量基址（BASE）和向量模式（MODE）。BASE域中的值必须按4字节对齐。MODE
= 0表示所有异常都把PC设置为BASE。MODE =
1会在一部中断时将PC设置为**$\mathbf{(}\mathbf{\text{BASE}}\mathbf{+}\left( \mathbf{4 \times}\mathbf{\text{cause}} \right)\mathbf{)}$**。**

![](media/image116.PNG){width="4.75in" height="0.5472222222222223in"}

**图10.18：机器和监管者**cause**（**mcause**和**scause**）CSR。当处理自陷时，CSR中被写入一个指示导致自陷的事件的代码。如果自陷由中断引起，则置上中断位。"异常代码"字段包含指示最后一个异常的代码。\[Waterman
and Asanovic 2017\]中的表3.6中包含自陷的来源到自陷代码的映射。**

10.7 结束语
-----------

研究表明，最优秀的设计师会设计出更快、更小、更简单的结构，而且设计过程也更轻松。伟大的结构和一般的结构之间差了一个数量级。

------Fred Brooks,Jr.,1986

Brooks是图灵奖获得者，还是IBM
System/360系列计算机的架构师（这些计算机说明了将架构和实现区分开来的重要性）。这个1964年诞生的架构的继承者至今仍在销售。

![](media/image15.png){width="0.7in" height="0.6034722222222222in"}

![](media/image16.png){width="0.6666666666666666in"
height="0.3770833333333333in"}
RISC-V特权架构的模块化特性满足了各种系统的需求。十分精简的机器模式以低成本的特征支持裸机嵌入式应用。附加的用户模式和物理内存保护功能共同支持了更复杂的嵌入式系统中的多任务处理。最后，监管者模式和基于页面的虚拟内存提供了运行现代操作系统所必需的灵活性。

10.8 扩展阅读
-------------

A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
Manual Volume II: Privileged Architecture Version 1.10*. May 2017. URL
[[https://riscv.org/specifications/privileged-isa/]{.underline}](https://riscv.org/specifications/privileged-isa/).

**注记**

http://parlab.eecs.berkeley.edu

![](media/image117.PNG){width="5.768055555555556in" height="4.0375in"}

**图10.19：虚址到物理地址转换的完整算法。va是输入的虚拟地址，pa是输出的物理地址。PAGESIZE是常数212。在Sv32中，LEVELS
= 2且PTESIZE = 4；而在Sv39中，LEVELS = 3且PTESIZE = 8。来自\[Waterman
and Asanovic 2017\]中的第4.3.2节。**

第十一章 RISC-V未来的可选扩展
=============================

![](media/image118.png){width="1.2777777777777777in"
height="3.259258530183727in"}

对于复杂性，傻子无视它，实用主义者忍受它，有的人有时能规避它，而天才则解决它。

------Alan Perlis, 1982

以RISC-V为基础，至少可以有8种可选的扩展。

11.1 "B"标准扩展：位操作
------------------------

B扩展提供位操作，包括插入、提取和测试位字段（insert, extract, and test
bit fields），旋转（rotations），漏斗位移（funnel
shifts），位置换和字节置换（bit and byte
permutations），计算前导0和尾随0（count leading and trailing
zeros）和计算置位数（count bits set）等。

11.2 "E"标准扩展：嵌入式
------------------------

为了降低对低端核心的开销，这个扩展少了16个寄存器。正是因为RV32E，被保存寄存器和临时寄存器都是在0-15号和16-31号这两部分之间分开的（图3.2）。

![](media/image13.png){width="0.7833333333333333in" height="0.4388888888888889in"}11.3 "H"特权态架构扩展：支持管理程序（Hypervisor）
------------------------------------------------------------------------------------------------------------------------------------

H特权架构扩展加入了管理程序模式和基于内存页的二级地址翻译机制，提高在同一台计算机上运行多个操作系统的效率。

![](media/image13.png){width="0.7833333333333333in" height="0.4388888888888889in"}11.4 "J"标准扩展：动态翻译语言
----------------------------------------------------------------------------------------------------------------

有许多常用的语言使用了动态翻译，比如Java和Javascript。这些语言的动态检查和垃圾回收可以得到ISA的支持。（J表示即时（Just-In-Time）编译。）

![](media/image16.png){width="0.6666666666666666in" height="0.3770833333333333in"}11.5 "L"标准扩展：十进制浮点
--------------------------------------------------------------------------------------------------------------

L扩展的目的是支持IEEE
754-2008标准规定的十进制浮点算术运算。二进制数的问题在于无法表示出一些常用的十进制小数，如0.1。RV32L使得计算基数可以和输入输出的基数相同。

11.6 "N"标准扩展：用户态中断
----------------------------

N扩展允许用户态程序发生中断和例外后，直接进入用户态的处理程序，不触发外层运![](media/image15.png){width="0.7in"
height="0.6034722222222222in"}行环境响应。用户态中断主要用于支持存在M模式和U模式的安全嵌入式系统（见第10章）。不过，它也能支持类Unix操作系统中的用户态中断。当在Unix环境中使用时，传统![](media/image17.png){width="0.7763888888888889in"
height="0.6409722222222223in"}的信号处理机制依然保留，而用户态中断可以用来做未来的扩展，产生诸如垃圾回收屏障（garbage
collection barriers）、整数溢出（integer
overflow）、浮点陷入（floating-point traps）等用户态事件。

![](media/image13.png){width="0.7833333333333333in" height="0.4388888888888889in"}11.7 "P"标准扩展：封装的单指令多数据（Packed-SIMD）指令
-----------------------------------------------------------------------------------------------------------------------------------------

P扩展细分了现有的寄存器架构，提供更小数据类型上的并行计算。封装的单指令多数据指令代表了一种合理复用现有宽数据通路的设计。不过，如果有额外的资源来进行并行计算，第8章的向量架构通常是更好的选择，设计者更应使用RVV扩展。

11.8 "Q"标准扩展：四精度浮点
----------------------------

Q扩展增加了符合IEEE
754-2008标准的128位的四精度浮点指令。扩展后的浮点寄存器可以存储一个单精度、双精度或者四精度的浮点数。四精度浮点扩展要求RV64IFD。

11.9 结束语
-----------

简化，简化。

------亨利·大卫·梭罗（Henry David Thoreau），19世纪著名作家，1854

![](media/image12.png){width="0.7034722222222223in" height="0.425in"}

![](media/image21.png){width="0.6560247156605424in"
height="0.674248687664042in"}
RISC-V具有开放、标准的扩展方式，可能意味着可以在指令集最终确定之前得到反馈和争论，使得进一步的修改为时未晚。理想情况下，一小部分成员将先把一个提议实现出来，然后再提交通过，而FPGA上让实现的过程变得很容易。通过RISC-V基础委员会提交指令扩展所需工作量比较适中，他们将努力控制ISA变动的速度，至少不会像x86-32那样有太快的变化（见第\[1\]章的图1.2）。另外别忘了，不管有多少扩展被应用了，这一章提到的这些东西都是可选的。

我们希望RISC-V可以在保持简洁和高效的同时适应技术需求的发展。如果RISC-V成功了，它将成为以往增量式ISA上的一次革命性突破。

附录A RISC-V指令列表
====================

![](media/image120.emf){width="1.2497692475940507in"
height="1.7222222222222223in"}

简约是一切真正优雅的要义。------Coco Chanel，1923

本附录列出了RV32/64I的所有指令、本书中涵盖的所有扩展（RVM、RVA、RVF、RVD、RVC和RVV）以及所有伪指令。每个条目都包括指令名称、操作数、寄存器传输级定义、指令格式类型、中文描述、压缩版本（如果存在），以及一张带有操作码的指令布局图。我们认为这些摘要对于您了解所有的指令已经足够，但如果您想了解更多细节，请参阅RISC-V官方规范\[Waterman
and Asanovic 2017\]。

为了帮助读者在本附录中找到所需的指令，左侧（奇数）页面的标题包含该页顶部的第一条指令，右侧（偶数）页面的标题包含该页底部的最后一条指令。格式类似于字典的标题，有助于您搜索单词所在的页面。例如，下一个偶数页的标题是**AMOADD.W**，这是该页的第一条指令；下一个奇数页的标题是**AMOMINU.D**，这是该页的最后一条指令。如下是你能在这两页中找到的指令：amoadd.w、adoand.d、amoadn.w、amomax.d、amomax.w、amomaxu.d、amomaxu.w、amomin.d、amomin.w和amominu.d。

add rd, rs1, rs2 x\[rd\] = x\[rs1\] + x\[rs2\]

加 *(Add)*. R-type, RV32I and RV64I.

把寄存器x\[*rs2*\]加到寄存器x\[*rs1*\]上，结果写入x\[*rd*\]。忽略算术溢出。

压缩形式：**c.add** rd, rs2; **c.mv** rd, rs2

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   000   Rd   0110011
  --------- ----- ----- ----- ---- ---------

addi rd, rs1, immediate x\[rd\] = x\[rs1\] + sext(immediate)

加立即数*(Add Immediate)*. I-type, RV32I and RV64I.

把符号位扩展的立即数加到寄存器x\[*rs1*\]上，结果写入x\[*rd*\]。忽略算术溢出。

压缩形式：**c.li** rd, imm; **c.addi** rd, imm; **c.addi16sp** imm;
**c.addi4spn** rd, imm

  ------------------- ----- ----- ---- ---------
  immediate\[11:0\]   rs1   000   rd   0010011
  ------------------- ----- ----- ---- ---------

addiw rd, rs1, immediate x\[rd\] = sext((x\[rs1\] +
sext(immediate))\[31:0\])

加立即数字*(Add Word Immediate)*. I-type, RV64I.

把符号位扩展的立即数加到x\[*rs1*\]，将结果截断为32位，把符号位扩展的结果写入x\[*rd*\]。忽略算术溢出。

压缩形式：**c.addiw** rd, imm

  ------------------- ----- ----- ---- ---------
  immediate\[11:0\]   rs1   000   rd   0011011
  ------------------- ----- ----- ---- ---------

addw rd, rs1, rs2 x\[rd\] = sext((x\[rs1\] + x\[rs2\])\[31:0\])

加字*(Add Word)*. R-type, RV64I.

把寄存器x\[*rs2*\]加到寄存器x\[*rs1*\]上，将结果截断为32位，把符号位扩展的结果写入x\[*rd*\]。忽略算术溢出。

压缩形式：**c.addw** rd, rs2

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   000   rd   0111011
  --------- ----- ----- ----- ---- ---------

amoadd.d rd, rs2, (rs1) x\[rd\] = AMO64(M\[x\[rs1\]\] + x\[rs2\])

原子加双字*(Atomic Memory Operation: Add Doubleword)*. R-type, RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的双字记为*t*，把这个双字变为*t*+x\[*rs2*\]，把x\[*rd*\]设为*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  00000   aq   rl   rs2   rs1   011   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amoadd.w rd, rs2, (rs1) x\[rd\] = AMO32(M\[x\[rs1\]\] + x\[rs2\])

原子加字*(Atomic Memory Operation: Add Word)*. R-type, RV32A and RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的字记为*t*，把这个字变为*t*+x\[*rs2*\]，把x\[*rd*\]设为符号位扩展的*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  00000   aq   rl   rs2   rs1   010   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amoand.d rd, rs2, (rs1) x\[rd\] = AMO64(M\[x\[rs1\]\] & x\[rs2\])

原子双字与 *(Atomic Memory Operation: AND Doubleword)*. R-type, RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的双字记为*t*，把这个双字变为t和x\[*rs2*\]位与的结果，把x\[*rd*\]设为*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  01100   aq   rl   rs2   rs1   011   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amoand.w rd, rs2, (rs1) x\[rd\] = AMO32(M\[x\[rs1\]\] & x\[rs2\])

原子字与 *(Atomic Memory Operation: AND Word)*. R-type, RV32A and RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的字记为*t*，把这个字变为t和x\[*rs2*\]位与的结果，把x\[*rd*\]设为符号位扩展的*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  01100   aq   rl   rs2   rs1   010   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amomax.d rd, rs2, (rs1) x\[rd\] = AMO64(M\[x\[rs1\]\] MAX x\[rs2\])

原子最大双字*(Atomic Memory Operation: Maximum Doubleword)*. R-type,
RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的双字记为*t*，把这个双字变为t和x\[*rs2*\]中较大的一个（用二进制补码比较），把x\[*rd*\]设为*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  10100   aq   rl   rs2   rs1   011   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amomax.w rd, rs2, (rs1) x\[rd\] = AMO32(M\[x\[rs1\]\] MAX x\[rs2\])

原子最大字*(Atomic Memory Operation: Maximum Word)*. R-type, RV32A and
RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的字记为*t*，把这个字变为t和x\[*rs2*\]中较大的一个（用二进制补码比较），把x\[*rd*\]设为符号位扩展的*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  10100   aq   rl   rs2   rs1   010   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amomaxu.d rd, rs2, (rs1) x\[rd\] = AMO64(M\[x\[rs1\]\] MAXU x\[rs2\])

原子无符号最大双字*(Atomic Memory Operation: Maximum Doubleword,
Unsigned).* R-type, RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的双字记为*t*，把这个双字变为t和x\[*rs2*\]中较大的一个（用无符号比较），把x\[*rd*\]设为*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  11100   aq   rl   rs2   rs1   011   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amomaxu.w rd, rs2, (rs1) x\[rd\] = AMO32(M\[x\[rs1\]\] MAXU x\[rs2\])

原子无符号最大字*(Atomic Memory Operation: Maximum Word, Unsigned).*
R-type, RV32A and RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的字记为*t*，把这个字变为t和x\[*rs2*\]中较大的一个（用无符号比较），把x\[*rd*\]设为符号位扩展的*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  11100   aq   rl   rs2   rs1   010   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amomin.d rd, rs2, (rs1) x\[rd\] = AMO64(M\[x\[rs1\]\] MIN x\[rs2\])

原子最小双字*(Atomic Memory Operation: Minimum Doubleword).* R-type,
RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的双字记为*t*，把这个双字变为t和x\[*rs2*\]中较小的一个（用二进制补码比较），把x\[*rd*\]设为*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  10000   aq   rl   rs2   rs1   011   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amomin.w rd, rs2, (rs1) x\[rd\] = AMO32(M\[x\[rs1\]\] MIN x\[rs2\])

原子最小字*(Atomic Memory Operation: Minimum Word).* R-type, RV32A and
RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的字记为*t*，把这个字变为t和x\[*rs2*\]中较小的一个（用二进制补码比较），把x\[*rd*\]设为符号位扩展的*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  10000   aq   rl   rs2   rs1   010   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amominu.d rd, rs2,(rs1) x\[rd\] = AMO64(M\[x\[rs1\]\] MINU x\[rs2\])

原子无符号最小双字*(Atomic Memory Operation: Minimum Doubleword,
Unsigned).* R-type, RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的双字记为*t*，把这个双字变为t和x\[*rs2*\]中较小的一个（用无符号比较），把x\[*rd*\]设为*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  11000   aq   rl   rs2   rs1   011   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amominu.w rd, rs2, (rs1) x\[rd\] = AMO32(M\[x\[rs1\]\] MINU x\[rs2\])

原子无符号最大字*(Atomic Memory Operation: Minimum Word, Unsigned).*
R-type, RV32A and RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的字记为*t*，把这个字变为t和x\[*rs2*\]中较小的一个（用无符号比较），把x\[*rd*\]设为符号位扩展的*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  11000   aq   rl   rs2   rs1   010   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amoor.d rd, rs2, (rs1) x\[rd\] = AMO64(M\[x\[rs1\]\] \| x\[rs2\])

原子双字或 *(Atomic Memory Operation: OR Doubleword)*. R-type, RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的双字记为*t*，把这个双字变为t和x\[*rs2*\]位或的结果，把x\[*rd*\]设为*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  01000   aq   rl   rs2   rs1   011   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amoor.w rd, rs2, (rs1) x\[rd\] = AMO32(M\[x\[rs1\]\] \| x\[rs2\])

原子字或 *(Atomic Memory Operation: OR Word)*. R-type, RV32A and RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的字记为*t*，把这个字变为t和x\[*rs2*\]位或的结果，把x\[*rd*\]设为符号位扩展的*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  01000   aq   rl   rs2   rs1   010   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amoswap.d rd, rs2, (rs1) x\[rd\] = AMO64(M\[x\[rs1\]\] SWAP x\[rs2\])

原子双字交换 *(Atomic Memory Operation: Swap Doubleword)*. R-type,
RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的双字记为*t*，把这个双字变为x\[*rs2*\]的值，把x\[*rd*\]设为*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  00001   aq   rl   rs2   rs1   011   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amoor.w rd, rs2, (rs1) x\[rd\] = AMO32(M\[x\[rs1\]\] SWAP x\[rs2\])

原子字交换 *(Atomic Memory Operation: Swap Word)*. R-type, RV32A and
RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的字记为*t*，把这个字变为x\[*rs2*\]的值，把x\[*rd*\]设为符号位扩展的*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  00001   aq   rl   rs2   rs1   010   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amoxor.d rd, rs2, (rs1) x\[rd\] = AMO64(M\[x\[rs1\]\] \^ x\[rs2\])

原子双字异或 *(Atomic Memory Operation: XOR Doubleword)*. R-type, RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的双字记为*t*，把这个双字变为t和x\[*rs2*\]按位异或的结果，把x\[*rd*\]设为*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  00100   aq   rl   rs2   rs1   011   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

amoxor.w rd, rs2, (rs1) x\[rd\] = AMO32(M\[x\[rs1\]\] \^ x\[rs2\])

原子字异或 *(Atomic Memory Operation: XOR Word)*. R-type, RV32A and
RV64A.

进行如下的原子操作：将内存中地址为x\[*rs1*\]中的字记为*t*，把这个字变为t和x\[*rs2*\]按位异或的结果，把x\[*rd*\]设为符号位扩展的*t*。

  ------- ---- ---- ----- ----- ----- ---- ---------
  00100   aq   rl   rs2   rs1   010   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

and rd, rs1, rs2 x\[rd\] = x\[rs1\] & x\[rs2\]

与 *(And)*. R-type, RV32I and RV64I.

将寄存器x\[*rs1*\]和寄存器x\[*rs2*\]位与的结果写入x\[*rd*\]。

压缩形式：**c.and** rd, rs2

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   111   rd   0110011
  --------- ----- ----- ----- ---- ---------

andi rd, rs1, immediate x\[rd\] = x\[rs1\] & sext(immediate)

与立即数 *(And Immediate)*. I-type, RV32I and RV64I.

把符号位扩展的立即数和寄存器x\[*rs1*\]上的值进行位与，结果写入x\[*rd*\]。

压缩形式：**c.andi** rd, imm

  ------------------- ----- ----- ---- ---------
  immediate\[11:0\]   rs1   111   rd   0010011
  ------------------- ----- ----- ---- ---------

auipc rd, immediate x\[rd\] = pc + sext(immediate\[31:12\] \<\< 12)

*PC*加立即数 *(Add Upper Immediate to PC)*. U-type, RV32I and RV64I.

把符号位扩展的20位（左移12位）立即数加到*pc*上，结果写入x\[*rd*\]。

  -------------------- ---- ---------
  immediate\[31:12\]   rd   0010111
  -------------------- ---- ---------

beq rs1, rs2, offset if (rs1 == rs2) pc += sext(offset)

相等时分支 *(Branch if Equal)*. B-type, RV32I and RV64I.

若寄存器x\[*rs1*\]和寄存器x\[*rs2*\]的值相等，把*pc*的值设为当前值加上符号位扩展的偏移*offset*。

压缩形式：**c.beqz** rs1, offset

  -------------------- ----- ----- ----- ------------------- ---------
  offset\[12\|10:5\]   rs2   rs1   000   offset\[4:1\|11\]   1100011
  -------------------- ----- ----- ----- ------------------- ---------

beqz rs1, offset if (rs1 == 0) pc += sext(offset)

等于零时分支 *(Branch if Equal to Zero)*. 伪指令(Pesudoinstruction),
RV32I and RV64I.

可视为**beq** rs1, x0, offset.

bge rs1, rs2, offset if (rs1 ≥~s~ rs2) pc += sext(offset)

大于等于时分支 *(Branch if Greater Than or Equal)*. B-type, RV32I and
RV64I.

若寄存器x\[*rs1*\]的值大于等于寄存器x\[*rs2*\]的值（均视为二进制补码），把*pc*的值设为当前值加上符号位扩展的偏移*offset*。

  -------------------- ----- ----- ----- ------------------- ---------
  offset\[12\|10:5\]   rs2   rs1   101   offset\[4:1\|11\]   1100011
  -------------------- ----- ----- ----- ------------------- ---------

bgeu rs1, rs2, offset if (rs1 ≥~u~ rs2) pc += sext(offset)

无符号大于等于时分支 *(Branch if Greater Than or Equal, Unsigned)*.
B-type, RV32I and RV64I.

若寄存器x\[*rs1*\]的值大于等于寄存器x\[*rs2*\]的值（均视为无符号数），把*pc*的值设为当前值加上符号位扩展的偏移*offset*。

  -------------------- ----- ----- ----- ------------------- ---------
  offset\[12\|10:5\]   rs2   rs1   111   offset\[4:1\|11\]   1100011
  -------------------- ----- ----- ----- ------------------- ---------

bgez rs1, offset if (rs1 ≥~s~ 0) pc += sext(offset)

大于等于零时分支 *(Branch if Greater Than or Equal to Zero)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

可视为**bge** rs1, x0, offset.

bgt rs1, rs2, offset if (rs1 \>~s~ rs2) pc += sext(offset)

大于时分支 *(Branch if Greater Than)*. 伪指令(Pesudoinstruction), RV32I
and RV64I.

可视为**blt** rs2, rs1, offset.

bgtu rs1, rs2, offset if (rs1 \>~u~ rs2) pc += sext(offset)

无符号大于时分支 *(Branch if Greater Than, Unsigned)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

可视为**bltu** rs2, rs1, offset.

bgtz rs1, offset if (rs2 \>~s~ 0) pc += sext(offset)

大于零时分支 *(Branch if Greater Than Zero)*. 伪指令(Pesudoinstruction),
RV32I and RV64I.

可视为**blt** x0, rs2, offset.

ble rs1, rs2, offset if (rs1 ≤~s~ rs2) pc += sext(offset)

小于等于时分支 *(Branch if Less Than or Equal)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

可视为**bge** rs2, rs1, offset.

bleu rs1, rs2, offset if (rs1 ≤~u~ rs2) pc += sext(offset)

小于等于时分支 *(Branch if Less Than or Equal, Unsigned)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

可视为**bgeu** rs2, rs1, offset.

blez rs2, offset if (rs2 ≤~s~ 0) pc += sext(offset)

小于等于零时分支 *(Branch if Less Than or Equal to Zero)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

可视为**bge** x0, rs2, offset.

blt rs1, rs2, offset if (rs1 \<~s~ rs2) pc += sext(offset)

小于时分支 *(Branch if Less Than)*. B-type, RV32I and RV64I.

若寄存器x\[*rs1*\]的值小于寄存器x\[*rs2*\]的值（均视为二进制补码），把*pc*的值设为当前值加上符号位扩展的偏移*offset*。

  -------------------- ----- ----- ----- ------------------- ---------
  offset\[12\|10:5\]   rs2   rs1   100   offset\[4:1\|11\]   1100011
  -------------------- ----- ----- ----- ------------------- ---------

bltz rs2, offset if (rs1 \<~s~ 0) pc += sext(offset)

小于零时分支 *(Branch if Less Than Zero)*. 伪指令(Pesudoinstruction),
RV32I and RV64I.

可视为**blt** rs1, x0, offset.

bltu rs1, rs2, offset if (rs1 \<~u~ rs2) pc += sext(offset)

无符号小于时分支 *(Branch if Less Than, Unsigned)*. B-type, RV32I and
RV64I.

若寄存器x\[*rs1*\]的值小于寄存器x\[*rs2*\]的值（均视为无符号数），把*pc*的值设为当前值加上符号位扩展的偏移*offset*。

  -------------------- ----- ----- ----- ------------------- ---------
  offset\[12\|10:5\]   rs2   rs1   110   offset\[4:1\|11\]   1100011
  -------------------- ----- ----- ----- ------------------- ---------

bne rs1, rs2, offset if (rs1 ≠ rs2) pc += sext(offset)

不相等时分支 *(Branch if Not Equal)*. B-type, RV32I and RV64I.

若寄存器x\[*rs1*\]和寄存器x\[*rs2*\]的值不相等，把*pc*的值设为当前值加上符号位扩展的偏移*offset*。

压缩形式：**c.bnez** rs1, offset

  -------------------- ----- ----- ----- ------------------- ---------
  offset\[12\|10:5\]   rs2   rs1   001   offset\[4:1\|11\]   1100011
  -------------------- ----- ----- ----- ------------------- ---------

bnez rs1, offset if (rs1 ≠ 0) pc += sext(offset)

不等于零时分支 *(Branch if Not Equal to Zero)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

可视为**bne** rs1, x0, offset.

c.add rd, rs2 x\[rd\] = x\[rd\] + x\[rs2\]

加 *(Add)*. RV32IC and RV64IC.

扩展形式为**add** rd, rd, rs2. rd=x0或rs2=x0时非法。

  ----- --- ---- ----- ----
  100   1   rd   rs2   10
  ----- --- ---- ----- ----

c.addi rd, imm x\[rd\] = x\[rd\] + sext(imm)

加立即数 *(Add Immediate)*. RV32IC and RV64IC.

扩展形式为**addi** rd, rd, imm.

  ----- ---------- ---- ------------ ----
  000   imm\[5\]   rd   imm\[4:0\]   01
  ----- ---------- ---- ------------ ----

c.addi16sp imm x\[2\] = x\[2\] + sext(imm)

加16倍立即数到栈指针 *(Add Immediate, Scaled by 16, to Stack Pointer)*.
RV32IC and RV64IC.

扩展形式为**addi** x2, x2, imm. imm=0时非法。

  ----- ---------- ------- --------------------- ----
  011   imm\[9\]   00010   imm\[4\|6\|8:7\|5\]   01
  ----- ---------- ------- --------------------- ----

c.addi4spn rd', uimm x\[8+rd'\] = x\[2\] + uimm

加4倍立即数到栈指针 *(Add Immediate, Scaled by 4, to Stack Pointer,
Nondestructive)*. RV32IC and RV64IC.

扩展形式为**addi** rd, x2, uimm, 其中rd=8+rd'. uimm=0时非法。

  ----- ------------------------ ----- ----
  000   uimm\[5:4\|9:6\|2\|3\]   rd'   00
  ----- ------------------------ ----- ----

c.addiw rd, imm x\[rd\] = sext((x\[rd\] + sext(imm))\[31:0\])

加立即数字 *(Add Word Immediate)*. RV64IC.

扩展形式为**addiw** rd, rd, imm. rd=x0时非法。

  ----- ---------- ---- ------------ ----
  001   imm\[5\]   rd   imm\[4:0\]   01
  ----- ---------- ---- ------------ ----

c.and rd', rs2' x\[8+rd'\] = x\[8+rd'\] & x\[8+rs2'\]

与 *(AND)*. RV32IC and RV64IC.

扩展形式为**and** rd, rd, rs2, 其中rd=8+rd', rs2=8+rs2'.

  -------- ----- ---- ------ ----
  100011   rd'   11   rs2'   01
  -------- ----- ---- ------ ----

c.addw rd', rs2' x\[8+rd'\] = sext((x\[8+rd'\] + x\[8+rs2'\])\[31:0\])

加字 *(Add Word)*. RV64IC.

扩展形式为**addw** rd, rd, rs2, 其中rd=8+rd', rs2=8+rs2'.

  -------- ----- ---- ------ ----
  100111   rd'   01   rs2'   01
  -------- ----- ---- ------ ----

c.andi rd', imm x\[8+rd'\] = x\[8+rd'\] & sext(imm)

与立即数 *(AND Immediate)*. RV32IC and RV64IC.

扩展形式为**andi** rd, rd, imm, 其中rd=8+rd'.

  ----- ---------- ---- ----- ------------ ----
  100   imm\[5\]   10   rd'   imm\[4:0\]   01
  ----- ---------- ---- ----- ------------ ----

c.beqz rs1', offset if (x\[8+rs1'\] == 0) pc += sext(offset)

等于零时分支 *(Branch if Equal to Zero)*. RV32IC and RV64IC.

扩展形式为**beq** rs1, x0, offset, 其中rs1=8+rs1'.

  ----- ------------------ ------ ----------------------- ----
  110   offset\[8\|4:3\]   rs1'   offset\[7:6\|2:1\|5\]   01
  ----- ------------------ ------ ----------------------- ----

c.bnez rs1', offset if (x\[8+rs1'\] ≠ 0) pc += sext(offset)

不等于零时分支 *(Branch if Not Equal to Zero)*. RV32IC and RV64IC.

扩展形式为**bne** rs1, x0, offset, 其中rs1=8+rs1'.

  ----- ------------------ ------ ----------------------- ----
  111   offset\[8\|4:3\]   rs1'   offset\[7:6\|2:1\|5\]   01
  ----- ------------------ ------ ----------------------- ----

c.ebreak RaiseException(Breakpoint)

环境断点 *(Environment Breakpoint)*. RV32IC and RV64IC.

扩展形式为**ebreak**.

  ----- --- ------- ------- ----
  100   1   00000   00000   10
  ----- --- ------- ------- ----

c.fld rd', uimm(rs1') f\[8+rd'\] = M\[x\[8+rs1'\] + uimm\]\[63:0\]

浮点双字加载 *(Floating-point Load Doubleword)*. RV32DC and RV64DC.

扩展形式为**fld** rd, uimm(rs1), 其中rd=8+rd', rs1=8+rs1'.

  ----- ------------- ------ ------------- ----- ----
  001   uimm\[5:3\]   rs1'   uimm\[7:6\]   rd'   00
  ----- ------------- ------ ------------- ----- ----

c.fldsp rd, uimm(x2) f\[rd\] = M\[x\[2\] + uimm\]\[63:0\]

栈指针相关浮点双字加载 *(Floating-point Load Doubleword, Stack-Pointer
Relative)*. RV32DC and RV64DC.

扩展形式为**fld** rd, uimm(x2).

  ----- ----------- ---- ------------------ ----
  001   uimm\[5\]   rd   uimm\[4:3\|8:6\]   10
  ----- ----------- ---- ------------------ ----

c.flw rd', uimm(rs1') f\[8+rd'\] = M\[x\[8+rs1'\] + uimm\]\[31:0\]

浮点字加载 *(Floating-point Load Word)*. RV32FC.

扩展形式为**flw** rd, uimm(rs1), 其中rd=8+rd', rs1=8+rs1'.

  ----- ------------- ------ -------------- ----- ----
  011   uimm\[5:3\]   rs1'   uimm\[2\|6\]   rd'   00
  ----- ------------- ------ -------------- ----- ----

c.flwsp rd, uimm(x2) f\[rd\] = M\[x\[2\] + uimm\]\[31:0\]

栈指针相关浮点字加载 *(Floating-point Load Word, Stack-Pointer
Relative)*. RV32FC.

扩展形式为**flw** rd, uimm(x2).

  ----- ----------- ---- ------------------ ----
  011   uimm\[5\]   rd   uimm\[4:2\|7:6\]   10
  ----- ----------- ---- ------------------ ----

c.fsd rs2', uimm(rs1') M\[x\[8+rs1'\] + uimm\]\[63:0\] = f\[8+rs2'\]

浮点双字存储 *(Floating-point Store Doubleword)*. RV32DC and RV64DC.

扩展形式为**fsd** rs2, uimm(rs1), 其中rs2=8+rs2', rs1=8+rs1'.

  ----- ------------- ------ ------------- ------ ----
  101   uimm\[5:3\]   rs1'   uimm\[7:6\]   rs2'   00
  ----- ------------- ------ ------------- ------ ----

c.fsdsp rs2, uimm(x2) M\[x\[2\] + uimm\]\[63:0\] = f\[rs2\]

栈指针相关浮点双字存储 *(Floating-point Store Doubleword, Stack-Pointer
Relative)*. RV32DC and RV64DC.

扩展形式为**fsd** rs2, uimm(x2).

  ----- ------------------ ----- ----
  101   uimm\[5:3\|8:6\]   rs2   10
  ----- ------------------ ----- ----

c.fsw rs2', uimm(rs1') M\[x\[8+rs1'\] + uimm\]\[31:0\] = f\[8+rs2'\]

浮点字存储 *(Floating-point Store Word)*. RV32FC.

扩展形式为**fsw** rs2, uimm(rs1), 其中rs2=8+rs2', rs1=8+rs1'.

  ----- ------------- ------ -------------- ------ ----
  111   uimm\[5:3\]   rs1'   uimm\[2\|6\]   rs2'   00
  ----- ------------- ------ -------------- ------ ----

c.fswsp rs2, uimm(x2) M\[x\[2\] + uimm\]\[31:0\] = f\[rs2\]

栈指针相关浮点字存储 *(Floating-point Store Word, Stack-Pointer
Relative)*. RV32FC.

扩展形式为**fsw** rs2, uimm(x2).

  ----- ------------------ ----- ----
  111   uimm\[5:2\|7:6\]   rs2   10
  ----- ------------------ ----- ----

c.j offset pc += sext(offset)

跳转 *(Jump)*. RV32IC and RV64IC.

扩展形式为**jal** x0, offset.

  ----- ---------------------------------------- ----
  101   offset\[11\|4\|9:8\|10\|6\|7\|3:1\|5\]   01
  ----- ---------------------------------------- ----

c.jal offset x\[1\] = pc+2; pc += sext(offset)

链接跳转 *(Jump and Link)*. RV32IC.

扩展形式为**jal** x1, offset.

  ----- ---------------------------------------- ----
  001   offset\[11\|4\|9:8\|10\|6\|7\|3:1\|5\]   01
  ----- ---------------------------------------- ----

c.jalr rs1 t = pc+2; pc = x\[rs1\]; x\[1\] = t

寄存器链接跳转 *(Jump and Link Register)*. RV32IC and RV64IC.

扩展形式为**jalr** x1, 0(rs1). 当rs1=x0时非法。

  ----- --- ----- ------- ----
  100   1   rs1   00000   10
  ----- --- ----- ------- ----

c.jr rs1 pc = x\[rs1\]

寄存器跳转 *(Jump Register)*. RV32IC and RV64IC.

扩展形式为**jalr** x0, 0(rs1). 当rs1=x0时非法。

  ----- --- ----- ------- ----
  100   0   rs1   00000   10
  ----- --- ----- ------- ----

c.ld rd', uimm(rs1') x\[8+rd'\] = M\[x\[8+rs1'\] + uimm\]\[63:0\]

双字加载 *(Load Doubleword)*. RV64IC.

扩展形式为**ld** rd, uimm(rs1), 其中rd=8+rd', rs1=8+rs1'.

  ----- ------------- ------ ------------- ----- ----
  011   uimm\[5:3\]   rs1'   uimm\[7:6\]   rd'   00
  ----- ------------- ------ ------------- ----- ----

c.ldsp rd, uimm(x2) x\[rd\] = M\[x\[2\] + uimm\]\[63:0\]

栈指针相关双字加载 *(Load Doubleword, Stack-Pointer Relative)*. RV64IC.

扩展形式为**ld** rd, uimm(x2). rd=x0时非法。

  ----- ----------- ---- ------------------ ----
  011   uimm\[5\]   rd   uimm\[4:3\|8:6\]   10
  ----- ----------- ---- ------------------ ----

c.li rd, imm x\[rd\] = sext(imm)

立即数加载 *(Load Immediate)*. RV32IC and RV64IC.

扩展形式为**addi** rd, x0, imm.

  ----- ---------- ---- ------------ ----
  010   imm\[5\]   rd   imm\[4:0\]   01
  ----- ---------- ---- ------------ ----

c.lui rd, imm x\[rd\] = sext(imm\[17:12\] \<\< 12)

高位立即数加载 *(Load Upper Immediate)*. RV32IC and RV64IC.

扩展形式为**lui** rd, imm. 当rd=x2或imm=0时非法。

  ----- ----------- ---- -------------- ----
  011   imm\[17\]   rd   imm\[16:12\]   01
  ----- ----------- ---- -------------- ----

c.lw rd', uimm(rs1') x\[8+rd'\] = sext(M\[x\[8+rs1'\] + uimm\]\[31:0\])

字加载 *(Load Word)*. RV32IC and RV64IC.

扩展形式为**lw** rd, uimm(rs1), 其中rd=8+rd', rs1=8+rs1'.

  ----- ------------- ------ -------------- ----- ----
  010   uimm\[5:3\]   rs1'   uimm\[2\|6\]   rd'   00
  ----- ------------- ------ -------------- ----- ----

c.lwsp rd, uimm(x2) x\[rd\] = sext(M\[x\[2\] + uimm\]\[31:0\])

栈指针相关字加载 *(Load Word, Stack-Pointer Relative)*. RV32IC and
RV64IC.

扩展形式为**lw** rd, uimm(x2). rd=x0时非法。

  ----- ----------- ---- ------------------ ----
  010   uimm\[5\]   rd   uimm\[4:2\|7:6\]   10
  ----- ----------- ---- ------------------ ----

c.mv rd, rs2 x\[rd\] = x\[rs2\]

移动 *(Move)*. RV32IC and RV64IC.

扩展形式为**add** rd, x0, rs2. rs2=x0时非法。

  ----- --- ---- ----- ----
  100   0   rd   rs2   10
  ----- --- ---- ----- ----

c.or rd', rs2' x\[8+rd'\] = x\[8+rd'\] \| x\[8+rs2'\]

或 *(OR)*. RV32IC and RV64IC.

扩展形式为**or** rd, rd, rs2, 其中rd=8+rd', rs2=8+rs2'.

  -------- ----- ---- ------ ----
  100011   rd'   10   rs2'   01
  -------- ----- ---- ------ ----

c.sd rs2', uimm(rs1') M\[x\[8+rs1'\] + uimm\]\[63:0\] = x\[8+rs2'\]

双字存储*(Store Doubleword)*. RV64IC.

扩展形式为**sd** rs2, uimm(rs1), 其中rs2=8+rs2', rs1=8+rs1'.

  ----- ------------- ------ ------------- ------ ----
  111   uimm\[5:3\]   rs1'   uimm\[7:6\]   rs2'   00
  ----- ------------- ------ ------------- ------ ----

c.sdsp rs2, uimm(x2) M\[x\[2\] + uimm\]\[63:0\] = x\[rs2\]

栈指针相关双字存储 *(Store Doubleword, Stack-Pointer Relative)*. RV64IC.

扩展形式为**sd** rs2, uimm(x2).

  ----- ------------------ ----- ----
  111   uimm\[5:3\|8:6\]   rs2   10
  ----- ------------------ ----- ----

c.slli rd, uimm x\[rd\] = x\[rd\] \<\< uimm

立即数逻辑左移 *(Shift Left Logical Immediate)*. RV32IC and RV64IC.

扩展形式为**slli** rd, rd, uimm.

  ----- ----------- ---- ------------- ----
  000   uimm\[5\]   rd   uimm\[4:0\]   10
  ----- ----------- ---- ------------- ----

c.srai rd', uimm x\[8+rd'\] = x\[8+rd'\] \>\>~s~ uimm

立即数算术右移 *(Shift Right Arithmetic Immediate)*. RV32IC and RV64IC.

扩展形式为**srai** rd, rd, uimm, 其中rd=8+rd'.

  ----- ----------- ---- ----- ------------- ----
  100   uimm\[5\]   01   rd'   uimm\[4:0\]   01
  ----- ----------- ---- ----- ------------- ----

c.srli rd', uimm x\[8+rd'\] = x\[8+rd'\] \>\>~u~ uimm

立即数逻辑右移 *(Shift Right Logical Immediate)*. RV32IC and RV64IC.

扩展形式为**srli** rd, rd, uimm, 其中rd=8+rd'.

  ----- ----------- ---- ----- ------------- ----
  100   uimm\[5\]   00   rd'   uimm\[4:0\]   01
  ----- ----------- ---- ----- ------------- ----

c.sub rd', rs2' x\[8+rd'\] = x\[8+rd'\] - x\[8+rs2'\]

减 *(Subtract)*. RV32IC and RV64IC.

扩展形式为**sub** rd, rd, rs2. 其中rd=8+rd', rs2=8+rs2'. .

  -------- ----- ---- ------ ----
  100011   rd'   00   rs2'   01
  -------- ----- ---- ------ ----

c.subw rd', rs2' x\[8+rd'\] = sext((x\[8+rd'\] - x\[8+rs2'\])\[31:0\])

减字 *(Subtract Word)*. RV64IC.

扩展形式为**subw** rd, rd, rs2. 其中rd=8+rd', rs2=8+rs2'. .

  -------- ----- ---- ------ ----
  100111   rd'   00   rs2'   01
  -------- ----- ---- ------ ----

c.sw rs2', uimm(rs1') M\[x\[8+rs1'\] + uimm\]\[31:0\] = x\[8+rs2'\]

字存储 *(Store Word)*. RV32IC and RV64IC.

扩展形式为**sw** rs2, uimm(rs1), 其中rs2=8+rs2', rs1=8+rs1'.

  ----- ------------- ------ -------------- ------ ----
  110   uimm\[5:3\]   rs1'   uimm\[2\|6\]   rs2'   00
  ----- ------------- ------ -------------- ------ ----

c.swsp rs2, uimm(x2) M\[x\[2\] + uimm\]\[31:0\] = x\[rs2\]

栈指针相关字存储 *(Store Word, Stack-Pointer Relative)*. RV32IC and
RV64IC.

扩展形式为**sw** rs2, uimm(x2).

  ----- ------------------ ----- ----
  110   uimm\[5:2\|7:6\]   rs2   10
  ----- ------------------ ----- ----

c.xor rd', rs2' x\[8+rd'\] = x\[8+rd'\] \^ x\[8+rs2'\]

异或 *(Exclusive-OR)*. RV32IC and RV64IC.

扩展形式为**xor** rd, rd, rs2, 其中rd=8+rd', rs2=8+rs2'.

  -------- ----- ---- ------ ----
  100011   rd'   01   rs2'   01
  -------- ----- ---- ------ ----

call rd, symbol x\[rd\] = pc+8; pc = &symbol

调用 *(Call)*. 伪指令(Pesudoinstruction), RV32I and RV64I.

把下一条指令的地址（*pc*+8）写入x\[*rd*\]，然后把*pc*设为*symbol*。等同于**auipc**
rd, offestHi, 再加上一条**jalr** rd, offsetLo(rd).
若省略了*rd*，默认为x1.

csrr rd, csr x\[rd\] = CSRs\[csr\]

读控制状态寄存器 *(Control and Status Register Read)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

把控制状态寄存器*csr*的值写入x\[*rd*\]，等同于**csrrs** rd, csr, x0.

csrc csr, rs1 CSRs\[csr\] &= \~x\[rs1\]

清除控制状态寄存器 *(Control and Status Register Clear)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

对于x\[*rs1*\]中每一个为1的位，把控制状态寄存器*csr*的的对应位清零，等同于**csrrc**
x0, csr, rs1.

csrci csr, zimm\[4:0\] CSRs\[csr\] &= \~zimm

立即数清除控制状态寄存器 *(Control and Status Register Clear
Immediate)*. 伪指令(Pesudoinstruction), RV32I and RV64I.

对于五位的零扩展的立即数中每一个为1的位，把控制状态寄存器*csr*的的对应位清零，等同于**csrrci**
x0, csr, zimm.

csrrc rd, csr, rs1 t = CSRs\[csr\]; CSRs\[csr\] = t &\~x\[rs1\]; x\[rd\]
= t

读后清除控制状态寄存器 *(Control and Status Register Read and Clear)*.
I-type, RV32I and RV64I.

记控制状态寄存器*csr*中的值为*t。*把*t*和寄存器x\[*rs1*\]按位与的结果写入*csr*，再把*t*写入x\[*rd*\]。

  ----- ----- ----- ---- ---------
  csr   rs1   011   rd   1110011
  ----- ----- ----- ---- ---------

csrrci rd, csr, zimm\[4:0\] t = CSRs\[csr\]; CSRs\[csr\] = t &\~zimm;
x\[rd\] = t

立即数读后清除控制状态寄存器 *(Control and Status Register Read and
Clear Immediate)*. I-type, RV32I and RV64I.

记控制状态寄存器*csr*中的值为*t。*把*t*和五位的零扩展的立即数*zimm*按位与的结果写入*csr*，再把*t*写入x\[*rd*\]（*csr*寄存器的第5位及更高位不变）。

  ----- ------------- ----- ---- ---------
  csr   zimm\[4:0\]   111   rd   1110011
  ----- ------------- ----- ---- ---------

csrrs rd, csr, rs1 t = CSRs\[csr\]; CSRs\[csr\] = t \| x\[rs1\]; x\[rd\]
= t

读后置位控制状态寄存器 *(Control and Status Register Read and Set)*.
I-type, RV32I and RV64I.

记控制状态寄存器*csr*中的值为*t。*把*t*和寄存器x\[*rs1*\]按位或的结果写入*csr*，再把*t*写入x\[*rd*\]。

  ----- ----- ----- ---- ---------
  csr   rs1   010   rd   1110011
  ----- ----- ----- ---- ---------

csrrci rd, csr, zimm\[4:0\] t = CSRs\[csr\]; CSRs\[csr\] = t \| zimm;
x\[rd\] = t

立即数读后设置控制状态寄存器 *(Control and Status Register Read and Set
Immediate)*. I-type, RV32I and RV64I.

记控制状态寄存器*csr*中的值为*t。*把*t*和五位的零扩展的立即数*zimm*按位或的结果写入*csr*，再把*t*写入x\[*rd*\]（*csr*寄存器的第5位及更高位不变）。

  ----- ------------- ----- ---- ---------
  csr   zimm\[4:0\]   110   rd   1110011
  ----- ------------- ----- ---- ---------

csrrw rd, csr, zimm\[4:0\] t = CSRs\[csr\]; CSRs\[csr\] = x\[rs1\];
x\[rd\] = t

读后写控制状态寄存器 *(Control and Status Register Read and Write)*.
I-type, RV32I and RV64I.

记控制状态寄存器*csr*中的值为*t。*把寄存器x\[*rs1*\]的值写入*csr*，再把*t*写入x\[*rd*\]。

  ----- ----- ----- ---- ---------
  csr   rs1   001   rd   1110011
  ----- ----- ----- ---- ---------

csrrwi rd, csr, zimm\[4:0\] x\[rd\] = CSRs\[csr\]; CSRs\[csr\] = zimm

立即数读后写控制状态寄存器 *(Control and Status Register Read and Write
Immediate)*. I-type, RV32I and RV64I.

把控制状态寄存器*csr*中的值拷贝到x\[*rd*\]中，再把五位的零扩展的立即数*zimm*的值写入*csr*。

  ----- ------------- ----- ---- ---------
  csr   zimm\[4:0\]   101   rd   1110011
  ----- ------------- ----- ---- ---------

csrc csr, rs1 CSRs\[csr\] \|= x\[rs1\]

置位控制状态寄存器 *(Control and Status Register Set)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

对于x\[*rs1*\]中每一个为1的位，把控制状态寄存器*csr*的的对应位置位，等同于**csrrs**
x0, csr, rs1.

csrci csr, zimm\[4:0\] CSRs\[csr\] \|= zimm

立即数置位控制状态寄存器 *(Control and Status Register Set Immediate)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

对于五位的零扩展的立即数中每一个为1的位，把控制状态寄存器*csr*的的对应位清零，等同于**csrrsi**
x0, csr, zimm.

csrw csr, rs1 CSRs\[csr\] = x\[rs1\]

写控制状态寄存器 *(Control and Status Register Set)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

对于x\[*rs1*\]中每一个为1的位，把控制状态寄存器*csr*的的对应位置位，等同于**csrrs**
x0, csr, rs1.

csrwi csr, zimm\[4:0\] CSRs\[csr\] = zimm

立即数写控制状态寄存器 *(Control and Status Register Write Immediate)*.
伪指令(Pesudoinstruction), RV32I and RV64I.

把五位的零扩展的立即数的值写入控制状态寄存器*csr*的，等同于**csrrwi**
x0, csr, zimm.

div rd, rs1, rs2 x\[rd\] = x\[rs1\] ÷~s~ x\[rs2\]

除法*(Divide)*. R-type, RV32M and RV64M.

用寄存器x\[*rs1*\]的值除以寄存器x\[*rs2*\]的值，向零舍入，将这些数视为二进制补码，把商写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   100   rd   0110011
  --------- ----- ----- ----- ---- ---------

divu rd, rs1, rs2 x\[rd\] = x\[rs1\] ÷~u~ x\[rs2\]

无符号除法*(Divide, Unsigned)*. R-type, RV32M and RV64M.

用寄存器x\[*rs1*\]的值除以寄存器x\[*rs2*\]的值，向零舍入，将这些数视为无符号数，把商写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   101   rd   0110011
  --------- ----- ----- ----- ---- ---------

divuw rd, rs1, rs2 x\[rd\] = sext(x\[rs1\]\[31:0\] ÷~u~
x\[rs2\]\[31:0\])

无符号字除法*(Divide Word, Unsigned)*. R-type, RV64M.

用寄存器x\[*rs1*\]的低32位除以寄存器x\[*rs2*\]的低32位，向零舍入，将这些数视为无符号数，把经符号位扩展的32位商写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   101   rd   0111011
  --------- ----- ----- ----- ---- ---------

divw rd, rs1, rs2 x\[rd\] = sext(x\[rs1\]\[31:0\] ÷~s~ x\[rs2\]\[31:0\])

字除法*(Divide Word)*. R-type, RV64M.

用寄存器x\[*rs1*\]的低32位除以寄存器x\[*rs2*\]的低32位，向零舍入，将这些数视为二进制补码，把经符号位扩展的32位商写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   100   rd   0111011
  --------- ----- ----- ----- ---- ---------

Ebreak RaiseException(Breakpoint)

环境断点 *(Environment Breakpoint)*. I-type, RV32I and RV64I.

通过抛出断点异常的方式请求调试器。

  -------------- ------- ----- ------- ---------
  000000000001   00000   000   00000   1110011
  -------------- ------- ----- ------- ---------

ecall RaiseException(EnvironmentCall)

环境调用 *(Environment Call)*. I-type, RV32I and RV64I.

通过引发环境调用异常来请求执行环境。

  -------------- ------- ----- ------- ---------
  000000000000   00000   000   00000   1110011
  -------------- ------- ----- ------- ---------

fabs.d rd, rs1 f\[rd\] = \|f\[rs1\]\|

浮点数绝对值 *(Floating-point Absolute Value)*.
伪指令(Pesudoinstruction), RV32D and RV64D.

把双精度浮点数f\[*rs1*\]的绝对值写入f\[*rd*\]。

等同于**fsgnjx.d** rd, rs1, rs1.

fabs.s rd, rs1 f\[rd\] = \|f\[rs1\]\|

浮点数绝对值 *(Floating-point Absolute Value)*.
伪指令(Pesudoinstruction), RV32F and RV64F.

把单精度浮点数f\[*rs1*\]的绝对值写入f\[*rd*\]。

等同于**fsgnjx.s** rd, rs1, rs1.

fadd.d rd, rs1, rs2 f \[rd\] = f \[rs1\] + f \[rs2\]

双精度浮点加*(Floating-point Add, Double-Precision)*. R-type, RV32D and
RV64D.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数相加，并将舍入后的和写入f\[*rd*\]。

  --------- ----- ----- ---- ---- ---------
  0000001   rs2   rs1   rm   rd   1010011
  --------- ----- ----- ---- ---- ---------

fadd.s rd, rs1, rs2 f \[rd\] = f \[rs1\] + f \[rs2\]

单精度浮点加*(Floating-point Add, Single-Precision)*. R-type, RV32F and
RV64F.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数相加，并将舍入后的和写入f\[*rd*\]。

  --------- ----- ----- ---- ---- ---------
  0000000   rs2   rs1   rm   rd   1010011
  --------- ----- ----- ---- ---- ---------

fclass.d rd, rs1, rs2 x\[rd\] = classify*~d~*(f\[rs1\])

双精度浮点分类*(Floating-point Classify, Double-Precision)*. R-type,
RV32D and RV64D.

把一个表示寄存器f\[*rs1*\]中双精度浮点数类别的掩码写入x\[*rd*\]中。关于如何解释写入x\[*rd*\]的值，请参阅指令**fclass.s**的介绍。

  --------- ------- ----- ----- ---- ---------
  1110001   00000   rs1   001   rd   1010011
  --------- ------- ----- ----- ---- ---------

fclass.s rd, rs1, rs2 x\[rd\] = classify*~s~*(f\[rs1\])

单精度浮点分类*(Floating-point Classify, Single-Precision)*. R-type,
RV32F and RV64F.

把一个表示寄存器f\[*rs1*\]中单精度浮点数类别的掩码写入x\[*rd*\]中。x\[*rd*\]中有且仅有一位被置上，见下表。

  x*\[rd\]*位   含义
  ------------- -----------------------------------
  0             f \[*rs1*\]为$- \infty$。
  1             f \[*rs1*\]是负规格化数。
  2             f \[*rs1*\]是负的非规格化数。
  3             f \[*rs1*\]是-0。
  4             f \[*rs1*\]是+0。
  5             f \[*rs1*\]是正的非规格化数。
  6             f \[*rs1*\]是正的规格化数。
  7             f \[*rs1*\]为+$\infty$。
  8             f \[*rs1*\]是信号(signaling)NaN。
  9             f \[*rs1*\]是一个安静(quiet)NaN。

  --------- ------- ----- ----- ---- ---------
  1110000   00000   rs1   001   rd   1010011
  --------- ------- ----- ----- ---- ---------

fcvt.d.l rd, rs1, rs2 f\[rd\] = f64~*s*64~(x\[rs1\])

长整型向双精度浮点转换*(Floating-point Convert to Double from Long)*.
R-type, RV64D.

把寄存器x\[*rs1*\]中的64位二进制补码表示的整数转化为双精度浮点数，再写入f\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1101001   00010   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.d.lu rd, rs1, rs2 f\[rd\] = f64~*u*64~(x\[rs1\])

无符号长整型向双精度浮点转换*(Floating-point Convert to Double from
Unsigned Long)*. R-type, RV64D.

把寄存器x\[*rs1*\]中的64位无符号整数转化为双精度浮点数，再写入f\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1101001   00011   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.d.s rd, rs1, rs2 f\[rd\] = f64~*f*32~(f\[rs1\])

单精度向双精度浮点转换*(Floating-point Convert to Double from Single)*.
R-type, RV32D and RV64D.

把寄存器f\[*rs1*\]中的单精度浮点数转化为双精度浮点数，再写入f\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  0100001   00000   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.d.w rd, rs1, rs2 f\[rd\] = f64~*s*32~(x\[rs1\])

字向双精度浮点转换*(Floating-point Convert to Double from Word)*.
R-type, RV32D and RV64D.

把寄存器x\[*rs1*\]中的32位二进制补码表示的整数转化为双精度浮点数，再写入f\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1101001   00000   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.d.wu rd, rs1, rs2 f\[rd\] = f64~*u*32~(x\[rs1\])

无符号字向双精度浮点转换*(Floating-point Convert to Double from Unsigned
Word)*. R-type, RV32D and RV64D.

把寄存器x\[*rs1*\]中的32位无符号整数转化为双精度浮点数，再写入f\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1101001   00001   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.l.d rd, rs1, rs2 x\[rd\] = s64~*f*64~(f\[rs1\])

双精度浮点向长整型转换*(Floating-point Convert to Long from Double)*.
R-type, RV64D.

把寄存器f\[*rs1*\]中的双精度浮点数转化为64位二进制补码表示的整数，再写入x\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1100001   00010   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.l.s rd, rs1, rs2 x\[rd\] = s64~*f*32~(f\[rs1\])

单精度浮点向长整型转换*(Floating-point Convert to Long from Single)*.
R-type, RV64F.

把寄存器f\[*rs1*\]中的单精度浮点数转化为64位二进制补码表示的整数，再写入x\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1100000   00010   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.lu.d rd, rs1, rs2 x\[rd\] = u64~*f*64~(f\[rs1\])

双精度浮点向无符号长整型转换*(Floating-point Convert to Unsigned Long
from Double)*. R-type, RV64D.

把寄存器f\[*rs1*\]中的双精度浮点数转化为64位无符号整数，再写入x\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1100001   00011   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.lu.s rd, rs1, rs2 x\[rd\] = u64~*f*32~(f\[rs1\])

单精度浮点向无符号长整型转换*(Floating-point Convert to Unsigned Long
from Single)*. R-type, RV64F.

把寄存器f\[*rs1*\]中的单精度浮点数转化为64位二进制补码表示的整数，再写入x\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1100000   00011   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.s.d rd, rs1, rs2 f\[rd\] = f32~*f*64~(f\[rs1\])

双精度向单精度浮点转换*(Floating-point Convert to Single from Double)*.
R-type, RV32D and RV64D.

把寄存器f\[*rs1*\]中的双精度浮点数转化为单精度浮点数，再写入f\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  0100000   00001   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.s.l rd, rs1, rs2 f\[rd\] = f32~*s*64~(x\[rs1\])

长整型向单精度浮点转换*(Floating-point Convert to Single from Long)*.
R-type, RV64F.

把寄存器x\[*rs1*\]中的64位二进制补码表示的整数转化为单精度浮点数，再写入f\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1101000   00010   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.s.lu rd, rs1, rs2 f\[rd\] = f32~*u*64~(x\[rs1\])

无符号长整型向单精度浮点转换*(Floating-point Convert to Single from
Unsigned Long)*. R-type, RV64F.

把寄存器x\[*rs1*\]中的64位的无符号整数转化为单精度浮点数，再写入f\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1101000   00011   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.s.w rd, rs1, rs2 f\[rd\] = f32~*s*32~(x\[rs1\])

字向单精度浮点转换*(Floating-point Convert to Single from Word)*.
R-type, RV32F and RV64F.

把寄存器x\[*rs1*\]中的32位二进制补码表示的整数转化为单精度浮点数，再写入f\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1101000   00000   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.s.wu rd, rs1, rs2 f\[rd\] = f32~*u*32~(x\[rs1\])

无符号字向单精度浮点转换*(Floating-point Convert to Single from Unsigned
Word)*. R-type, RV32F and RV64F.

把寄存器x\[*rs1*\]中的32位无符号整数转化为单精度浮点数，再写入f\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1101000   00001   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.w.d rd, rs1, rs2 x\[rd\] = sext(s32~*f*64~(f\[rs1\]))

双精度浮点向字转换*(Floating-point Convert to Word from Double)*.
R-type, RV32D and RV64D.

把寄存器f\[*rs1*\]中的双精度浮点数转化为32位二进制补码表示的整数，再写入x\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1100001   00000   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.wu.d rd, rs1, rs2 x\[rd\] = sext(u32~*f*64~(f\[rs1\]))

双精度浮点向无符号字转换*(Floating-point Convert to Unsigned Word from
Double)*. R-type, RV32D and RV64D.

把寄存器f\[*rs1*\]中的双精度浮点数转化为32位无符号整数，再写入x\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1100001   00001   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.w.s rd, rs1, rs2 x\[rd\] = sext(s32~*f*32~(f\[rs1\]))

单精度浮点向字转换*(Floating-point Convert to Word from Single)*.
R-type, RV32F and RV64F.

把寄存器f\[*rs1*\]中的单精度浮点数转化为32位二进制补码表示的整数，再写入x\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1100000   00000   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fcvt.wu.s rd, rs1, rs2 x\[rd\] = sext(u32~*f*32~(f\[rs1\]))

单精度浮点向无符号字转换*(Floating-point Convert to Unsigned Word from
Single)*. R-type, RV32F and RV64F.

把寄存器f\[*rs1*\]中的单精度浮点数转化为32位无符号整数，再写入x\[*rd*\]中。

  --------- ------- ----- ---- ---- ---------
  1100000   00001   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fdiv.d rd, rs1, rs2 f\[rd\] = f\[rs1\] ÷ f\[rs2\]

双精度浮点除法*(Floating-point Divide, Double-Precision)*. R-type, RV32D
and RV64D.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数相除，并将舍入后的商写入f\[*rd*\]。

  --------- ----- ----- ---- ---- ---------
  0001101   rs2   rs1   rm   rd   1010011
  --------- ----- ----- ---- ---- ---------

fdiv.s rd, rs1, rs2 f\[rd\] = f\[rs1\] ÷ f\[rs2\]

单精度浮点除法*(Floating-point Divide, Single-Precision)*. R-type, RV32F
and RV64F.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数相除，并将舍入后的商写入f\[*rd*\]。

  --------- ----- ----- ---- ---- ---------
  0001100   rs2   rs1   rm   rd   1010011
  --------- ----- ----- ---- ---- ---------

fence pred, succ Fence(pred, succ)

同步内存和I/O*(Fence Memory and I/O)*. I-type, RV32I and RV64I.

在后续指令中的内存和I/O访问对外部（例如其他线程）可见之前，使这条指令之前的内存及I/O访问对外部可见。比特中的第3,2,1和0位分别对应于设备输入，设备输出，内存读写。例如**fence**
r, rw，将前面读取与后面的读取和写入排序，使用*pred* = 0010和*succ* =
0011进行编码。如果省略了参数，则表示**fence** iorw,
iorw，即对所有访存请求进行排序。

  ------ ------ ------ ------- ----- ------- ---------
  0000   pred   succ   00000   000   00000   0001111
  ------ ------ ------ ------- ----- ------- ---------

fence.i Fence(Store, Fetch)

同步指令流*(Fence Instruction Stream)*. I-type, RV32I and RV64I.

使对内存指令区域的读写，对后续取指令可见。

  -------------- ------- ----- ------- ---------
  000000000000   00000   001   00000   0001111
  -------------- ------- ----- ------- ---------

feq.d rd, rs1, rs2 x\[rd\] = f\[rs1\] == f\[rs2\]

双精度浮点相等*(Floating-point Equals, Double-Precision)*. R-type, RV32D
and RV64D.

若寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数相等，则在x\[*rd*\]中写入1，反之写0。

  --------- ----- ----- ----- ---- ---------
  1010001   rs2   rs1   010   rd   1010011
  --------- ----- ----- ----- ---- ---------

feq.s rd, rs1, rs2 x\[rd\] = f\[rs1\] == f\[rs2\]

单精度浮点相等*(Floating-point Equals, Single-Precision)*. R-type, RV32F
and RV64F.

若寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数相等，则在x\[*rd*\]中写入1，反之写0。

  --------- ----- ----- ----- ---- ---------
  1010000   rs2   rs1   010   rd   1010011
  --------- ----- ----- ----- ---- ---------

fld rd, offset(rs1) f\[rd\] = M\[x\[rs1\] + sext(offset)\]\[63:0\]

浮点加载双字*(Floating-point Load Doubleword)*. I-type, RV32D and RV64D.

从内存地址x\[*rs1*\] +
*sign-extend*(*offset*)中取双精度浮点数，并写入f\[*rd*\]。

压缩形式：**c.fldsp** rd, offset; **c.fld** rd, offset(rs1)

  ---------------- ----- ----- ---- ---------
  offset\[11:0\]   rs1   011   rd   0000111
  ---------------- ----- ----- ---- ---------

fle.d rd, rs1, rs2 x\[rd\] = f\[rs1\] ≤ f\[rs2\]

双精度浮点小于等于*(Floating-point Less Than or Equal,
Double-Precision)*. R-type, RV32D and RV64D.

若寄存器f\[*rs1*\]中的双精度浮点数小于等于f\[*rs2*\]中的双精度浮点数，则在x\[*rd*\]中写入1，反之写0。

  --------- ----- ----- ----- ---- ---------
  1010001   rs2   rs1   000   rd   1010011
  --------- ----- ----- ----- ---- ---------

fle.s rd, rs1, rs2 x\[rd\] = f\[rs1\] ≤ f\[rs2\]

单精度浮点小于等于*(Floating-point Less Than or Equal,
Single-Precision)*. R-type, RV32F and RV64F.

若寄存器f\[*rs1*\]中的单精度浮点数小于等于f\[*rs2*\]中的单精度浮点数，则在x\[*rd*\]中写入1，反之写0。

  --------- ----- ----- ----- ---- ---------
  1010000   rs2   rs1   000   rd   1010011
  --------- ----- ----- ----- ---- ---------

fle.d rd, rs1, rs2 x\[rd\] = f\[rs1\] \< f\[rs2\]

双精度浮点小于 *(Floating-point Less Than, Double-Precision)*. R-type,
RV32D and RV64D.

若寄存器f\[*rs1*\]中的双精度浮点数小于f\[*rs2*\]中的双精度浮点数，则在x\[*rd*\]中写入1，反之写0。

  --------- ----- ----- ----- ---- ---------
  1010001   rs2   rs1   001   rd   1010011
  --------- ----- ----- ----- ---- ---------

fle.s rd, rs1, rs2 x\[rd\] = f\[rs1\] \< f\[rs2\]

单精度浮点小于 *(Floating-point Less Than, Single-Precision)*. R-type,
RV32F and RV64F.

若寄存器f\[*rs1*\]中的单精度浮点数小于f\[*rs2*\]中的单精度浮点数，则在x\[*rd*\]中写入1，反之写0。

  --------- ----- ----- ----- ---- ---------
  1010000   rs2   rs1   001   rd   1010011
  --------- ----- ----- ----- ---- ---------

flw rd, offset(rs1) f\[rd\] = M\[x\[rs1\] + sext(offset)\]\[31:0\]

浮点加载字*(Floating-point Load Word)*. I-type, RV32F and RV64F.

从内存地址x\[*rs1*\] +
*sign-extend*(*offset*)中取单精度浮点数，并写入f\[*rd*\]。

压缩形式：**c.flwsp** rd, offset; **c.flw** rd, offset(rs1)

  ---------------- ----- ----- ---- ---------
  offset\[11:0\]   rs1   010   rd   0000111
  ---------------- ----- ----- ---- ---------

fmadd.d rd, rs1, rs2, rs3 f\[rd\] = f\[rs1\]×f\[rs2\]+f\[rs3\]

双精度浮点乘加*(Floating-point Fused Multiply-Add, Double-Precision)*.
R4-type, RV32D and RV64D.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数相乘，并将未舍入的积和寄存器f\[*rs3*\]中的双精度浮点数相加，将舍入后的双精度浮点数写入f\[*rd*\]。

  ----- ---- ----- ----- ---- ---- ---------
  rs3   01   rs2   rs1   rm   rd   1000011
  ----- ---- ----- ----- ---- ---- ---------

fmadd.s rd, rs1, rs2, rs3 f\[rd\] = f\[rs1\]×f\[rs2\]+f\[rs3\]

单精度浮点乘加*(Floating-point Fused Multiply-Add, Single-Precision)*.
R4-type, RV32F and RV64F.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数相乘，并将未舍入的积和寄存器f\[*rs3*\]中的单精度浮点数相加，将舍入后的单精度浮点数写入f\[*rd*\]。

  ----- ---- ----- ----- ---- ---- ---------
  rs3   00   rs2   rs1   rm   rd   1000011
  ----- ---- ----- ----- ---- ---- ---------

fmax.d rd, rs1, rs2 f\[rd\] = max(f\[rs1\], f\[rs2\])

双精度浮点最大值*(Floating-point Maximum, Double-Precision)*. R-type,
RV32D and RV64D.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数中的较大值写入f\[*rd*\]中。

  --------- ----- ----- ----- ---- ---------
  0010101   rs2   rs1   001   rd   1010011
  --------- ----- ----- ----- ---- ---------

fmax.s rd, rs1, rs2 f\[rd\] = max(f\[rs1\], f\[rs2\])

单精度浮点最大值*(Floating-point Maximum, Single-Precision)*. R-type,
RV32F and RV64F.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数中的较大值写入f\[*rd*\]中。

  --------- ----- ----- ----- ---- ---------
  0010100   rs2   rs1   001   rd   1010011
  --------- ----- ----- ----- ---- ---------

fmin.d rd, rs1, rs2 f\[rd\] = min(f\[rs1\], f\[rs2\])

双精度浮点最小值*(Floating-point Minimum, Double-Precision)*. R-type,
RV32D and RV64D.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数中的较小值写入f\[*rd*\]中。

  --------- ----- ----- ----- ---- ---------
  0010101   rs2   rs1   000   rd   1010011
  --------- ----- ----- ----- ---- ---------

fmin.s rd, rs1, rs2 f\[rd\] = min(f\[rs1\], f\[rs2\])

单精度浮点最小值*(Floating-point Minimum, Single-Precision)*. R-type,
RV32F and RV64F.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数中的较小值写入f\[*rd*\]中。

  --------- ----- ----- ----- ---- ---------
  0010100   rs2   rs1   000   rd   1010011
  --------- ----- ----- ----- ---- ---------

fmsub.d rd, rs1, rs2, rs3 f\[rd\] = f\[rs1\]×f\[rs2\]-f\[rs3\]

双精度浮点乘减*(Floating-point Fused Multiply-Subtract,
Double-Precision)*. R4-type, RV32D and RV64D.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数相乘，并将未舍入的积减去寄存器f\[*rs3*\]中的双精度浮点数，将舍入后的双精度浮点数写入f\[*rd*\]。

  ----- ---- ----- ----- ---- ---- ---------
  rs3   01   rs2   rs1   rm   rd   1000111
  ----- ---- ----- ----- ---- ---- ---------

fmsub.s rd, rs1, rs2, rs3 f\[rd\] = f\[rs1\]×f\[rs2\]-f\[rs3\]

单精度浮点乘减*(Floating-point Fused Multiply-Subtarct,
Single-Precision)*. R4-type, RV32F and RV64F.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数相乘，并将未舍入的积减去寄存器f\[*rs3*\]中的单精度浮点数，将舍入后的单精度浮点数写入f\[*rd*\]。

  ----- ---- ----- ----- ---- ---- ---------
  rs3   00   rs2   rs1   rm   rd   1000111
  ----- ---- ----- ----- ---- ---- ---------

fmul.d rd, rs1, rs2 f\[rd\] = f\[rs1\] × f\[rs2\]

双精度浮点乘*(Floating-point Multiply, Double-Precision)*. R-type, RV32D
and RV64D.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数相乘，将舍入后的双精度结果写入f\[*rd*\]中。

  --------- ----- ----- ---- ---- ---------
  0001001   rs2   rs1   rm   rd   1010011
  --------- ----- ----- ---- ---- ---------

fmul.s rd, rs1, rs2 f\[rd\] = f\[rs1\] × f\[rs2\]

单精度浮点乘*(Floating-point Multiply, Single-Precision)*. R-type, RV32F
and RV64F.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数相乘，将舍入后的单精度结果写入f\[*rd*\]中。

  --------- ----- ----- ---- ---- ---------
  0001000   rs2   rs1   rm   rd   1010011
  --------- ----- ----- ---- ---- ---------

fmv.d rd, rs1 f\[rd\] = f\[rs1\]

双精度浮点移动 *(Floating-point Move)*. 伪指令(Pesudoinstruction), RV32D
and RV64D.

把寄存器f\[*rs1*\]中的双精度浮点数复制到f\[*rd*\]中，等同于**fsgnj.d**
rd, rs1, rs1.

fmv.d.x rd, rs1, rs2 f\[rd\] = x\[rs1\]\[63:0\]

双精度浮点移动*(Floating-point Move Doubleword from Integer)*. R-type,
RV64D.

把寄存器x\[*rs1*\]中的双精度浮点数复制到f\[*rd*\]中。

  --------- ------- ----- ----- ---- ---------
  1111001   00000   rs1   000   rd   1010011
  --------- ------- ----- ----- ---- ---------

fmv.s rd, rs1 f\[rd\] = f\[rs1\]

单精度浮点移动 *(Floating-point Move)*. 伪指令(Pesudoinstruction), RV32F
and RV64F.

把寄存器f\[*rs1*\]中的单精度浮点数复制到f\[*rd*\]中，等同于**fsgnj.s**
rd, rs1, rs1.

fmv.d.x rd, rs1, rs2 f\[rd\] = x\[rs1\]\[31:0\]

单精度浮点移动*(Floating-point Move Word from Integer)*. R-type, RV32F
and RV64F.

把寄存器x\[*rs1*\]中的单精度浮点数复制到f\[*rd*\]中。

  --------- ------- ----- ----- ---- ---------
  1111000   00000   rs1   000   rd   1010011
  --------- ------- ----- ----- ---- ---------

fmv.x.d rd, rs1, rs2 x\[rd\] = f\[rs1\]\[63:0\]

双精度浮点移动*(Floating-point Move Doubleword to Integer)*. R-type,
RV64D.

把寄存器f\[*rs1*\]中的双精度浮点数复制到x\[*rd*\]中。

  --------- ------- ----- ----- ---- ---------
  1110001   00000   rs1   000   rd   1010011
  --------- ------- ----- ----- ---- ---------

fmv.x.w rd, rs1, rs2 x\[rd\] = sext(f\[rs1\]\[31:0\])

单精度浮点移动*(Floating-point Move Word to Integer)*. R-type, RV32F and
RV64F.

把寄存器f\[*rs1*\]中的单精度浮点数复制到x\[*rd*\]中，对于RV64F，将结果进行符号扩展。

  --------- ------- ----- ----- ---- ---------
  1110000   00000   rs1   000   rd   1010011
  --------- ------- ----- ----- ---- ---------

fneg.d rd, rs1 f\[rd\] = -f\[rs1\]

双精度浮点取反 *(Floating-point Negate)*. 伪指令(Pesudoinstruction),
RV32D and RV64D.

把寄存器f\[*rs1*\]中的双精度浮点数取反后写入f\[*rd*\]中，等同于**fsgnjn.d**
rd, rs1, rs1.

fneg.s rd, rs1 f\[rd\] = -f\[rs1\]

单精度浮点取反 *(Floating-point Negate)*. 伪指令(Pesudoinstruction),
RV32F and RV64F.

把寄存器f\[*rs1*\]中的单精度浮点数取反后写入f\[*rd*\]中，等同于**fsgnjn.s**
rd, rs1, rs1.

fnmadd.d rd, rs1, rs2, rs3 f\[rd\] = f\[rs1\]×f\[rs2\]+f\[rs3\]

双精度浮点乘取反加*(Floating-point Fused Negative Multiply-Add,
Double-Precision)*. R4-type, RV32D and RV64D.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数相乘，将结果取反，并将未舍入的积和寄存器f\[*rs3*\]中的双精度浮点数相加，将舍入后的双精度浮点数写入f\[*rd*\]。

  ----- ---- ----- ----- ---- ---- ---------
  rs3   01   rs2   rs1   rm   rd   1001111
  ----- ---- ----- ----- ---- ---- ---------

fnmadd.s rd, rs1, rs2, rs3 f\[rd\] = -f\[rs1\]\_f\[rs2\]-f\[rs3\]

单精度浮点乘取反加*(Floating-point Fused Negative Multiply-Add,
Single-Precision)*. R4-type, RV32F and RV64F.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数相乘，将结果取反，并将未舍入的积和寄存器f\[*rs3*\]中的单精度浮点数相加，将舍入后的单精度浮点数写入f\[*rd*\]。

  ----- ---- ----- ----- ---- ---- ---------
  rs3   00   rs2   rs1   rm   rd   1001111
  ----- ---- ----- ----- ---- ---- ---------

fnmsub.d rd, rs1, rs2, rs3 f\[rd\] = -f\[rs1\]\_f\[rs2\]+f\[rs3\]

双精度浮点乘取反减*(Floating-point Fused Negative Multiply-Subtract,
Double-Precision)*. R4-type, RV32D and RV64D.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数相乘，将结果取反，并将未舍入的积减去寄存器f\[*rs3*\]中的双精度浮点数，将舍入后的双精度浮点数写入f\[*rd*\]。

  ----- ---- ----- ----- ---- ---- ---------
  rs3   01   rs2   rs1   rm   rd   1001011
  ----- ---- ----- ----- ---- ---- ---------

fnmsub.s rd, rs1, rs2, rs3 f\[rd\] = -f\[rs1\]×f\[rs2\]+f\[rs3\]

单精度浮点乘取反减*(Floating-point Fused Negative Multiply-Subtract,
Single-Precision)*. R4-type, RV32F and RV64F.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数相乘，将结果取反，并将未舍入的积减去寄存器f\[*rs3*\]中的单精度浮点数，将舍入后的单精度浮点数写入f\[*rd*\]。

  ----- ---- ----- ----- ---- ---- ---------
  rs3   00   rs2   rs1   rm   rd   1001011
  ----- ---- ----- ----- ---- ---- ---------

frcsr rd x\[rd\] = CSRs\[fcsr\]

浮点读控制状态寄存器 *(Floating-point Read Control and Status
Register)*. 伪指令(Pseudoinstruction), RV32F and RV64F.

把浮点控制状态寄存器的值写入x\[*rd*\]，等同于**csrrs** rd, fcsr, x0.

frflags rd x\[rd\] = CSRs\[fflags\]

浮点读异常标志 *(Floating-point Read Exception Flags)*.
伪指令(Pseudoinstruction), RV32F and RV64F.

把浮点异常标志的值写入x\[*rd*\]，等同于**csrrs** rd, fflags, x0.

frrm rd x\[rd\] = CSRs\[frm\]

浮点读舍入模式 *(Floating-point Read Rounding Mode)*.
伪指令(Pseudoinstruction), RV32F and RV64F.

把浮点舍入模式的值写入x\[*rd*\]，等同于**csrrs** rd, frm, x0.

fscsr rd, rs1 t = CSRs\[fcsr\]; CSRs\[fcsr\] = x\[rs1\]; x\[rd\] = t

浮点换出控制状态寄存器 *(Floating-point Swap Control and Status
Register)*. 伪指令(Pseudoinstruction), RV32F and RV64F.

把寄存器x\[*rs1*\]的值写入浮点控制状态寄存器，并将浮点控制状态寄存器的原值写入x\[*rd*\]，等同于**csrrw**
rd, fcsr, rs1。*rd*默认为x0。

fsd rs2, offset(rs1) M\[x\[rs1\] + sext(offset)\] = f\[rs2\]\[63:0\]

双精度浮点存储*(Floating-point Store Doubleword)*. S-type, RV32D and
RV64D.

将寄存器f\[*rs2*\]中的双精度浮点数存入内存地址x\[*rs1*\] +
*sign-extend*(*offset*)中。

压缩形式：**c.fsdsp** rs2, offset; **c.fsd** rs2, offset(rs1)

  ---------------- ----- ----- ----- --------------- ---------
  offset\[11:5\]   rs2   rs1   011   offset\[4:0\]   0100111
  ---------------- ----- ----- ----- --------------- ---------

fsflags rd, rs1 t = CSRs\[fflags\]; CSRs\[fflags\] = x\[rs1\]; x\[rd\] =
t

浮点换出异常标志 *(Floating-point Swap Exception Flags)*.
伪指令(Pseudoinstruction), RV32F and RV64F.

把寄存器x\[*rs1*\]的值写入浮点异常标志寄存器，并将浮点异常标志寄存器的原值写入x\[*rd*\]，等同于**csrrw**
rd, fflags, rs1。*rd*默认为x0。

fsgnj.d rd, rs1, rs2 f\[rd\] = {f\[rs2\]\[63\], f\[rs1\]\[62:0\]}

双精度浮点符号注入*(Floating-point Sign Inject, Double-Precision)*.
R-type, RV32D and RV64D.

用f\[*rs1*\]指数和有效数以及f\[*rs2*\]的符号的符号位，来构造一个新的双精度浮点数，并将其写入f\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0010001   rs2   rs1   000   rd   1010011
  --------- ----- ----- ----- ---- ---------

fsgnj.s rd, rs1, rs2 f\[rd\] = {f\[rs2\]\[31\], f\[rs1\]\[30:0\]}

单精度浮点符号注入*(Floating-point Sign Inject, Single-Precision)*.
R-type, RV32F and RV64F.

用f\[*rs1*\]指数和有效数以及f\[*rs2*\]的符号的符号位，来构造一个新的单精度浮点数，并将其写入f\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0010000   rs2   rs1   000   rd   1010011
  --------- ----- ----- ----- ---- ---------

fsgnjn.d rd, rs1, rs2 f\[rd\] = {\~f\[rs2\]\[63\], f\[rs1\]\[62:0\]}

双精度浮点符号取反注入*(Floating-point Sign Inject-Negate,
Double-Precision)*. R-type, RV32D and RV64D.

用f\[*rs1*\]指数和有效数以及f\[*rs2*\]的符号的符号位取反，来构造一个新的双精度浮点数，并将其写入f\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0010001   rs2   rs1   001   rd   1010011
  --------- ----- ----- ----- ---- ---------

fsgnjn.s rd, rs1, rs2 f\[rd\] = {\~f\[rs2\]\[31\], f\[rs1\]\[30:0\]}

单精度浮点符号取反注入*(Floating-point Sign Inject-Negate,
Single-Precision)*. R-type, RV32F and RV64F.

用f\[*rs1*\]指数和有效数以及f\[*rs2*\]的符号的符号位取反，来构造一个新的单精度浮点数，并将其写入f\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0010000   rs2   rs1   001   rd   1010011
  --------- ----- ----- ----- ---- ---------

fsgnjx.d rd, rs1, rs2 f\[rd\] = {f\[rs1\]\[63\] \^ f\[rs2\]\[63\],
f\[rs1\]\[62:0\]}

双精度浮点符号异或注入*(Floating-point Sign Inject-XOR,
Double-Precision)*. R-type, RV32D and RV64D.

用f\[*rs1*\]指数和有效数以及f\[*rs1*\]和f\[*rs2*\]的符号的符号位异或，来构造一个新的双精度浮点数，并将其写入f\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0010001   rs2   rs1   010   rd   1010011
  --------- ----- ----- ----- ---- ---------

fsgnjx.s rd, rs1, rs2 f\[rd\] = {f\[rs1\]\[31\] \^ f\[rs2\]\[31\],
f\[rs1\]\[30:0\]}

单精度浮点符号异或注入*(Floating-point Sign Inject-XOR,
Single-Precision)*. R-type, RV32F and RV64F.

用f\[*rs1*\]指数和有效数以及f\[*rs1*\]和f\[*rs2*\]的符号的符号位异或，来构造一个新的单精度浮点数，并将其写入f\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0010000   rs2   rs1   010   rd   1010011
  --------- ----- ----- ----- ---- ---------

fsqrt.d rd, rs1, rs2 f\[rd\] =$\sqrt{\ f\lbrack rs1\rbrack}$

双精度浮点平方根*(Floating-point Square Root, Double-Precision)*.
R-type, RV32D and RV64D.

将f\[*rs1*\]中的双精度浮点数的平方根舍入和写入f\[*rd*\]。

  --------- ------- ----- ---- ---- ---------
  0101101   00000   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fsqrt.s rd, rs1, rs2 f\[rd\] =$\sqrt{\ f\lbrack rs1\rbrack}$

单精度浮点平方根*(Floating-point Square Root, Single-Precision)*.
R-type, RV32F and RV64F.

将f\[*rs1*\]中的单精度浮点数的平方根舍入和写入f\[*rd*\]。

  --------- ------- ----- ---- ---- ---------
  0101100   00000   rs1   rm   rd   1010011
  --------- ------- ----- ---- ---- ---------

fsrm rd, rs1 t = CSRs\[frm\]; CSRs\[frm\] = x\[rs1\]; x\[rd\] = t

浮点换出舍入模式 *(Floating-point Swap Rounding Mode)*.
伪指令(Pseudoinstruction), RV32F and RV64F.

把寄存器x\[*rs1*\]的值写入浮点舍入模式寄存器，并将浮点舍入模式寄存器的原值写入x\[*rd*\]，等同于**csrrw**
rd, frm, rs1。*rd*默认为x0。

fsub.d rd, rs1, rs2 f\[rd\] = f\[rs1\] - f\[rs2\]

双精度浮点减*(Floating-point Subtract, Double-Precision)*. R-type, RV32D
and RV64D.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的双精度浮点数相减，并将舍入后的差写入f\[*rd*\]。

  --------- ----- ----- ---- ---- ---------
  0000101   rs2   rs1   rm   rd   1010011
  --------- ----- ----- ---- ---- ---------

fsub.s rd, rs1, rs2 f\[rd\] = f\[rs1\] - f\[rs2\]

单精度浮点减*(Floating-point Subtract, Single-Precision)*. R-type, RV32F
and RV64F.

把寄存器f\[*rs1*\]和f\[*rs2*\]中的单精度浮点数相减，并将舍入后的差写入f\[*rd*\]。

  --------- ----- ----- ---- ---- ---------
  0000100   rs2   rs1   rm   rd   1010011
  --------- ----- ----- ---- ---- ---------

fsw rs2, offset(rs1) M\[x\[rs1\] + sext(offset)\] = f\[rs2\]\[31:0\]

单精度浮点存储*(Floating-point Store Word)*. S-type, RV32F and RV64F.

将寄存器f\[*rs2*\]中的单精度浮点数存入内存地址x\[*rs1*\] +
*sign-extend*(*offset*)中。

压缩形式：**c.fswsp** rs2, offset; **c.fsw** rs2, offset(rs1)

  ---------------- ----- ----- ----- --------------- ---------
  offset\[11:5\]   rs2   rs1   010   offset\[4:0\]   0100111
  ---------------- ----- ----- ----- --------------- ---------

j offset pc += sext(offset)

跳转 *(Jump)*. 伪指令(Pseudoinstruction), RV32I and RV64I.

把*pc*设置为当前值加上符号位扩展的*offset*，等同于**jal** x0, offset.

jal rd, offset x\[rd\] = pc+4; pc += sext(offset)

跳转并链接 *(Jump and Link)*. J-type, RV32I and RV64I.

把下一条指令的地址(*pc+4*)，然后把*pc*设置为当前值加上符号位扩展的*offset*。*rd*默认为x1。

压缩形式：**c.j** offset; **c.jal** offset

  ------------------------------- ---- ---------
  offset\[20\|10:1\|11\|19:12\]   rd   1101111
  ------------------------------- ---- ---------

jalr rd, offset(rs1) t =pc+4; pc=(x\[rs1\]+sext(offset))&\~1; x\[rd\]=t

跳转并寄存器链接 *(Jump and Link Register)*. I-type, RV32I and RV64I.

把*pc*设置为x\[*rs1*\] +
*sign-extend*(*offset*)，把计算出的地址的最低有效位设为0，并将原*pc+4*的值写入f\[*rd*\]。*rd*默认为x1。

压缩形式：**c.jr** rs1; **c.jalr** rs1

  ---------------- ----- ----- ---- ---------
  offset\[11:0\]   rs1   010   rd   1100111
  ---------------- ----- ----- ---- ---------

jr rs1 pc = x\[rs1\]

寄存器跳转 *(Jump Register)*. 伪指令(Pseudoinstruction), RV32I and
RV64I.

把*pc*设置为x\[*rs1*\]，等同于**jalr** x0, 0(rs1)。

la rd, symbol x\[rd\] = &symbol

地址加载 *(Load Address)*. 伪指令(Pseudoinstruction), RV32I and RV64I.

将*symbol*的地址加载到x\[*rd*\]中。当编译位置无关的代码时，它会被扩展为对全局偏移量表(Global
Offset Table)的加载。对于RV32I，等同于执行**auipc** rd,
offsetHi，然后是**lw** rd， offsetLo(rd);对于RV64I，则等同于**auipc**
rd，offsetHi和**ld** rd,
offsetLo(rd)。如果offset过大，开始的算加载地址的指令会变成两条，先是**auipc**
rd, offsetHi然后是**addi** rd, rd, offsetLo。

lb rd, offset(rs1) x\[rd\] = sext(M\[x\[rs1\] + sext(offset)\]\[7:0\])

字节加载 *(Load Byte)*. I-type, RV32I and RV64I.

从地址x\[*rs1*\] +
*sign-extend*(*offset*)读取一个字节，经符号位扩展后写入x\[*rd*\]。

  ---------------- ----- ----- ---- ---------
  offset\[11:0\]   rs1   000   rd   0000011
  ---------------- ----- ----- ---- ---------

lbu rd, offset(rs1) x\[rd\] = M\[x\[rs1\] + sext(offset)\]\[7:0\]

无符号字节加载 *(Load Byte, Unsigned)*. I-type, RV32I and RV64I.

从地址x\[*rs1*\] +
*sign-extend*(*offset*)读取一个字节，经零扩展后写入x\[*rd*\]。

  ---------------- ----- ----- ---- ---------
  offset\[11:0\]   rs1   100   rd   0000011
  ---------------- ----- ----- ---- ---------

ld rd, offset(rs1) x\[rd\] = M\[x\[rs1\] + sext(offset)\]\[63:0\]

双字加载 *(Load Doubleword)*. I-type, RV32I and RV64I.

从地址x\[*rs1*\] + *sign-extend*(*offset*)读取八个字节，写入x\[*rd*\]。

压缩形式：**c.ldsp** rd, offset; **c.ld** rd, offset(rs1)

  ---------------- ----- ----- ---- ---------
  offset\[11:0\]   rs1   011   rd   0000011
  ---------------- ----- ----- ---- ---------

lh rd, offset(rs1) x\[rd\] = sext(M\[x\[rs1\] + sext(offset)\]\[15:0\])

半字加载 *(Load Halfword)*. I-type, RV32I and RV64I.

从地址x\[*rs1*\] +
*sign-extend*(*offset*)读取两个字节，经符号位扩展后写入x\[*rd*\]。

  ---------------- ----- ----- ---- ---------
  offset\[11:0\]   rs1   001   rd   0000011
  ---------------- ----- ----- ---- ---------

lhu rd, offset(rs1) x\[rd\] = M\[x\[rs1\] + sext(offset)\]\[15:0\]

无符号半字加载 *(Load Halfword, Unsigned)*. I-type, RV32I and RV64I.

从地址x\[*rs1*\] +
*sign-extend*(*offset*)读取两个字节，经零扩展后写入x\[*rd*\]。

  ---------------- ----- ----- ---- ---------
  offset\[11:0\]   rs1   101   rd   0000011
  ---------------- ----- ----- ---- ---------

li rd, immediate x\[rd\] = immediate

立即数加载 *(Load Immediate)*. 伪指令(Pseudoinstruction), RV32I and
RV64I.

使用尽可能少的指令将常量加载到x\[*rd*\]中。在RV32I中，它等同于执行**lui**和/或**addi**；对于RV64I，会扩展为这种指令序列**lui,
addi, slli, addi, slli, addi ,slli, addi。**

lla rd, symbol x\[rd\] = &symbol

本地地址加载 *(Load Local Address)*. 伪指令(Pseudoinstruction), RV32I
and RV64I.

将*symbol*的地址加载到x\[*rd*\]中。等同于执行**auipc** rd,
offsetHi，然后是**addi** rd, rd, offsetLo。

lr.d rd, (rs1) x\[rd\] = LoadReserved64(M\[x\[rs1\]\])

加载保留双字*(Load-Reserved Doubleword)*. R-type, RV64A.

从内存中地址为x\[*rs1*\]中加载八个字节，写入x\[*rd*\]，并对这个内存双字注册保留。

  ------- ---- ---- ------- ----- ----- ---- ---------
  00010   aq   rl   00000   rs1   011   rd   0101111
  ------- ---- ---- ------- ----- ----- ---- ---------

lr.w rd, (rs1) x\[rd\] = LoadReserved32(M\[x\[rs1\]\])

加载保留字*(Load-Reserved Word)*. R-type, RV32A and RV64A.

从内存中地址为x\[*rs1*\]中加载四个字节，符号位扩展后写入x\[*rd*\]，并对这个内存字注册保留。

  ------- ---- ---- ------- ----- ----- ---- ---------
  00010   aq   rl   00000   rs1   010   rd   0101111
  ------- ---- ---- ------- ----- ----- ---- ---------

lw rd, offset(rs1) x\[rd\] = sext(M\[x\[rs1\] + sext(offset)\]\[31:0\])

字加载 *(Load Word)*. I-type, RV32I and RV64I.

从地址x\[*rs1*\] +
*sign-extend*(*offset*)读取四个字节，写入x\[*rd*\]。对于RV64I，结果要进行符号位扩展。

压缩形式：**c.lwsp** rd, offset; **c.lw** rd, offset(rs1)

  ---------------- ----- ----- ---- ---------
  offset\[11:0\]   rs1   010   rd   0000011
  ---------------- ----- ----- ---- ---------

lwu rd, offset(rs1) x\[rd\] = M\[x\[rs1\] + sext(offset)\]\[31:0\]

无符号字加载 *(Load Word, Unsigned)*. I-type, RV64I.

从地址x\[*rs1*\] +
*sign-extend*(*offset*)读取四个字节，零扩展后写入x\[*rd*\]。

  ---------------- ----- ----- ---- ---------
  offset\[11:0\]   rs1   110   rd   0000011
  ---------------- ----- ----- ---- ---------

lui rd, immediate x\[rd\] = sext(immediate\[31:12\] \<\< 12)

高位立即数加载 *(Load Upper Immediate)*. U-type, RV32I and RV64I.

将符号位扩展的20位立即数*immediate*左移12位，并将低12位置零，写入x\[*rd*\]中。

压缩形式：**c.lui** rd, imm

  -------------------- ---- ---------
  immediate\[31:12\]   rd   0110111
  -------------------- ---- ---------

mret ExceptionReturn(Machine)

机器模式异常返回*(Machine-mode Exception Return)*. R-type, RV32I and
RV64I特权架构

从机器模式异常处理程序返回。将*pc*设置为CSRs\[mepc\],
将特权级设置成CSRs\[mstatus\].MPP,
CSRs\[mstatus\].MIE置成CSRs\[mstatus\].MPIE,
并且将CSRs\[mstatus\].MPIE为1;并且，如果支持用户模式，则将CSR
\[mstatus\].MPP设置为0。

  --------- ------- ------- ----- ------- ---------
  0011000   00010   00000   000   00000   1110011
  --------- ------- ------- ----- ------- ---------

mul rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = x\lbrack rs1\rbrack \times x\lbrack rs2\rbrack$

乘*(Multiply)*. R-type, RV32M and RV64M.

把寄存器x\[*rs2*\]乘到寄存器x\[*rs1*\]上，乘积写入x\[*rd*\]。忽略算术溢出。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   000   rd   0110011
  --------- ----- ----- ----- ---- ---------

mulh rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = \left( x\lbrack rs1{\rbrack\ }_{s} \times_{s}x\left\lbrack rs2 \right\rbrack \right) \gg_{s}\text{XLEN}$

高位乘*(Multiply High)*. R-type, RV32M and RV64M.

把寄存器x\[*rs2*\]乘到寄存器x\[*rs1*\]上，都视为2的补码，将乘积的高位写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   001   rd   0110011
  --------- ----- ----- ----- ---- ---------

mulhsu rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = \left( x\lbrack rs1{\rbrack\ }_{s} \times_{u}x\left\lbrack rs2 \right\rbrack \right) \gg_{s}\text{XLEN}$

高位有符号-无符号乘*(Multiply High Signed-Unsigned)*. R-type, RV32M and
RV64M.

把寄存器x\[*rs2*\]乘到寄存器x\[*rs1*\]上，x\[*rs1*\]为2的补码，x\[*rs2*\]为无符号数，将乘积的高位写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   010   rd   0110011
  --------- ----- ----- ----- ---- ---------

mulhu rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = \left( x\lbrack rs1{\rbrack\ }_{u} \times_{u}x\left\lbrack rs2 \right\rbrack \right) \gg_{u}\text{XLEN}$

高位无符号乘*(Multiply High Unsigned)*. R-type, RV32M and RV64M.

把寄存器x\[*rs2*\]乘到寄存器x\[*rs1*\]上，x\[*rs1*\]、x\[*rs2*\]均为无符号数，将乘积的高位写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   011   rd   0110011
  --------- ----- ----- ----- ---- ---------

mulw rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = sext(\left( x\left\lbrack rs1 \right\rbrack \times x\left\lbrack rs2 \right\rbrack \right)\left\lbrack 31:0 \right\rbrack)$

乘字*(Multiply Word)*. R-type, RV64M only.

把寄存器x\[*rs2*\]乘到寄存器x\[*rs1*\]上，乘积截为32位，进行有符号扩展后写入x\[*rd*\]。忽略算术溢出。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   000   rd   0111011
  --------- ----- ----- ----- ---- ---------

mv rd, rs1 $x\left\lbrack \text{rd} \right\rbrack = x\lbrack rs1\rbrack$

移动*(Move)*. 伪指令(Pseudoinstruction), RV32I and RV64I.

把寄存器x\[*rs1*\]复制到x\[*rd*\]中。实际被扩展为**addi** rd, rs1, 0

neg rd, rs2
$x\left\lbrack \text{rd} \right\rbrack = - x\lbrack rs2\rbrack$

取反*(Negate)*. 伪指令(Pseudoinstruction), RV32I and RV64I.

把寄存器x\[*rs2*\]的二进制补码写入x\[*rd*\]。实际被扩展为**sub** rd, x0,
rs2。

negw rd, rs2
$x\left\lbrack \text{rd} \right\rbrack = sext(\left( - x\left\lbrack rs2 \right\rbrack \right)\lbrack 31:0\rbrack)$

取非字*(Negate Word)*. 伪指令(Pseudoinstruction), RV64I only.

计算寄存器x\[*rs2*\]对于2的补码，结果截为32位，进行符号扩展后写入x\[*rd*\]。实际被扩展为**subw**
rd, x0, rs2。

nop $\text{Nothing}$

无操作*(No operation)*. 伪指令(Pseudoinstruction), RV32I and RV64I.

将*pc*推进到下一条指令。实际被扩展为**addi** x0, x0, 0。

not rd, rs1
$x\left\lbrack \text{rd} \right\rbrack = \sim x\lbrack rs1\rbrack$

取反*(NOT)*. 伪指令(Pseudoinstruction), RV32I and RV64I.

把寄存器x\[*rs1*\]对于1的补码（即按位取反的值）写入x\[*rd*\]。实际被扩展为**xori**
rd, rs1, -1。

or rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = x\left\lbrack rs1 \right\rbrack\ |\ x\lbrack\text{rs}2\rbrack$

取或*(OR)*. R-type, RV32I and RV64I.

把寄存器x\[*rs1*\]和寄存器x\[*rs2*\]按位取或，结果写入x\[*rd*\]。

压缩形式：**c.or** rd, rs2

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   110   rd   0110011
  --------- ----- ----- ----- ---- ---------

ori rd, rs1, immediate
$x\left\lbrack \text{rd} \right\rbrack = x\left\lbrack rs1 \right\rbrack\ |\ sext(immediate)$

立即数取或*(OR Immediate)*. R-type, RV32I and RV64I.

把寄存器x\[*rs1*\]和有符号扩展的立即数*immediate*按位取或，结果写入x\[*rd*\]。

压缩形式：**c.or** rd, rs2

  ------------------- ----- ----- ----- ---- ---------
  Immediate\[11:0\]   rs2   rs1   110   rd   0010011
  ------------------- ----- ----- ----- ---- ---------

rdcycle rd
$x\left\lbrack \text{rd} \right\rbrack = CSRS\lbrack cycle\rbrack$

读周期计数器*(Read Cycle Counter)*. 伪指令(Pseudoinstruction), RV32I and
RV64I.

把周期数写入x\[*rd*\]。实际被扩展为**csrrs** rd, cycle, x0。

rdcycleh rd
$x\left\lbrack \text{rd} \right\rbrack = CSRs\lbrack cycleh\rbrack$

读周期计数器高位*(Read Cycle Counte High)*. 伪指令(Pseudoinstruction),
RV32I only.

把周期数右移32位后写入x\[*rd*\]。实际被扩展为**csrrs** rd, cycleh, x0。

rdinstret rd
$x\left\lbrack \text{rd} \right\rbrack = CSRs\lbrack instret\rbrack$

读已完成指令计数器*(Read Instruction-Retired Counter)*.
伪指令(Pseudoinstruction), RV32I and RV64I.

把已完成指令数写入x\[*rd*\]。实际被扩展为**csrrs** rd, instret, x0。

rdinstreth rd
$x\left\lbrack \text{rd} \right\rbrack = CSRs\lbrack instreth\rbrack$

读已完成指令计数器高位*(Read Instruction-Retired Counter High)*.
伪指令(Pseudoinstruction), RV32I only.

把已完成指令数右移32位后写入x\[*rd*\]。实际被扩展为**csrrs** rd,
instreth, x0。

rdtime rd
$x\left\lbrack \text{rd} \right\rbrack = CSRs\lbrack time\rbrack$

读取时间*(Read Time)*. 伪指令(Pseudoinstruction), RV32I and RV64I.

把当前时间写入x\[*rd*\]，时间频率与平台相关。实际被扩展为**csrrs** rd,
time, x0。

rdtimeh rd
$x\left\lbrack \text{rd} \right\rbrack = CSRs\lbrack timeh\rbrack$

读取时间高位*(Read Time High)*. 伪指令(Pseudoinstruction), RV32I only.

把当前时间右移32位后写入x\[*rd*\]，时间频率与平台相关。实际被扩展为**csrrs**
rd, timeh, x0。

rem rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = x\left\lbrack rs1 \right\rbrack\ \%_{s}\ x\lbrack rs2\rbrack$

求余数*(Remainder)*. R-type, RV32M and RV64M.

x\[*rs1*\]除以x\[*rs2*\]，向0舍入，都视为2的补码，余数写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   110   rd   0110011
  --------- ----- ----- ----- ---- ---------

remu rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = x\left\lbrack rs1 \right\rbrack\ \%_{u}\ x\lbrack rs2\rbrack$

求无符号数的余数*(Remainder, Unsigned)*. R-type, RV32M and RV64M.

x\[*rs1*\]除以x\[*rs2*\]，向0舍入，都视为无符号数，余数写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   111   rd   0110011
  --------- ----- ----- ----- ---- ---------

remuw rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = sext(x\left\lbrack rs1 \right\rbrack\lbrack 31:0\rbrack\ \%_{u}\ x\lbrack rs2\rbrack\lbrack 31:0\rbrack)$

求无符号数的余数字*(Remainder Word, Unsigned)*. R-type, RV64M only.

x\[*rs1*\]的低32位除以x\[*rs2*\]的低32位，向0舍入，都视为无符号数，将余数的有符号扩展写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   111   rd   0111011
  --------- ----- ----- ----- ---- ---------

remw rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = sext(x\left\lbrack rs1 \right\rbrack\lbrack 31:0\rbrack\ \%_{s}\ x\lbrack rs2\rbrack\lbrack 31:0\rbrack)$

求余数字*(Remainder Word)*. R-type, RV64M only.

x\[*rs1*\]的低32位除以x\[*rs2*\]的低32位，向0舍入，都视为2的补码，将余数的有符号扩展写入x\[*rd*\]。

  --------- ----- ----- ----- ---- ---------
  0000001   rs2   rs1   110   rd   0111011
  --------- ----- ----- ----- ---- ---------

ret $pc = x\left\lbrack 1 \right\rbrack$

返回*(Return)*. 伪指令(Pseudoinstruction), RV32I and RV64I.

从子过程返回。实际被扩展为**jalr** x0, 0(x1)。

sb rs2, offset(rs1)
$M\lbrack x\left\lbrack rs1 \right\rbrack + sext(offset) = x\left\lbrack rs2 \right\rbrack\lbrack 7:0\rbrack\ $

存字节*(Store Byte)*. S-type, RV32I and RV64I.

将x\[*rs2*\]的低位字节存入内存地址x\[*rs1*\]+*sign-extend(offset)*。

  ---------------- ----- ----- ----- --------------- ---------
  offset\[11:5\]   rs2   rs1   000   offset\[4:0\]   0100011
  ---------------- ----- ----- ----- --------------- ---------

sc.d rd, rs2, (rs1)
$x\left\lbrack \text{rd} \right\rbrack = StoreConditonal64(M\lbrack x\left\lbrack rs1 \right\rbrack,\ x\left\lbrack rs2 \right\rbrack)$

条件存入双字*(Store-Conditional Doubleword)*. R-type, RV64A only.

如果内存地址x\[*rs1*\]上存在加载保留，将x\[*rs2*\]寄存器中的8字节数存入该地址。如果存入成功，向寄存器x\[*rd*\]中存入0，否则存入一个非0的错误码。

  ------- ---- ---- ----- ----- ----- ---- ---------
  00011   aq   rl   rs2   rs1   011   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

sc.w rd, rs2, (rs1)
$x\left\lbrack \text{rd} \right\rbrack = StoreConditonal32(M\lbrack x\left\lbrack rs1 \right\rbrack,\ x\left\lbrack rs2 \right\rbrack)$

条件存入字*(Store-Conditional Word)*. R-type, RV32A and RV64A.

内存地址x\[*rs1*\]上存在加载保留，将x\[*rs2*\]寄存器中的4字节数存入该地址。如果存入成功，向寄存器x\[*rd*\]中存入0，否则存入一个非0的错误码。

  ------- ---- ---- ----- ----- ----- ---- ---------
  00011   aq   rl   rs2   rs1   010   rd   0101111
  ------- ---- ---- ----- ----- ----- ---- ---------

sd rs2, offset(rs1)
$M\lbrack x\left\lbrack rs1 \right\rbrack + sext(offset) = x\left\lbrack rs2 \right\rbrack\lbrack 63:0\rbrack$

存双字*(Store Doubleword)*. S-type, RV64I only.

将x\[*rs2*\]中的8字节存入内存地址x\[*rs1*\]+*sign-extend(offset)*。

压缩形式：**c.sdsp** rs2, offset; **c.sd** rs2, offset(rs1)

  ---------------- ----- ----- ----- --------------- ---------
  offset\[11:5\]   rs2   rs1   011   offset\[4:0\]   0100011
  ---------------- ----- ----- ----- --------------- ---------

seqz rd, rs1
$x\left\lbrack \text{rd} \right\rbrack = (x\left\lbrack rs1 \right\rbrack = = 0)$

等于0则置位*(Set if Equal to Zero)*. 伪指令(Pseudoinstruction), RV32I
and RV64I.

如果x\[*rs1*\]等于0，向x\[*rd*\]写入1，否则写入0。实际被扩展为**sltiu**
rd, rs1, 1。

sext.w rd, rs1
$x\left\lbrack \text{rd} \right\rbrack = sext(x\lbrack rs1\rbrack\lbrack 31:0\rbrack)$

有符号字扩展*(Sign-extend Word)*. 伪指令(Pseudoinstruction), RV64I only.

读入x\[*rs1*\]的低32位，有符号扩展，结果写入x\[*rd*\]。实际被扩展为**addiw**
rd, rs1, 0。

sfence.vma rs1, rs2 $Fence(Store,\ \ AddressTranslation)$

虚拟内存屏障*(Fence Virtual Memory)*. R-type, RV32I and RV64I特权指令。

根据后续的虚拟地址翻译对之前的页表存入进行排序。当*rs2*=0时，所有地址空间的翻译都会受到影响；否则，仅对x\[*rs2*\]标识的地址空间的翻译进行排序。当*rs1*=0时，对所选地址空间中的所有虚拟地址的翻译进行排序；否则，仅对其中包含虚拟地址x\[*rs1*\]的页面地址翻译进行排序。

  --------- ----- ----- ----- ------- ---------
  0001001   rs2   rs1   000   00000   1110011
  --------- ----- ----- ----- ------- ---------

sgtz rd, rs2
$x\left\lbrack \text{rd} \right\rbrack = {(x\left\lbrack rs1 \right\rbrack >}_{s}0)$

大于0则置位*(Set if Greater Than Zero)*. 伪指令(Pseudoinstruction),
RV32I and RV64I.

如果x\[*rs2*\]大于0，向x\[*rd*\]写入1，否则写入0。实际被扩展为**slt**
rd, x0, rs2。

sh rs2, offset(rs1)
$M\lbrack x\left\lbrack rs1 \right\rbrack + sext(offset) = x\left\lbrack rs2 \right\rbrack\lbrack 15:0\rbrack$

存半字*(Store Halfword)*. S-type, RV32I and RV64I.

将x\[*rs2*\]的低位2个字节存入内存地址x\[*rs1*\]+*sign-extend(offset)*。

  ---------------- ----- ----- ----- --------------- ---------
  offset\[11:5\]   rs2   rs1   001   offset\[4:0\]   0100011
  ---------------- ----- ----- ----- --------------- ---------

sw rs2, offset(rs1)
$M\lbrack x\left\lbrack rs1 \right\rbrack + sext(offset) = x\left\lbrack rs2 \right\rbrack\lbrack 31:0\rbrack$

存字*(Store Word)*. S-type, RV32I and RV64I.

将x\[*rs2*\]的低位4个字节存入内存地址x\[*rs1*\]+*sign-extend(offset)*。

压缩形式：**c.swsp** rs2, offset; **c.sw** rs2, offset(rs1)

  ---------------- ----- ----- ----- --------------- ---------
  offset\[11:5\]   rs2   rs1   010   offset\[4:0\]   0100011
  ---------------- ----- ----- ----- --------------- ---------

sll rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = x\left\lbrack rs1 \right\rbrack \ll x\lbrack rs2\rbrack$

逻辑左移*(Shift Left Logical)*. R-type, RV32I and RV64I.

把寄存器x\[*rs1*\]左移x\[*rs2*\]位，空出的位置填入0，结果写入x\[*rd*\]。x\[*rs2*\]的低5位（如果是RV64I则是低6位）代表移动位数，其高位则被忽略。

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   001   rd   0110011
  --------- ----- ----- ----- ---- ---------

slli rd, rs1, shamt
$x\left\lbrack \text{rd} \right\rbrack = x\left\lbrack rs1 \right\rbrack \ll shamt$

立即数逻辑左移*(Shift Left Logical Immediate)*. I-type, RV32I and RV64I.

把寄存器x\[*rs1*\]左移*shamt*位，空出的位置填入0，结果写入x\[*rd*\]。对于RV32I，仅当*shamt*\[5\]=0时，指令才是有效的。

压缩形式：**c.slli** rd, shamt

  -------- ------- ----- ----- ---- ---------
  000000   shamt   rs1   001   rd   0010011
  -------- ------- ----- ----- ---- ---------

slliw rd, rs1, shamt
$x\left\lbrack \text{rd} \right\rbrack = sext(\left( x\left\lbrack rs1 \right\rbrack \ll shamt \right)\lbrack 31:0\rbrack)$

立即数逻辑左移字*(Shift Left Logical Word Immediate)*. I-type, RV64I
only.

把寄存器x\[*rs1*\]左移*shamt*位，空出的位置填入0，结果截为32位，进行有符号扩展后写入x\[*rd*\]。仅当*shamt*\[5\]=0时，指令才是有效的。

  -------- ------- ----- ----- ---- ---------
  000000   shamt   rs1   001   rd   0011011
  -------- ------- ----- ----- ---- ---------

sllw rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = sext(\left( x\left\lbrack rs1 \right\rbrack \ll x\lbrack rs2\rbrack\lbrack 4:0\rbrack \right)\lbrack 31:0\rbrack)$

逻辑左移字*(Shift Left Logical Word)*. R-type, RV64I only.

把寄存器x\[*rs1*\]的低32位左移x\[*rs2*\]位，空出的位置填入0，结果进行有符号扩展后写入x\[*rd*\]。x\[*rs2*\]的低5位代表移动位数，其高位则被忽略。

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   001   rd   0111011
  --------- ----- ----- ----- ---- ---------

slt rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = {(x\left\lbrack rs1 \right\rbrack <}_{s}x\lbrack rs2\rbrack)$

小于则置位*(Set if Less Than)*. R-type, RV32I and RV64I.

比较x\[*rs1*\]和x\[*rs2*\]中的数，如果x\[*rs1*\]更小，向x\[*rd*\]写入1，否则写入0。

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   010   rd   0110011
  --------- ----- ----- ----- ---- ---------

slti rd, rs1, immediate
$x\left\lbrack \text{rd} \right\rbrack = {(x\left\lbrack rs1 \right\rbrack <}_{s}sext(immediate))$

小于立即数则置位*(Set if Less Than Immediate)*. I-type, RV32I and RV64I.

比较x\[*rs1*\]和有符号扩展的*immediate*，如果x\[*rs1*\]更小，向x\[*rd*\]写入1，否则写入0。

  ------------------- ----- ----- ---- ---------
  immediate\[11:0\]   rs1   010   rd   0010011
  ------------------- ----- ----- ---- ---------

sltiu rd, rs1, immediate
$x\left\lbrack \text{rd} \right\rbrack = {(x\left\lbrack rs1 \right\rbrack <}_{u}sext(immediate))$

无符号小于立即数则置位*(Set if Less Than Immediate, Unsigned)*. I-type,
RV32I and RV64I.

比较x\[*rs1*\]和有符号扩展的*immediate*，比较时视为无符号数。如果x\[*rs1*\]更小，向x\[*rd*\]写入1，否则写入0。

  ------------------- ----- ----- ---- ---------
  immediate\[11:0\]   rs1   011   rd   0010011
  ------------------- ----- ----- ---- ---------

sltu rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = {(x\left\lbrack rs1 \right\rbrack <}_{u}x\lbrack rs2\rbrack)$

无符号小于则置位*(Set if Less Than, Unsigned)*. R-type, RV32I and RV64I.

比较x\[*rs1*\]和x\[*rs2*\]，比较时视为无符号数。如果x\[*rs1*\]更小，向x\[*rd*\]写入1，否则写入0。

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   011   rd   0110011
  --------- ----- ----- ----- ---- ---------

sltz rd, rs1
$x\left\lbrack \text{rd} \right\rbrack = {(x\left\lbrack rs1 \right\rbrack <}_{s}0)$

小于0则置位*(Set if Less Than to Zero)*. 伪指令(Pseudoinstruction),
RV32I and RV64I.

如果x\[*rs1*\]小于0，向x\[*rd*\]写入1，否则写入0。实际扩展为**slt** rd,
rs1, x0。

snez rd, rs2
$x\left\lbrack \text{rd} \right\rbrack = x\lbrack rs2\rbrack \neq 0)$

不等于0则置位*(Set if Not Equal to Zero)*. 伪指令(Pseudoinstruction),
RV32I and RV64I.

如果x\[*rs1*\]不等于0，向x\[*rd*\]写入1，否则写入0。实际扩展为**sltu**
rd, x0, rs2。

sra rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = {(x\left\lbrack rs1 \right\rbrack \gg}_{s}x\lbrack rs2\rbrack)$

算术右移*(Shift Right Arithmetic)*. R-type, RV32I and RV64I.

把寄存器x\[*rs1*\]右移x\[*rs2*\]位，空位用x\[*rs1*\]的最高位填充，结果写入x\[*rd*\]。x\[*rs2*\]的低5位（如果是RV64I则是低6位）为移动位数，高位则被忽略。

  --------- ----- ----- ----- ---- ---------
  0100000   rs2   rs1   101   rd   0110011
  --------- ----- ----- ----- ---- ---------

srai rd, rs1, shamt
$x\left\lbrack \text{rd} \right\rbrack = {(x\left\lbrack rs1 \right\rbrack \gg}_{s}shamt)$

立即数算术右移*(Shift Right Arithmetic Immediate)*. I-type, RV32I and
RV64I.

把寄存器x\[*rs1*\]右移*shamt*位，空位用x\[*rs1*\]的最高位填充，结果写入x\[*rd*\]。对于RV32I，仅当*shamt*\[5\]=0时指令有效。

压缩形式：**c.srai** rd, shamt

  -------- ------- ----- ----- ---- ---------
  010000   shamt   rs1   101   rd   0010011
  -------- ------- ----- ----- ---- ---------

sraiw rd, rs1, shamt
$x\left\lbrack \text{rd} \right\rbrack = {sext(x\left\lbrack rs1 \right\rbrack\lbrack 31:0\rbrack \gg}_{s}shamt)$

立即数算术右移字*(Shift Right Arithmetic Word Immediate)*. I-type, RV64I
only.

把寄存器x\[*rs1*\]的低32位右移*shamt*位，空位用x\[*rs1*\]\[31\]填充，结果进行有符号扩展后写入x\[*rd*\]。仅当*shamt*\[5\]=0时指令有效。

压缩形式：**c.srai** rd, shamt

  -------- ------- ----- ----- ---- ---------
  010000   shamt   rs1   101   rd   0011011
  -------- ------- ----- ----- ---- ---------

sraw rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = {sext(x\left\lbrack rs1 \right\rbrack\lbrack 31:0\rbrack \gg}_{s}x\left\lbrack rs2 \right\rbrack\lbrack 4:0\rbrack)$

算术右移字*(Shift Right Arithmetic Word)*. R-type, RV64I only.

把寄存器x\[*rs1*\]的低32位右移x\[*rs2*\]位，空位用x\[*rs1*\]\[31\]填充，结果进行有符号扩展后写入x\[*rd*\]。x\[*rs2*\]的低5位为移动位数，高位则被忽略。

  --------- ----- ----- ----- ---- ---------
  0100000   rs2   rs1   101   rd   0111011
  --------- ----- ----- ----- ---- ---------

sret $ExceptionReturn(Supervisor)$

管理员模式例外返回*(Supervisor-mode Exception Return)*. R-type, RV32I
and RV64I特权指令。

从管理员模式的例外处理程序中返回，设置*pc*为CSRs\[spec\]，权限模式为CSRs\[sstatus\].SPP，CSRs\[sstatus\].SIE为CSRs\[sstatus\].SPIE，CSRs\[sstatus\].SPIE为1，CSRs\[sstatus\].spp为0。

  --------- ------- ------- ----- ------- ---------
  0001000   00010   00000   000   00000   1110011
  --------- ------- ------- ----- ------- ---------

srl rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = {(x\left\lbrack rs1 \right\rbrack \gg}_{u}x\lbrack rs2\rbrack)$

逻辑右移*(Shift Right Logical)*. R-type, RV32I and RV64I.

把寄存器x\[*rs1*\]右移x\[*rs2*\]位，空出的位置填入0，结果写入x\[*rd*\]。x\[*rs2*\]的低5位（如果是RV64I则是低6位）代表移动位数，其高位则被忽略。

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   101   rd   0110011
  --------- ----- ----- ----- ---- ---------

srli rd, rs1, shamt
$x\left\lbrack \text{rd} \right\rbrack = {(x\left\lbrack rs1 \right\rbrack \gg}_{u}shamt)$

立即数逻辑右移*(Shift Right Logical Immediate)*. I-type, RV32I and
RV64I.

把寄存器x\[*rs1*\]右移*shamt*位，空出的位置填入0，结果写入x\[*rd*\]。对于RV32I，仅当*shamt*\[5\]=0时，指令才是有效的。

压缩形式：**c.srli** rd, shamt

  -------- ------- ----- ----- ---- ---------
  000000   shamt   rs1   101   rd   0010011
  -------- ------- ----- ----- ---- ---------

srliw rd, rs1, shamt
$x\left\lbrack \text{rd} \right\rbrack = {sext(x\left\lbrack rs1 \right\rbrack\lbrack 31:0\rbrack \gg}_{u}shamt)$

立即数逻辑右移字*(Shift Right Logical Word Immediate)*. I-type, RV64I
only.

把寄存器x\[*rs1*\]右移*shamt*位，空出的位置填入0，结果截为32位，进行有符号扩展后写入x\[*rd*\]。仅当*shamt*\[5\]=0时，指令才是有效的。

  -------- ------- ----- ----- ---- ---------
  000000   shamt   rs1   101   rd   0011011
  -------- ------- ----- ----- ---- ---------

srlw rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = {sext(x\left\lbrack rs1 \right\rbrack\lbrack 31:0\rbrack \gg}_{u}x\left\lbrack rs2 \right\rbrack\lbrack 4:0\rbrack)$

逻辑右移字*(Shift Right Logical Word)*. R-type, RV64I only.

把寄存器x\[*rs1*\]的低32位右移x\[*rs2*\]位，空出的位置填入0，结果进行有符号扩展后写入x\[*rd*\]。x\[*rs2*\]的低5位代表移动位数，其高位则被忽略。

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   101   rd   0111011
  --------- ----- ----- ----- ---- ---------

sub rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = x\left\lbrack rs1 \right\rbrack - x\left\lbrack rs2 \right\rbrack$

减*(Substract)*. R-type, RV32I and RV64I.

x\[*rs1*\]减去x\[*rs2*\]，结果写入x\[*rd*\]。忽略算术溢出。

压缩形式：**c.sub** rd, rs2

  --------- ----- ----- ----- ---- ---------
  0100000   rs2   rs1   000   rd   0110011
  --------- ----- ----- ----- ---- ---------

subw rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = sext\left( (x\left\lbrack rs1 \right\rbrack - x\left\lbrack rs2 \right\rbrack \right)\lbrack 31:0\rbrack)$

减去字*(Substract Word)*. R-type, RV64I only.

x\[*rs1*\]减去x\[*rs2*\]，结果截为32位，有符号扩展后写入x\[*rd*\]。忽略算术溢出。

压缩形式：**c.subw** rd, rs2

  --------- ----- ----- ----- ---- ---------
  0100000   rs2   rs1   000   rd   0111011
  --------- ----- ----- ----- ---- ---------

tail symbol $pc = \& symbol;\ clobber\ x\lbrack 6\rbrack$

尾调用*(Tail call)*. 伪指令(Pseudoinstuction), RV32I and RV64I.

设置*pc*为*symbol*，同时覆写x\[6\]。实际扩展为**auipc** x6,
offsetHi和**jalr** x0, offsetLo(x6)。

wfi
$\text{while\ }\left( \text{noInterruptPending} \right)\text{\ idle}$

等待中断*(Wait for Interrupt)*. R-type, RV32I and RV64I特权指令。

如果没有待处理的中断，则使处理器处于空闲状态。

  --------- ------- ------- ----- ------- ---------
  0001000   00101   00000   000   00000   1110011
  --------- ------- ------- ----- ------- ---------

xor rd, rs1, rs2
$x\left\lbrack \text{rd} \right\rbrack = x\left\lbrack rs1 \right\rbrack\ \ \hat{}\ \ x\left\lbrack rs2 \right\rbrack$

异或*(Exclusive-OR)*. R-type, RV32I and RV64I.

x\[*rs1*\]和x\[*rs2*\]按位异或，结果写入x\[*rd*\]。

压缩形式：**c.xor** rd, rs2

  --------- ----- ----- ----- ---- ---------
  0000000   rs2   rs1   100   rd   0110011
  --------- ----- ----- ----- ---- ---------

xori rd, rs1, immediate
$x\left\lbrack \text{rd} \right\rbrack = x\left\lbrack rs1 \right\rbrack\ \ \hat{}\ \ sext(immediate)$

立即数异或*(Exclusive-OR Immediate)*. I-type, RV32I and RV64I.

x\[*rs1*\]和有符号扩展的*immediate*按位异或，结果写入x\[*rd*\]。

压缩形式：**c.xor** rd, rs2

  ------------------- ----- ----- ---- ---------
  immediate\[11:0\]   rs1   100   rd   0010011
  ------------------- ----- ----- ---- ---------

[^1]: 定义RV32V的委员会没有赶在本书的测试版本之前完成他们的工作，所以我们在附录A中省略了这些指令。尽管到时候RV32V有可能会有一些微小的改变，第八章是我们对于它的最为接近的猜想。
