第二章 RV32I：RISC-V基础整数指令集

![](media/image1.emf){width="1.1in" height="2.2416666666666667in"}

...提升计算性能并且让用户能切实享受到性能提升的唯一方法是同时设计编译器和计算机。这样软件用不到的特性将不会被实现在硬件上...

------Frances Elizabeth "Fran" Allen, 1981

2.1 导言

![](media/image3.PNG){width="3.375in"
height="0.6333333333333333in"}图2.1是RV32I基础指令集的一页图形表示。对于每幅图，将有下划线的字母从左到右连接起来，即可组成完整的RV32I指令集。对于每一个图，集合标志{}内列举了指令的所有变体，变体用加下划线的字母或下划线字符\_表示。特别的，下划线字符\_表示对于此指令变体不需用字符表示。例如，下图表示了这四个RV32I指令：slt，slti，sltu，sltiu:

我们使用这些图（下面几章的第一个图），旨在对本章的指令给出一个进行快速、深入的概述。

![](media/image4.png){width="0.7in" height="0.6034722222222222in"}2.2
RV32I指令格式

![](media/image5.png){width="0.6263888888888889in"
height="0.6069444444444444in"}图2.2显示了六种基本指令格式，分别是：用于寄存器-寄存器操作的R类型指令，用于短立即数和访存load操作的I型指令，用于访存store操作的S型指令，用于条件跳转操作的B类型指令，用于长立即数的U型指令和用于无条件跳转的J型指令。图2.3使用图2.2的指令格式列出了图2.1中出现的所有RV32I指令的操作码。

![](media/image6.png){width="0.7833333333333333in"
height="0.4388888888888889in"}即使是指令格式也能从一些方面说明RISC-V
更简洁的ISA设计能提高提高性能功耗比。首先，指令只有六种格式，并且所有的指令都是32位长，这简化了指令解码。ARM-32，还有更典型的x86-32都有许多不同的指令格式，使得解码部件在低端实现中偏昂贵，在中高端处理器设计中容易带来性能挑战。第二，RISC-V指令提供三个寄存器操作数，而不是像x86-32一样，让源操作数和目的操作数共享一个字段。当一个操作天然就需要有三个不同的操作数，但是ISA只提供了两个操作数时，编译器或者汇编程序程序员就需要多使用一条move（搬运）指令，来保存目的寄存器的值。第三，在RISC-V中对于所有指令，要读写的寄存器的标识符总是在同一位置，意味着在解码指令之前，就可以先开始访问寄存器。在许多其他的ISA中，某些指令字段在部分指令中被重用作为源目的地，在其他指令中又被作为目的操作数（例如，ARM-32和MIPS-32）。因此，为了取出正确的指令字段，我们需要时序本就可能紧张的解码路径上添加额外的解码逻辑，使得解码路径的时序更为紧张。第四，这些格式的立即数字段总是符号扩展，符号位总是在指令中最高位。这意味着可能成为关键路径的立即数符号扩展，可以在指令解码之前进行。

![](media/image7.PNG){width="5.772222222222222in"
height="4.0368055555555555in"}

**图2.1：RV32I指令图示。把带下划线的字母从左到右连接就组成了RV32I指令。花括号{}表示集合中垂直方向上的每个项目都是指令的不同变体。集合中的下划线\_意味着不包含这个字母的也是一个指令名称。例如，左上角附近的符号表示以下六个指令：**and，or，xor，andi，ori，xori**。**

![](media/image8.PNG){width="5.772222222222222in"
height="1.8263888888888888in"}

**图2.2：RISC-V指令格式。我们用生成的立即数值中的位置（而不是通常的指令立即数域中的位置）(imm\[*x*\])标记每个立即数子域。第十章解释了控制状态寄存器指令使用I型格式的稍微不同的做法。（本图基于Waterman和Asanovi\'c
2017的图2.2）。 **

  imm\[31:12\]                 rd      0110111   U lui                                            
  ---------------------------- ------- --------- --------- ---------------- ----------- --------- -----------
  imm\[31:12\]                 rd      0010111   U auipc                                          
  imm\[20\|10:1\|11\|19:12\]   rd      1101111   J jal                                            
  imm\[11:0\]                  rs1     000       rd        1100111          I jalr                
  imm\[12\|10:5\]              rs2     rs1       000       imm\[4:1\|11\]   1100011     B beq     
  imm\[12\|10:5\]              rs2     rs1       001       imm\[4:1\|11\]   1100011     B bne     
  imm\[12\|10:5\]              rs2     rs1       100       imm\[4:1\|11\]   1100011     B blt     
  imm\[12\|10:5\]              rs2     rs1       101       imm\[4:1\|11\]   1100011     B bge     
  imm\[12\|10:5\]              rs2     rs1       110       imm\[4:1\|11\]   1100011     B bltu    
  imm\[12\|10:5\]              rs2     rs1       111       imm\[4:1\|11\]   1100011     B bgeu    
  imm\[11:0\]                  rs1     000       rd        0000011          I lb                  
  imm\[11:0\]                  rs1     001       rd        0000011          I lh                  
  imm\[11:0\]                  rs1     010       rd        0000011          I lw                  
  imm\[11:0\]                  rs1     100       rd        0000011          I lbu                 
  imm\[11:0\]                  rs1     101       rd        0000011          I lhu                 
  imm\[11:5\]                  rs2     rs1       000       imm\[4:0\]       0100011     S sb      
  imm\[11:5\]                  rs2     rs1       001       imm\[4:0\]       0100011     S sh      
  imm\[11:5\]                  rs2     rs1       010       imm\[4:0\]       0100011     S sw      
  imm\[11:0\]                  rs1     000       rd        0010011          I addi                
  imm\[11:0\]                  rs1     010       rd        0010011          I slti                
  imm\[11:0\]                  rs1     011       rd        0010011          I sltiu               
  imm\[11:0\]                  rs1     100       rd        0010011          I xori                
  imm\[11:0\]                  rs1     110       rd        0010011          I ori                 
  imm\[11:0\]                  rs1     111       rd        0010011          I andi                
  0000000                      shamt   rs1       001       rd               0010011     I slli    
  0000000                      shamt   rs1       101       rd               0010011     I srli    
  0100000                      shamt   rs1       101       rd               0010011     I srai    
  0000000                      rs2     rs1       000       rd               0110011     R add     
  0100000                      rs2     rs1       000       rd               0110011     R sub     
  0000000                      rs2     rs1       001       rd               0110011     R sll     
  0000000                      rs2     rs1       010       rd               0110011     R slt     
  0000000                      rs2     rs1       011       rd               0110011     Rsltu     
  0000000                      rs2     rs1       100       rd               0110011     R xor     
  0000000                      rs2     rs1       101       rd               0110011     R srl     
  0100000                      rs2     rs1       101       rd               0110011     R sra     
  0000000                      rs2     rs1       110       rd               0110011     R or      
  0000000                      rs2     rs1       111       rd               0110011     R and     
  0000                         pred    succ      00000     000              00000       0001111   I fence
  0000                         0000    0000      00000     001              00000       0001111   I fence.i
  000000000000                 00000   00        00000     1110011          I ecall               
  000000000000                 00000   000       00000     1110011          I ebreak              
  csr                          rs1     001       rd        1110011          I csrrw               
  csr                          rs1     010       rd        1110011          I csrrs               
  csr                          rs1     011       rd        1110011          I csrrc               
  csr                          zimm    101       rd        1110011          I csrrwi              
  csr                          zimm    110       rd        1110011          I cssrrsi             
  csr                          zimm    111       rd        1110011          I csrrci              

**图2.3：RV32I带有指令布局，操作码，格式类型和名称的操作码映射。（此图基于\[Waterman
and Asanovi\'c 2017\]的表19.2。）**

![](media/image9.png){width="0.6666666666666666in"
height="0.3770833333333333in"}

![](media/image10.png){width="0.7034722222222223in"
height="0.425in"}为了帮助程序员，所有位全部是0是非法的RV32I指令。因此,
试图跳转到被清零的内存区域的错误跳转将会立即触发异常，这可以帮助调试。类似地，所有位全部是1的指令也是非法指令，它将捕获其他常见的错误，诸如未编程的非易失性内存设备、断开连接的内存总线或者坏掉的内存芯片。

![](media/image5.png){width="0.6263888888888889in"
height="0.6069444444444444in"}
为了给ISA扩展留出足够的空间，最基础的RV32I指令集只使用了32位指令字中的编码空间的不到八分之一。架构师们也仔细挑选了RV32I操作码，使拥有共同数据通路的指令的操作码位有尽可能多的位的值是一样的，这简化了控制逻辑。最后,当我们看到，B和J格式的分支和跳转地址必须向左移动1位以将地址乘以2，从而给予分支和跳转指令更大的跳转范围。RISC-V将立即数中的位从自然排布进行了一些移位轮换，将指令信号的扇出和立即数多路复用的成本降低了近两倍，这也简化了低端实现中的数据通路逻辑。

**有什么不同之处？**在这一章和后面的章节的结束部分，我们将描述RISC-V与其他指令集的不同之处。这种对比通常是描述相比于其他指令集，RISC-V少了什么。省略什么特性和包括什么特性一样，都能体现架构师的精心设计。

![](media/image6.png){width="0.7833333333333333in"
height="0.4388888888888889in"} ARM-32
指令集12位的立即字段不仅仅是一个常量，而是一个函数的输入，此函数根据12位立即数的输入来产生一个常量：8位被零扩展到全宽度，然后被循环右移。右移的位数是12位立即数中剩余4位的值乘2。设计者希望在12位中编码更多有用的常数来减少执行指令的数量。在大多数指令格式中，ARM-32也将十分宝贵的四位编码空间拿出来专门用于条件执行。这些条件执行指令不仅使用频率低而且增加了乱序处理器的复杂性。

2.3 RV32I寄存器

![](media/image9.png){width="0.6666666666666666in"
height="0.3770833333333333in"}

图4列出了RV32I寄存器以及由RISC-V
应用程序二进制接口（ABI）所定义的寄存器名称。在我们的示例代码中，我们将使用ABI名称，使它们更容易阅读。为了满足汇编语言程序员和编译器编写者，RV32I有31寄存器加上一个值恒为0的x0寄存器。与之相比，ARM-32只有16个寄存器，x86-32甚至只有8
个寄存器。

![](media/image4.png){width="0.7in" height="0.6034722222222222in"}
**有什么不同之处？**为常量0单独分配一个寄存器是RISC-V
ISA能如此简单的一个很大的因素。第3章的第36页的图3给出了许多ARM-32和x86-32的原生指令操作，这两个指令集中没有零寄存器。我们可以用RV32I指令完成功能相同的操作，只需使用零寄存器作为操作数。

程序计数器（PC）是ARM-32的16个寄存器之一，这意味着任何改变寄存器的指令都有可能导致分支跳转。PC作为一个寄存器使硬件分支预测变得复杂，因为在典型的ISA中，仅10%-20%的指令为分支指令，而在ARM-32中，任何指令都有可能是分支指令。而分支预测的准确性对于良好的流水线性能至关重要。另外将PC作为一个寄存器也意味着可用的通用寄存器少了一个。

2.4 RV32I整数计算

附录A给出了所有RISC-V指令的细节信息，包括格式和操作码。在本节以及接下来的章节的类似小节中，我们将给出ISA的一些概述。这能够让有基础的汇编语言程序员了解RISC-V，同时也顺便说明RISC-V的特性如何满足第一章中阐述的七个ISA指标。

简单的算术指令（add, sub）、逻辑指令（and, or,
xor），以及图2.1中的移位指令（sll, srl,
sra）和其他ISA差不多。他们从寄存器读取两个32位的值，并将32位结果写入目标寄存器。RV32I还提供了这些指令的立即数版本。和ARM-32不同，立即数总是进行符号扩展，这样子如果需要，我们可以用立即数表示负数，正因为如此，我们并不需要一个立即数版本的sub。

![](media/image4.png){width="0.7in"
height="0.6034722222222222in"}程序可以根据比较结果生成布尔值。为应对这种使用场景下，RV32I提供一个当小于时置位的指令。如果第一个操作数小于第二个操作数，它将目标寄存器设置为1，否则为0。不出所料，对这个指令，有一个有符号版本（slt）和无符号版本（sltu），分别用于处理有符号和无符号整数比较。相应的，上述两条指令也有立即数版本的（slti，sltiu）。正如我们将要看到的，虽然RV32I分支指令可以检查两个寄存器之间的所有关系，但一些条件表达式涉及多对寄存器之间的关系。对于这些表达式，编译器或汇编语言程序员可以将slt以及与或异或等逻辑指令组合使用来解决更复杂的条件表达式。

![](media/image9.png){width="0.6666666666666666in"
height="0.3770833333333333in"}
图2.1剩下的两条整数计算指令主要用于构造大的常量数值和链接。加载立即数到高位（lui）将20位常量加载到寄存器的高20位。接着便可以使用标准的立即指令来创建32位常量。这样子，仅使用2条32位RV32I指令，便可构造一个32位常量。向PC高位加上立即数（auipc）让我们仅用两条指令，便可以基于当前PC以任意偏移量转移控制流或者访问数据。将auipc中的20位立即数与jalr（参见下面）中12位立即数的组合，我们可以将执行流转移到任何32位PC相对地址。而auipc加上普通加载或存储指令中的12位立即数偏移量，使我们可以访问任何32位PC相对地址的数据。

![](media/image4.png){width="0.7in"
height="0.6034722222222222in"}**有什么不同之处？**首先，RISC-V中没有字节或半字宽度的整数计算操作。操作始终是以完整的寄存器宽度。内存访问需要的能量比算术运算高几个数量级。因此低宽度的数据访问可以节省大量的能量，但低宽度的运算不会。ARM-32具有一个不寻常的功能，对于大多数算术逻辑运算中的一个操作数，你可以选择对它进行移位。尽管这些指令的使用频率很低，但它使数据路径和数据通路更加复杂。与此相对的是，RV32I提供了单独的移位指令。

![](media/image5.png){width="0.6263888888888889in"
height="0.6069444444444444in"}RV32I也不包含乘法和除法，它们包含在可选的RV32M扩展中（参见第4章）。与ARM-32和x86-32不同，即使处理器没有添加乘除法扩展，完整的RISC-V软件栈也可以运行，这可以缩小嵌入式芯片的面积。MIPS-32汇编程序可能用一系列移位以及加法指令来替换乘法，以提高性能，这可能会使程序员看到处理器执行了汇编程序中没有的指令，进而造成混淆。RV32I可以忽略了这些特性：循环移位指令和整数算术溢出检测，这两个特性都可以用若干条RV32I指令来实现（参见第2.6节）。

**图2.4：RV32I的寄存器。第3章解释了RISC-V调用约定，各种指针（sp，gp，tp，fp），保存寄存器（s0-s11）和临时寄存器（t0-t6）背后的基本原理（基于\[Waterman
and Asanovi\'c
2017\]的图2.1和表20.1）。**![](media/image11.PNG){width="5.7652777777777775in"
height="7.280555555555556in"}

2.5 RV32I的Load和Store

除了提供32位字（lw，sw）的加载和存储外，图2.1中说明，RV32I
支持加载有符号和无符号字节和半字（lb，lbu，lh，lhu）和存储字节和半字（sb，sh）。有符号字节和半字符号扩展为32位再写入目的寄存器。即使是自然数据类型更窄，低位宽数据也是被扩展后再处理，这使得后续的整数计算指令能正确处理所有的32位。在文本和无符号整数中常用的无符号字节和半字，在写入目标寄存器之前都被无符号扩展到32位。

![](media/image4.png){width="0.7in"
height="0.6034722222222222in"}加载和存储的支持的唯一寻址模式是符号扩展12位立即数到基地址寄存器，这在x86-32中被称为位偏移寻址模式\[Irvine
2014\]。

**有什么不同之处？**RV32I省略了ARM-32和x86-32的复杂寻址模式。另外，ARM-32提供的寻址模式并非适用于所有数据类型，但RV32I
寻址不会歧视任何数据类型。RISC-V可以模仿某些x86寻址模式。例如，将立即数字段设置为0即与x86中的寄存器间接寻址效果相同。与x86-32不同，RISC-V没有特殊的堆栈指令。将31个寄存器中的某一个作为堆栈指针（见图2.4），标准寻址模式使用起来和压栈（push）和出栈（pop）类似，并且不增加ISA的复杂性。与MIPS-32不同，RISC-V不支持延迟加载（*delayed
load*）。与延迟分支的设计相似，为了更好的适应五级流水线，MIPS-32重新定义了load指令的语义，load上来的数据在load指令两个指令后才可用。但是对于后来出现的更长的流水线，延迟加载带来的收益逐渐消失，因此RISC-V不支持延迟加载。

![](media/image9.png){width="0.6666666666666666in"
height="0.3770833333333333in"}![](media/image5.png){width="0.6263888888888889in"
height="0.6069444444444444in"}
虽然ARM-32和MIPS-32要求存储在内存中的数据，要按照数据的自然大小进行边界对齐，但是RISC-V没有这个要求。移植旧的代码有时需要未对齐的访问。对于不对齐访问，一种选择是在基础ISA中禁止不对齐访问，然后提供一些单独的指令用于不对齐访问，例如MIPS-32中的Load
Word Left和Load Word Right。然而，这会使寄存器访问变得复杂，因为lwl
并且lwr需要对寄存器进行部分写，而不是简单地对寄存器进行完整的写。支持不对齐访问的，另一种方法就是让普通的加载和存储指令支持不对齐访问，这简化了整体设计。

2.6 RV32I条件分支

RV32I可以比较两个寄存器并根据比较结果上进行分支跳转。比较可以是：相等（beq），不相等
（bne），大于等于（bge），或小于（blt）。最后两种比较有符号比较，RV32I也提供相应的无符号版本比较的：bgeu和bltu。剩下的两个比较关系（大于和小于等于）可以通过简单地交换两个操作数，即可完成比较。因为x
\< y表示y \> x且x ≥ y表示y ≤ x。

![](media/image9.png){width="0.6666666666666666in"
height="0.3770833333333333in"}由于RISC-V指令长度必须是两个字节的倍数------关于可选的双字节指令
，请参考第七章------分支指令的寻址方式是12位的立即数乘以2，符号扩展它，然后将得到值加到PC上作为分支的跳转地址。PC相对寻址可用于位置无关的代码，简化了链接器和加载器的工作（第3章）。

![](media/image4.png){width="0.7in"
height="0.6034722222222222in"}**有什么不同之处？**如上所述，RISC-V去掉了MIPS-32，Oracle
SPARC等指令集中被广为诟病的延迟分支特性等。对于条件分支，它还没有像ARM-32和x86-32那样使用条件码。条件码的存在使得大多数指令都需要隐式设置一些额外状态，这使乱序执行的依赖计算复杂化。最后，它省略了x86-32中的循环指令：loop，loope，loopz，loopne，loopnz。

2.7 RV32I无条件跳转

![](media/image4.png){width="0.7in"
height="0.6034722222222222in"}图2.1中的跳转并链接指令（jal）具有双重功能。若将下一条指令PC
+
4的地址保存到目标寄存器中，通常是返回地址寄存器ra（见图2.4），便可以用它来实现过程调用。如果使用零寄存器（x0）替换ra作为目标寄存器，则可以实现无条件跳转，因为x0不能更改。像分支一样，jal将其20位分支地址乘以2，进行符号扩展后再添加到PC上，便得到了跳转地址。

跳转和链接指令的寄存器版本（jalr）同样是多用途的。它可以调用地址是动态计算出来的函数，或者也可以实现调用返回（只需ra作为源寄存器，零寄存器（x0）作为目的寄存器）。Switch和case语句的地址跳转，也可以使用jalr指令，目的寄存器设为x0。

**有什么不同之处？**RV32I避开了错综复杂的程序调用指令，例如x86-32的进入和离开指令，或Intel
Itanium，Oracle SPARC和Cadence Tensilica中的寄存器窗口。

2.8 RV32I杂项

图2.1中的控制状态寄存器指令
(csrrc、csrrs、csrrw、csrrci、csrrsi、csrrwi)，使我们可以轻松地访问一些程序性能计数器。对于这些64位计数器,
我们一次可以读取32位。这些计数器包括了系统时间,
时钟周期以及执行的指令数目。

在RISC-V指令集中，ecall指令用于向运行时环境发出请求，例如系统调用。调试器使用ebreak指令将控制转移到调试环境。

fence指令对外部可见的访存请求，如设备I /
O和内存访问等进行串行化。外部可见指对处理器的其他核心、线程，外部设备或协处理器可见。fence.i指令同步指令和数据流。在执行fence.i指令之前，对于同一个硬件线程，RISC-V不保证用存储指令写到内存指令区的数据可以被取指令取到。

第10章介绍RISC-V系统指令。

![](media/image12.PNG){width="4.32537510936133in"
height="1.991839457567804in"}**图 2.5:**
**C语言版的插入排序。虽然看起来简单, 插入排序比复杂的排序算法有许多优势:
对于小数据集来说,
它是内存使用效率高、速度快，同时还有适应性强、稳定、能在线处理的特点。gcc编译器生成了以下四个数字的代码。我们设置优化标志以减少代码大小，因为这产生了最容易理解的代码。**

![](media/image13.PNG){width="5.772222222222222in"
height="0.5222222222222223in"}

**图 2.6:
插入排序在不同指令集下生成的指令数目以及指令大小。第7章会介绍ARM
Thumb-2, microMIPS以及RV32C指令集。**

![](media/image4.png){width="0.7in"
height="0.6034722222222222in"}**有什么不同之处？**RISC-V使用内存映射I /
O而不是像x86-32一样，使用in，ins，insb，insw和out，out，outsb等指令来进行I/O。为支持字符串处理，RISC-V实现了字节存取，而不是像x86-32那样实现了
rep，movs，coms，scas，lods等16条特殊的字符串处理指令。

2.9 使用插入排序比较RV32I，ARM-32，MIPS-32和x86-32指令集

我们已经介绍了RISC-V基本指令集，并说明了与ARM-32，MIPS-32和x86-32相比，它做了哪些取舍。我们现在通过真实程序来进行一场直接的较量。图2.5显示了我们的基准测试------用C实现的插入排序。图2.6是一个表，它总结了在编译到不同ISA后，插入排序的指令数和字节数。

图2.8至2.11显示了插入排序编译生成的RV32I，ARM-32，MIPS-32和x86-32的汇编代码。尽管强调简单性，RISC-V版本使用相同数目或更少的指令，
并且不同架构的代码大小非常接近。在此示例中，RISC-V的比较、执行分支指令和ARM-32和x86-32中花式繁多的寻址模式以及入栈出栈指令一样，能够节省大量指令。

2.10 结束语

那些不记得过去的人，注定要重复过去。------George Santayana, 1905

图2.7使用第1章中的七个ISA设计指标来组织前面提到的一些过去的指令集中学习到的经验教训，并说明了这些经验教训对RV32I设计的积极影响。我们并不是说RISC-V是第一个拥有这些积极结果的ISA。事实上，RV32I从RISC-I，它的曾祖父母\[Patterson
2017\]那里，继承了如下这些特性：

-   32位字节可寻址的地址空间

-   所有指令均为32位长

-   31个寄存器，全部32位宽，寄存器0硬连线为零

-   所有操作都在寄存器之间（没有寄存器到内存的操作）

-   加载/存储字加上有符号和无符号加载/存储字节和半字

-   所有算术，逻辑和移位指令都有立即数版本的指令

-   立即数总是符号扩展

-   仅提供一种数据寻址模式（寄存器+立即数）和PC相对分支

-   无乘法或除法指令

-   一个指令，用于将大立即数加载到寄存器的高位，这样加载32位常量到寄存器只需要两条指令

> ![](media/image14.png){width="0.6560247156605424in"
> height="0.674248687664042in"}

RISC-V的出现比过去的ISA晚了四分之一到三分之一个世纪后开始，这使它的设计者得以实践Santayana的建议，即借用之前指令集中好的设计，但不重复它们不好的瑕疵
-
包括RISC-I指令集中的瑕疵。另外RISC-V基金会将通过可选的指令集扩展的方式缓慢扩展着指令集，以避免出现困扰过去的成功指令集的疯狂的增量发展。

2.11 扩展阅读

Lindy effect, 2017. URL https://en.wikipedia.org/wiki/Lindy\_effect.

> T. Chen and D. A. Patterson. RISC-V genealogy. Technical Report
> UCB/EECS-2016-6, EECS Department, University of California, Berkeley,
> Jan 2016. URL
> http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-6.html.

W. Hohl and C. Hinds. *ARM Assembly Language: Fundamentals and
Techniques*. CRC

Press, 2016.

K. R. Irvine. *Assembly language for x86 processors*. Prentice Hall,
2014.

D. Patterson. How close is RISC-V to RISC-I?, 2017.

A. Waterman and K. Asanovi´c, editors. *The RISC-V Instruction Set
Manual, Volume I:*

*User-Level ISA, Version 2.2*. May 2017. URL
https://riscv.org/specifications/.

注记

http://parlab.eecs.berkeley.edu

+-------------+-------------+-------------+-------------+-------------+
|             | 过去的错误  | RV32I       |             |             |
|             |             | (2011)吸取的经验 |        |             |
|             | ARM-32      | 教训        |             |             |
|             | (1986)      |             |             |             |
|             | MIPS-32     |             |             |             |
|             | (1986)      |             |             |             |
|             | x86-32      |             |             |             |
|             | (1978)      |             |             |             |
+=============+=============+=============+=============+=============+
| 成本        | 必须支持整数乘除法 | 必须支持整数乘除法 | 8位以及16位操作、必 | 无8位、16位操作、可 |
|             |             |             | 须支持整数乘除法 | 选的整数乘除法支持(R |
|             |             |             |             | V32M)       |
+-------------+-------------+-------------+-------------+-------------+
| 简洁性      | 无零寄存器、条件指令执 | 立即数支持零扩展及符号 | 无零寄存器、复杂的过程 | 寄存器x0专门用于存放 |
|             | 行、复杂的寻址模式、栈 | 扩展、一些算术指令会造 | 调用指令(enter/ | 常数0、立即数只进行符 |
|             | 操作指令（push/p | 成溢出异常 | leave)、栈指令( | 号扩展 |
|             | op）、算术/逻辑指令 |     | push/pop)、复 | 、一种数据寻址模式、没 |
|             | 中存在移位  |             | 杂寻址模式、循环指令 | 有条件执行、没有复杂的 |
|             |             |             |             | 函数调用指令以及栈指令 |
|             |             |             |             | 、算术指令不抛异常、使 |
|             |             |             |             | 用单独的移位指令来处理 |
|             |             |             |             | 移位操作    |
+-------------+-------------+-------------+-------------+-------------+
| 性能        | 分支指令使用条件码、在 | 在不同格式的指令中，源 | 分支指令使用条件码、每 | 使用同一条指令实现比较 |
|             | 不同格式的指令中，源和 | 和目的寄存器的位置不同 | 个指令中最多只能使用两 | 及跳转（不使用条件码） |
|             | 目的寄存器的位置不同、 |  | 个寄存器    | 、每条指令三个寄存器 |
|             | 加载多个计算得到的立即 |  |             |             |
|             | 数、PC是一个通用寄存 |    |             | 、不能一次load多个 |
|             | 器          |             |             | 数据、不同指令格式中， |
|             |             |             |             | 源及目的寄存器字段位置 |
|             |             |             |             | 固定、立即数是常数（不 |
|             |             |             |             | 是由计算得出的）、PC |
|             |             |             |             | 不是通用寄存器 |
+-------------+-------------+-------------+-------------+-------------+
| 架构和具体实现的分离 | 将PC像普通寄存器一样 | 分支指令延迟槽、Loa | 寄存器不是通用的(AX | 分支指令没有延迟槽、L |
|             | 读写，这样暴露了流水线 | d指令延迟槽、乘除法使 | ,CX,DX, | oad指令无延迟槽、通 |
|             | 长度        | 用单独的HI，LO寄存 | DI,SI有特殊用途) | 用寄存器 |
|             |             | 器          |             |             |
+-------------+-------------+-------------+-------------+-------------+
| 增长空间    | 有限的指令码空间 | 有限的指令码空间 |   | 大量可用的指令码空间 |
+-------------+-------------+-------------+-------------+-------------+
| 程序大小    | 仅有32bit指令 | 仅32bit指令(mi | 指令长度可用是不同字节 | 32位指令+16位 |
|             |             | croMIPS是作为一 | ，但这是一个很不好的选 |  |
|             | (Thumb-2    | 个独立的ISA) | 择         | RV32C 扩展  |
|             | 是作为一个独立的ISA |     |             |             |
|             | )           |             |             |             |
+-------------+-------------+-------------+-------------+-------------+
| 易于编程/编译/链接 | 仅15个寄存器内存数据 | 内存数据必须对齐、不规 | 仅15个寄存器内存数据 | 31个寄存器、数据可用 |
|             | 必须对齐、不规则的数据 | 则的数据寻址模式、不一 | 必须对齐、不规则的数据 | 不对齐、PC相对的数据 |
|             | 寻址模式、不一致的性能 | 致的性能计数器 | 寻址模式、不一致的性能 | 寻址模式 |
|             | 计数器      |             | 计数器      | 、对称的数据寻址模式、 |
|             |             |             |             | 定义在架构中的性能计数 |
|             |             |             |             | 器          |
+-------------+-------------+-------------+-------------+-------------+

**图2.7：RISC-V架构师从过去指令集设计的错误中吸取的教训。通常的教训是避免过去的ISA"优化"。经验和教训按照第一章中提出的七个ISA指标进行分类。在成本，简单性和性能下列出的许多指令集特性可以互换，因为这只是设计的偏好问题，但不管它们出现在哪里，它们都很重要。**

![](media/image15.PNG){width="5.772222222222222in"
height="4.627777777777778in"}

**图2.8：插入排序的RV32I代码如图2.5所示。十六进制的地址在左边，
接下来是十六进制的机器语言代码，然后是汇编语言指令，最后是评论以及注释。RV32I分配两个寄存器用以指向a\[j\]和a\[j-1\]。RV32I有很多寄存器，其中一些被ABI预留用于函数调用。与其他ISA不同，它会跳过保存和恢复寄存器值到内存的过程。虽然代码大小大于x86-32，但使用可选的RV32C指令（请参阅第七章）缩小了指令大小的差距。注意RV32I中的一条比较和分支指令顶得上ARM-32和x86-32比较所需的三条指令。**

![](media/image16.PNG){width="5.772222222222222in"
height="3.9930555555555554in"}

**图2.9：图2.5中插入排序的ARM-32代码。十六进制的地址在左边，接下来是十六进制的机器语言代码，然后是汇编语言指令，最后是注释、评论。由于寄存器不足，为了腾出两个空寄存器，以便之后重用，ARM-32将两个寄存器的值保存到堆栈中（和返回地址放在一起）。它使用了一种将i和j缩放为字节地址的寻址方式。鉴于分支跳转需要同时适用于ARM-32和Thumb-2，bxcs首先设置返回的最低有效位保存前地址为0。条件码使得我们在递减j后在检查它时可以少用一条比较指令，但在其他地方比较仍然需要三条指令。**

![](media/image17.PNG){width="5.708333333333333in" height="5.325in"}

**图2.10：图2.5中插入排序的MIPS-32代码。十六进制的地址在左边，接下来是十六进制的机器语言代码，然后是汇编语言指令，最后是注释。MIPS-32代码中有三条**nop**指令，这增加了它的长度。两个是由于延迟分支，另一个是由于延迟加载。编译器无法找到有用的指令来填充延迟槽。延迟的分支也使代码更难理解，因为不管分支会不会跳转，延迟槽中的指令都会被执行。例如，地址5c处的最后一条指令（**addiu**）是循环的一部分，尽管它是在分支指令之后。**

![](media/image18.PNG){width="5.772222222222222in"
height="4.361805555555556in"}

**图2.11：图2.5中插入排序的x86-32代码。十六进制的地址在左边，接下来是十六进制的机器语言代码，然后是汇编语言指令，最后是注释。由于缺少寄存器，x86-32将将两个寄存器保存在堆栈中，以便腾出这两个寄存器供后续使用。而且，本来在RV32I中可以分配到寄存器的两个变量（n和指向a\[0\]的指针），现在是保存在内存中的。它使用扩展下标索引寻址模式，这对于访问\[i\]和\[j\]具有良好效果。
这里的20条x32-86指令中有7个是只有一个字节那么长，这使得对于这个简单的程序，x86-32的代码规模很小。x86有两个流行的汇编语言版本：Intel
/ Microsoft和AT＆T /
Linux。我们使用英特尔语法，部分原因是它将目的地放在左边，而源操作数放在右边，与RISC-V，ARM-32和MIPS-32的操作数顺序一致。而AT＆T的操作数顺序则与之相反（并且对于寄存器操作数，需要在名字前加上%）。对于一些程序员来说，这看似微不足道的事情几乎是一个宗教问题。我们这里做出这样的选择，纯粹是因为教学方便，而非因为所谓"正统的信仰"。**
